
好的，我们来一步步地为 `bt_g2.5t_strategy.py` 文件实现《BT日志系统开发需求文档 v11.txt》中定义的增强日志系统。我们将严格遵循需求文档，并尽量减少对现有代码的改动。

**核心思路：**

1.  **引入日志模块:** 使用 Python 内置的 `logging` 模块。
2.  **配置日志:** 在策略运行前设置好日志格式 (JSONL)、输出文件、异步写入等。
3.  **添加日志接口:** 在 `AShareETFStrategy` 类中添加 `log_event` 方法，用于统一记录日志。
4.  **管理 `trade_cycle_id`:** 这是关键，确保每个交易周期（从信号识别到交易关闭）都有唯一的 ID，并在相关日志中记录。需要一个映射来关联 `order.ref` 和 `trade_cycle_id`。
5.  **植入日志点:** 在策略的关键位置（初始化、信号触发、订单计算、下单、订单状态更新、交易关闭等）调用 `log_event` 记录信息。

**详细步骤与代码修改：**

**一、 准备工作：添加必要的库导入**

在 `bt_g2.5t_strategy.py` 文件开头添加以下导入语句：

```python
# -*- coding: utf-8 -*-
# ... (保留原有导入) ...
import logging
import logging.handlers
import json
import uuid
import datetime
import pytz
import threading
import queue
import sys
import os
from collections import OrderedDict # 如果需要记录有序字典

# 定义日志事件类型常量 (根据需求文档)
STRATEGY_INIT = 'STRATEGY_INIT'
MARKET_STATE_ASSESSED = 'MARKET_STATE_ASSESSED'
SIGNAL_TRIGGERED = 'SIGNAL_TRIGGERED'
ORDER_CALCULATION = 'ORDER_CALCULATION'
ORDER_SUBMITTED = 'ORDER_SUBMITTED'
ORDER_STATUS_UPDATE = 'ORDER_STATUS_UPDATE'
SL_TP_TRIGGERED = 'SL_TP_TRIGGERED'
TRADE_CLOSED = 'TRADE_CLOSED'
RISK_EVENT = 'RISK_EVENT'
TRADE_SKIPPED = 'TRADE_SKIPPED'
# ... (可以根据需要添加更多事件类型) ...
```

**二、 实现日志配置和设置 (通常在主脚本部分完成)**

我们需要一个函数来设置日志系统。由于我们是修改 `bt_g2.5t_strategy.py`，我们可以在这个文件中添加一个辅助函数，然后在 `run_backtest` 中调用它。

```python
# ... (在导入语句之后，策略类定义之前) ...

# --- 日志系统设置 ---

class JsonFormatter(logging.Formatter):
    """自定义JSON格式化器"""
    def format(self, record):
        log_entry = {
            'timestamp': datetime.datetime.fromtimestamp(record.created, tz=pytz.utc).isoformat(),
            'level': record.levelname,
            'message': record.getMessage() # getMessage() 返回的是已经格式化好的字符串，这里假设message本身就是json字符串或者字典
        }
        # 如果 record.msg 是字典，直接更新 log_entry
        if isinstance(record.msg, dict):
            log_entry['message'] = record.msg # 直接使用字典作为消息体
            # 确保标准字段不被覆盖 (如果需要强制标准字段)
            log_entry.update(record.msg) # 允许消息体覆盖level等，但保留timestamp
            log_entry['timestamp'] = datetime.datetime.fromtimestamp(record.created, tz=pytz.utc).isoformat() # 强制时间戳
            log_entry['level'] = record.levelname # 强制级别
        try:
            # 尝试将完整的 log_entry 序列化为 JSON Lines
            # 使用 ensure_ascii=False 支持中文等非 ASCII 字符
            # 使用 separators 减少输出大小
            return json.dumps(log_entry, ensure_ascii=False, separators=(',', ':'))
        except TypeError as e:
            # 处理无法序列化的对象，记录错误并返回简化信息
            log_entry['message'] = f"Error serializing log message: {record.getMessage()}. Error: {e}"
            log_entry['serialization_error'] = True
            return json.dumps(log_entry, ensure_ascii=False, separators=(',', ':'))

log_queue = queue.Queue(-1) # 无限大小队列
log_listener = None
logger = None

def setup_logging(config):
    """
    配置日志系统

    :param config: 包含日志配置的字典，例如:
        {
            'log_path': 'logs',
            'log_filename_pattern': '{strategy_name}_{data_name}_{timestamp:%Y%m%d_%H%M%S}.log',
            'log_level': 'INFO', # 'DEBUG' or 'INFO'
            'log_async_write': True,
            'strategy_name': 'MyStrategy', # 需要传入策略名
            'data_name': 'MyData' # 需要传入数据名
            # 可选: 'log_rotation_size_mb', 'log_rotation_backup_count'
        }
    :return: 配置好的 logger 对象
    """
    global logger, log_listener

    log_level = getattr(logging, config.get('log_level', 'INFO').upper(), logging.INFO)
    log_path = config.get('log_path', 'logs')
    os.makedirs(log_path, exist_ok=True) # 确保日志目录存在

    # --- 文件名格式化 ---
    # 提供默认值，防止缺少关键配置项
    strategy_name = config.get('strategy_name', 'UnknownStrategy')
    data_name = config.get('data_name', 'UnknownData')
    timestamp = datetime.datetime.now()
    pid = os.getpid()

    try:
        # 尝试格式化文件名，处理可能的缺失键
        filename_pattern = config.get('log_filename_pattern', '{strategy_name}_{data_name}_{timestamp:%Y%m%d_%H%M%S}_{pid}.log')
        log_filename = filename_pattern.format(
            strategy_name=strategy_name,
            data_name=data_name,
            timestamp=timestamp,
            pid=pid
        )
    except KeyError as e:
        print(f"日志文件名模板错误: 缺少键 {e}，使用默认文件名。", file=sys.stderr)
        log_filename = f"{strategy_name}_{data_name}_{timestamp:%Y%m%d_%H%M%S}_{pid}_default.log" # 提供一个安全的默认名

    log_filepath = os.path.join(log_path, log_filename)

    formatter = JsonFormatter()

    if config.get('log_async_write', True):
        # --- 异步写入 ---
        # **讲人话**: 为了不让写日志拖慢交易策略的速度，我们把写日志的任务交给一个后台小助手去完成。
        # 1. **红色字体**: 使用 `QueueHandler` + `QueueListener` 实现异步写入。
        #    **讲人话**: 我们建了一个队列 (`QueueHandler`)，策略把日志消息扔进队列里就行了，然后有个监听器 (`QueueListener`) 专门负责从队列里取出消息，慢慢写入文件。
        queue_handler = logging.handlers.QueueHandler(log_queue)
        logger = logging.getLogger(strategy_name) # 使用策略名作为 logger 名称
        logger.addHandler(queue_handler)
        logger.setLevel(log_level)
        logger.propagate = False # 防止日志向上传递给 root logger

        # 文件处理器，监听器会用这个来写文件
        file_handler = logging.FileHandler(log_filepath, encoding='utf-8')
        # 可选：添加日志轮转
        rotation_size_mb = config.get('log_rotation_size_mb')
        if rotation_size_mb:
            backup_count = config.get('log_rotation_backup_count', 5)
            file_handler = logging.handlers.RotatingFileHandler(
                log_filepath,
                maxBytes=rotation_size_mb * 1024 * 1024,
                backupCount=backup_count,
                encoding='utf-8'
            )

        file_handler.setFormatter(formatter)

        # 停止旧的监听器（如果存在）
        if log_listener and log_listener.is_alive():
            log_listener.stop()

        log_listener = logging.handlers.QueueListener(log_queue, file_handler, respect_handler_level=True)
        log_listener.start()
        print(f"日志系统已启动 (异步模式)，日志文件: {log_filepath}")

    else:
        # --- 同步写入 ---
        # **讲人话**: 如果不需要那么快，或者配置里关掉了异步，那就直接写日志文件。
        # 1. **红色字体**: 直接使用 `FileHandler` 进行同步写入。
        #    **讲人话**: 策略每次要写日志，就直接操作文件写入，可能会稍微慢一点点。
        logger = logging.getLogger(strategy_name)
        logger.setLevel(log_level)
        logger.propagate = False

        # 文件处理器
        file_handler = logging.FileHandler(log_filepath, encoding='utf-8')
         # 可选：添加日志轮转
        rotation_size_mb = config.get('log_rotation_size_mb')
        if rotation_size_mb:
            backup_count = config.get('log_rotation_backup_count', 5)
            file_handler = logging.handlers.RotatingFileHandler(
                log_filepath,
                maxBytes=rotation_size_mb * 1024 * 1024,
                backupCount=backup_count,
                encoding='utf-8'
            )

        file_handler.setFormatter(formatter)
        logger.addHandler(file_handler)
        print(f"日志系统已启动 (同步模式)，日志文件: {log_filepath}")

    # 添加基本的标准错误流处理器，用于捕获日志系统本身的错误
    stderr_handler = logging.StreamHandler(sys.stderr)
    stderr_handler.setLevel(logging.ERROR) # 只记录错误级别的信息到 stderr
    stderr_handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
    logging.getLogger(strategy_name).addHandler(stderr_handler) # 添加到特定 logger
    # logging.getLogger().addHandler(stderr_handler) # 或者添加到 root logger

    return logger

def stop_logging():
    """停止日志监听器线程"""
    global log_listener
    if log_listener:
        log_listener.stop()
        log_listener = None
        print("日志监听器已停止。")

# --- 结束日志系统设置 ---
```

**三、 修改 `AShareETFStrategy` 类**

1.  **修改 `__init__` 方法:**
    *   接收 `logger` 对象。
    *   初始化 `strategy_id` 和 `order_ref_to_trade_id_map`。
    *   记录 `STRATEGY_INIT` 事件。

    ```python
    class AShareETFStrategy(bt.Strategy):
        # ... (params 定义不变) ...

        # 90 行
        # def __init__(self, **kwargs):  # 原始签名
        # 91 行, 最小化修改: 增加 logger 参数
        def __init__(self, logger=None, **kwargs):  # 接受 **kwargs 并添加 logger
            # 定义策略的初始化函数__init__，在策略对象创建时自动执行。
            # (Define the initialization function __init__, executed automatically when the strategy object is created.)
            # (Accept **kwargs to be compatible with parameters passed by addstrategy)
            # 接受 logger 实例
            # (Accept logger instance)
            # **蓝色字体**: 策略初始化，设置基础参数和状态。
            # **讲人话**: 策略开始运行时，先做好准备工作，比如拿到日志记录工具，记住自己的名字等。
            super().__init__() # 调用父类的初始化

            # --- 日志系统集成 ---
            # 1. **红色字体**: 保存传入的 logger 实例，或者获取一个默认的 logger。
            #    **讲人话**: 拿到上面配置好的日志记录工具，如果外面没给，就自己创建一个简单的。
            self.logger = logger or logging.getLogger(self.__class__.__name__) # 获取或创建一个 logger
            # 2. **红色字体**: 生成策略实例的唯一标识符 `strategy_id`。
            #    **讲人话**: 给这次运行的策略起个独一无二的名字(ID)，方便以后追踪日志。
            self.strategy_id = uuid.uuid4().hex
            # 3. **红色字体**: 初始化 `order.ref` 到 `trade_cycle_id` 的映射字典。
            #    **讲人话**: 准备一个小本本 (`order_ref_to_trade_id_map`)，用来记下哪个订单属于哪个交易流程。
            self.order_ref_to_trade_id_map = {}
            # 4. **红色字体**: 初始化当前交易周期的 ID `current_trade_cycle_id`。
            #    **讲人话**: 准备一个变量 (`current_trade_cycle_id`)，记下当前正在进行的这笔交易的专属 ID。
            self.current_trade_cycle_id = None
            # --- 结束日志系统集成 ---

            # 引用数据源。
            # Reference the data feeds.
            # ... (保留原有 __init__ 代码) ...
            self.datas_list = self.datas # 保留对所有数据源的引用
            # 添加其他初始化代码...
            self.trade_history = [] # 用于记录交易历史详情
            self.completed_trades = [] # 记录完成的交易
            self.order_refs = set() # 跟踪所有活动订单的引用

            # 交易状态变量
            self.in_trade = False # 是否持有仓位
            self.trade_entry_bar = 0 # 进入交易的 bar 索引
            self.trade_direction = 0 # 交易方向: 1 for long, -1 for short

            # ... (保留原有指标定义等) ...
            # EMA 指标
            self.ema_short = {d._name: bt.indicators.ExponentialMovingAverage(d.close, period=self.p.ema_short_period) for d in self.datas}
            self.ema_medium = {d._name: bt.indicators.ExponentialMovingAverage(d.close, period=self.p.ema_medium_period) for d in self.datas}
            self.ema_long = {d._name: bt.indicators.ExponentialMovingAverage(d.close, period=self.p.ema_long_period) for d in self.datas}
            # 布林带指标
            self.bbands = {d._name: bt.indicators.BollingerBands(d.close, period=self.p.bbands_period, devfactor=self.p.bbands_dev) for d in self.datas}
            # ATR 指标
            self.atr = {d._name: bt.indicators.AverageTrueRange(d, period=self.p.atr_period) for d in self.datas}
            # RSI 指标
            self.rsi = {d._name: bt.indicators.RelativeStrengthIndex(d.close, period=self.p.rsi_period) for d in self.datas}
            # MACD 指标
            self.macd = {d._name: bt.indicators.MACD(d.close, period_me1=self.p.macd_fast, period_me2=self.p.macd_slow, period_signal=self.p.macd_signal) for d in self.datas}

            # 订单变量初始化
            self.order = None # 当前活动的订单
            self.stop_loss_order = None # 止损单
            self.take_profit_order = None # 止盈单
            self.buy_price = None # 买入价格
            self.buy_comm = None # 买入佣金

            # 风险管理变量
            self.initial_portfolio_value = self.broker.getvalue() # 初始投资组合价值
            self.high_water_mark = self.initial_portfolio_value # 最高水位线，用于计算回撤
            self.max_drawdown = 0.0 # 最大回撤比例
            self.consecutive_losses = 0 # 连续亏损次数
            self.halt_trading_signal = False # 暂停交易信号

            # --- 记录策略初始化事件 ---
            # 5. **红色字体**: 调用 `log_event` 记录 `STRATEGY_INIT` 事件。
            #    **讲人话**: 在日志里记一笔："策略某某某 (ID: xxx) 开始运行了，带着这些参数..."
            try:
                # 准备参数字典，确保可序列化
                params_dict = {}
                for key, value in self.params.__dict__.items():
                    if not key.startswith('_'): # 排除内部参数
                        try:
                            json.dumps({key: value}) # 测试是否可序列化
                            params_dict[key] = value
                        except TypeError:
                            params_dict[key] = str(value) # 不可序列化则转为字符串

                self.log_event(
                    event_type=STRATEGY_INIT,
                    data_feed=self.datas[0] if self.datas else None, # 使用第一个数据源或None
                    details={ # 使用 details 嵌套，避免与标准字段冲突
                        'strategy_name': self.__class__.__name__,
                        'params': params_dict, # 记录策略参数
                        'data_ids': [d._name for d in self.datas_list] # 记录所有数据源的名称
                    }
                )
            except Exception as e:
                 # **讲人话**: 如果写日志时出了问题，打印错误信息，但别让策略停下来。
                print(f"策略初始化日志记录失败: {e}", file=sys.stderr)
            # --- 结束记录策略初始化事件 ---
    ```

2.  **添加 `log_event` 方法:**
    *   这是日志记录的核心接口。

    ```python
    class AShareETFStrategy(bt.Strategy):
        # ... (init 和 params 之后) ...

        def log_event(self, event_type: str, data_feed, **kwargs):
            """
            统一的日志记录接口。

            :param event_type: 事件类型 (使用预定义的常量)。
            :param data_feed: 触发事件的数据源 (bt.DataBase 实例)，可以为 None。
            :param kwargs: 事件特定的数据 (键值对)。
            """
            # 1. **蓝色字体**: 检查 logger 是否可用。
            #    **讲人话**: 先看看日志工具在不在，不在就没法记了。
            if not self.logger:
                # print(f"警告: Logger 未初始化，无法记录事件 '{event_type}'。", file=sys.stderr) # 可以选择打印警告
                return # 如果 logger 不存在，则不执行任何操作

            # 2. **蓝色字体**: 构造基础日志信息字典。
            #    **讲人话**: 准备一个日志条目的基本框架，包含时间、事件类型、策略ID和数据ID。
            log_data = {}
            try:
                # **红色字体**: 获取当前 UTC 时间并格式化。
                # **讲人话**: 记下现在是什么时候 (用全球统一的 UTC 时间)。
                log_data['timestamp'] = datetime.datetime.now(pytz.utc).isoformat()
                # **红色字体**: 记录事件类型。
                # **讲人话**: 记下发生了什么事 (比如 "信号触发了"、"订单成交了")。
                log_data['event_type'] = event_type
                # **红色字体**: 记录策略实例 ID。
                # **讲人话**: 记下是哪个策略实例产生的这条日志。
                log_data['strategy_id'] = self.strategy_id
                # **红色字体**: 记录相关数据源的名称。
                # **讲人话**: 记下这条日志是关于哪个股票/ETF 的 (如果有关的话)。
                log_data['data_id'] = data_feed._name if data_feed and hasattr(data_feed, '_name') else 'N/A'

                # 3. **蓝色字体**: 合并事件特定数据 `kwargs`。
                #    **讲人话**: 把这次事件特有的信息 (比如信号类型、订单价格等) 加到日志里。
                #    为了避免与标准字段冲突，可以将 kwargs 放入一个 'details' 键下
                # log_data.update(kwargs)
                log_data['details'] = kwargs # 将特定数据放入 'details' 字典

                # 4. **蓝色字体**: 调用 logger 记录日志 (以 INFO 级别)。
                #    **讲人话**: 把整理好的日志信息交给日志工具去记录。
                # **红色字体**: 使用 `logger.info` 并传递字典，让 JSONFormatter 处理。
                # **讲人话**: 用 info 级别记录这条信息，并且直接把包含所有信息的字典传给日志工具，它会帮我们转成 JSON 格式。
                self.logger.info(log_data) # 直接传递字典

            except Exception as e:
                # 5. **蓝色字体**: 健壮的错误处理。
                #    **讲人话**: 如果记日志的过程中出了任何差错 (比如有些信息不能转成 JSON)，要抓住错误，打印出来，但绝不能让策略因此崩溃停止交易！
                # **红色字体**: 捕获所有异常，并将错误信息输出到 `sys.stderr` 或专用错误日志。
                # **讲人话**: 抓住所有可能的错误，把错误详情打印到控制台的错误输出流里，方便我们看到。
                error_log_entry = {
                    'timestamp': datetime.datetime.now(pytz.utc).isoformat(),
                    'level': 'ERROR',
                    'event_type': 'LOGGING_ERROR',
                    'strategy_id': getattr(self, 'strategy_id', 'N/A'),
                    'original_event_type': event_type,
                    'error_message': str(e),
                    'original_kwargs': {k: str(v) for k, v in kwargs.items()} # 尝试将原始数据转为字符串
                }
                print(json.dumps(error_log_entry), file=sys.stderr)
                # 也可以考虑写入单独的错误日志文件
                # with open("logging_errors.log", "a") as f_err:
                #     f_err.write(json.dumps(error_log_entry) + "\n")

        # ... (保留 log 方法, 但建议后续迁移到 log_event) ...
        # 68 行
        def log(self, txt, dt=None, data=None):
            ''' 原有的日志记录功能 - 建议逐步迁移到 log_event '''
            # 1. **蓝色字体**: 格式化日志时间。
            #    **讲人话**: 把当前时间或者指定的时间弄成容易看懂的格式。
            # 2. **红色字体**: 获取当前数据点的时间，优先使用传入的 `dt`，否则使用当前数据的时间。
            #    **讲人话**: 找到这条日志对应的时间点，如果外面指定了就用指定的，不然就用当前 K 线的时间。
            dt = dt or (data.datetime.date(0) if data else self.datas[0].datetime.date(0))
            # 3. **红色字体**: 获取数据源名称，如果提供了 `data` 参数。
            #    **讲人话**: 看看这条日志是不是跟某个特定的股票/ETF 相关，如果是，记下它的名字。
            data_name = f"Data: {data._name} " if data else ""
            # 4. **蓝色字体**: 打印日志信息。
            #    **讲人话**: 把时间和日志内容打印出来。
            print(f'{dt.isoformat()} {data_name}- {txt}')
            # 注意：此方法输出到控制台，不进入新的 JSON 日志系统。
            # 如果希望这些信息也进入 JSON 日志，需要改造或调用 log_event。
            # 例如:
            # simplified_log_data = {'original_log_message': txt}
            # self.log_event(event_type='LEGACY_LOG', data_feed=data, details=simplified_log_data)
    ```

3.  **修改 `next` 方法:**
    *   在识别交易机会并计算大小后、调用 `buy/sell` 前生成 `trade_cycle_id`。
    *   记录 `SIGNAL_TRIGGERED`、`ORDER_CALCULATION`、`TRADE_SKIPPED` 事件。

    ```python
    class AShareETFStrategy(bt.Strategy):
        # ... (其他方法) ...

        # 457 行
        def next(self):
            # 定义next函数，在每个数据点（通常是每个交易日）都会被调用一次，用于执行策略的主要逻辑。 (定义next函数，这是策略的核心，每天开盘后都要运行一遍，决定今天该干啥。)
            # **蓝色字体**: 策略的核心逻辑，每个交易周期执行一次。
            # **讲人话**: 这是策略每天都要运行的部分，用来判断市场情况，决定买还是卖。

            # 检查是否暂停交易
            # Check if trading is halted
            if self.halt_trading_signal:
                # **讲人话**: 如果收到了暂停交易的信号，今天啥也不干。
                self.log_event(event_type=RISK_EVENT, data_feed=None, event_subtype='TRADING_HALTED', reason="Risk limit exceeded or manual halt")
                return

            # 检查是否有活动订单，如果有则不进行新的交易决策
            # Check for active orders, if any, do not make new trading decisions
            if self.order:
                # **讲人话**: 如果还有没成交完的订单，先等等，不着急下新的。
                return

            current_bar_date = self.datas[0].datetime.date(0) # 使用第一个数据源的时间

            # --- 风险管理：检查最大回撤和连续亏损 ---
            # 1. **蓝色字体**: 更新并检查风险指标。
            #    **讲人话**: 算算最近亏了多少，有没有亏得太惨或者连着亏太多次。
            current_value = self.broker.getvalue()
            self.high_water_mark = max(self.high_water_mark, current_value)
            drawdown = (self.high_water_mark - current_value) / self.high_water_mark
            self.max_drawdown = max(self.max_drawdown, drawdown)

            # **红色字体**: 如果达到风险阈值，记录事件并暂停交易。
            # **讲人话**: 如果亏损超过了设定的底线，赶紧记下来，并且暂停交易，保住本金要紧。
            if self.max_drawdown > self.p.max_drawdown_limit:
                self.halt_trading_signal = True
                self.log_event(
                    event_type=RISK_EVENT,
                    data_feed=None, # 风险事件通常与特定数据无关
                    event_subtype='DRAWDOWN_LIMIT_EXCEEDED',
                    account_value=current_value,
                    cash=self.broker.getcash(),
                    drawdown_pct=self.max_drawdown,
                    high_water_mark=self.high_water_mark,
                    limit=self.p.max_drawdown_limit
                )
                self.log(f'{current_bar_date.isoformat()} - Risk Event: Max Drawdown Limit Exceeded: {self.max_drawdown:.2%}. Halting trading.')
                return # 暂停后直接返回

            # (连续亏损检查逻辑可以在 notify_trade 中更新 self.consecutive_losses)
            if self.consecutive_losses >= self.p.max_consecutive_losses:
                self.halt_trading_signal = True
                 self.log_event(
                    event_type=RISK_EVENT,
                    data_feed=None,
                    event_subtype='CONSECUTIVE_LOSS_LIMIT_EXCEEDED',
                    account_value=current_value,
                    cash=self.broker.getcash(),
                    consecutive_losses=self.consecutive_losses,
                    limit=self.p.max_consecutive_losses
                )
                 self.log(f'{current_bar_date.isoformat()} - Risk Event: Max Consecutive Loss Limit Exceeded: {self.consecutive_losses}. Halting trading.')
                 return # 暂停后直接返回
            # --- 结束风险管理检查 ---


            # 遍历所有数据源进行交易决策
            # Iterate over all data feeds for trading decisions
            for data in self.datas_list:
                data_name = data._name
                # **讲人话**: 对我们关注的每一个股票/ETF，都单独判断一下。
                if not len(data): # 检查数据点是否存在
                    continue

                # 获取当前数据点的收盘价和各项指标值
                # Get the closing price and indicator values for the current data point
                close_price = data.close[0]
                atr_value = self.atr[data_name][0]
                ema_short = self.ema_short[data_name][0]
                ema_medium = self.ema_medium[data_name][0]
                ema_long = self.ema_long[data_name][0]
                bb_mid = self.bbands[data_name].lines.mid[0]
                bb_top = self.bbands[data_name].lines.top[0]
                bb_bot = self.bbands[data_name].lines.bot[0]
                rsi_value = self.rsi[data_name][0]
                macd_line = self.macd[data_name].lines.macd[0]
                signal_line = self.macd[data_name].lines.signal[0]

                # 记录市场状态评估 (示例，可以根据实际逻辑调整)
                # Log market state assessment (example, adjust based on actual logic)
                # **讲人话**: 评估一下当前市场是涨是跌还是震荡 (这里只是个例子)。
                market_state = 'NEUTRAL'
                if ema_short > ema_medium > ema_long:
                    market_state = 'TREND_UP'
                elif ema_short < ema_medium < ema_long:
                    market_state = 'TREND_DOWN'
                self.log_event(
                    event_type=MARKET_STATE_ASSESSED,
                    data_feed=data,
                    market_state=market_state,
                    indicators={ # 记录关键指标值
                        'close': close_price,
                        'ema_short': ema_short,
                        'ema_medium': ema_medium,
                        'ema_long': ema_long,
                        'rsi': rsi_value,
                        'macd': macd_line,
                        'macd_signal': signal_line,
                        'bb_top': bb_top,
                        'bb_mid': bb_mid,
                        'bb_bot': bb_bot,
                        'atr': atr_value
                    }
                )


                # 获取当前持仓信息
                # Get current position information
                position = self.getposition(data)
                pos_size = position.size


                # --- 交易信号判断与执行 ---
                # 1. **蓝色字体**: 定义并判断交易信号。
                #    **讲人话**: 根据各种技术指标，判断现在是该买入、卖出，还是保持不动。

                # 示例：EMA 交叉和 RSI 确认的买入信号
                # Example: Buy signal confirmed by EMA crossover and RSI
                buy_signal = (ema_short > ema_medium and # 短期线上穿中期线
                              ema_medium > ema_long and # 中期线上穿长期线
                              rsi_value > self.p.rsi_buy_threshold and # RSI 确认强势
                              close_price > bb_mid) # 价格在布林带中轨之上

                # 示例：EMA 交叉和 RSI 确认的卖出信号
                # Example: Sell signal confirmed by EMA crossover and RSI
                sell_signal = (ema_short < ema_medium and # 短期线下穿中期线
                               ema_medium < ema_long and # 中期线下穿长期线
                               rsi_value < self.p.rsi_sell_threshold and # RSI 确认弱势
                               close_price < bb_mid) # 价格在布林带中轨之下


                # --- 日志记录与下单逻辑 ---
                # 1. **蓝色字体**: 如果没有持仓且出现买入信号。
                #    **讲人话**: 如果现在手里没货，并且指标说该买了。
                if not pos_size and buy_signal:
                    # **红色字体**: 生成唯一的交易周期 ID `trade_cycle_id`。
                    # **讲人话**: 给这笔即将开始的交易起个专属的名字 (ID)。
                    self.current_trade_cycle_id = uuid.uuid4().hex

                    # **红色字体**: 记录 `SIGNAL_TRIGGERED` 事件。
                    # **讲人话**: 在日志里记一笔："在某个股票上发现了买入信号！原因是..."
                    self.log_event(
                        event_type=SIGNAL_TRIGGERED,
                        data_feed=data,
                        trade_cycle_id=self.current_trade_cycle_id, #【强制】
                        signal_type='BUY_SIGNAL',
                        triggering_data={ # 记录触发信号的关键数据
                            'close': close_price,
                            'ema_short': ema_short,
                            'ema_medium': ema_medium,
                            'ema_long': ema_long,
                            'rsi': rsi_value,
                            'bb_mid': bb_mid,
                            'condition': 'EMA crossover and RSI confirmation'
                        }
                    )

                    # 计算止损价格和仓位大小
                    # Calculate stop-loss price and position size
                    entry_price = close_price # 使用当前收盘价作为预估入场价
                    stop_loss_price = entry_price - self.p.atr_stop_loss_multiplier * atr_value

                    # **红色字体**: 调用私有方法计算交易大小。
                    # **讲人话**: 根据风险控制规则，算算这次该买多少股。
                    trade_size = self._calculate_trade_size(
                        data_close_price=close_price,
                        entry_price=entry_price,
                        stop_loss_price=stop_loss_price,
                        risk_per_trade_percent=self.p.risk_per_trade,
                        data=data
                    )

                    # **红色字体**: 记录 `ORDER_CALCULATION` 事件。
                    # **讲人话**: 在日志里记下："为了这笔买入交易，我们计算出应该买 X 股，止损设在 Y 元，风险是 Z%。"
                    self.log_event(
                        event_type=ORDER_CALCULATION,
                        data_feed=data,
                        trade_cycle_id=self.current_trade_cycle_id, #【强制】
                        signal_type='BUY_SIGNAL',
                        entry_price_approx=entry_price,
                        stop_loss_calc=stop_loss_price,
                        take_profit_calc=entry_price + self.p.atr_take_profit_multiplier * atr_value, # 预估止盈
                        risk_inputs={
                            'risk_per_trade_percent': self.p.risk_per_trade,
                            'atr': atr_value,
                            'atr_stop_loss_multiplier': self.p.atr_stop_loss_multiplier
                        },
                        size_raw=trade_size, # 记录原始计算大小 (如果后面有调整)
                        size_final=trade_size, # 最终大小 (这里假设没有调整)
                        adjustment_reasons=[] # 记录调整原因 (如果有)
                    )

                    if trade_size > 0:
                        # **红色字体**: 执行买入订单。
                        # **讲人话**: 计算结果说可以买，那就下单买入！
                        self.order = self.buy(data=data, size=trade_size)
                        if self.order:
                            # **红色字体**: 记录 `ORDER_SUBMITTED` 事件。
                            # **讲人话**: 在日志里记下："我们已经提交了一个买单，订单号是 XXX，买 Y 股，价格大概是 Z。"
                            self.log_event(
                                event_type=ORDER_SUBMITTED,
                                data_feed=data,
                                trade_cycle_id=self.current_trade_cycle_id, #【强制】
                                order_ref=self.order.ref, #【强制】
                                order_details={ # 记录下单参数
                                    'type': 'BUY',
                                    'size': trade_size,
                                    'exectype': self.order.getordername(), # 记录执行类型，例如 'Market'
                                    'price': self.order.created.price, # 记录订单创建时的价格（市价单可能为0或参考价）
                                    'valid': self.order.valid, # 记录订单有效期
                                    # 可以添加更多 relevant 参数
                                }
                            )
                            # **红色字体**: 将 `order.ref` 与 `trade_cycle_id` 关联。
                            # **讲人话**: 在小本本上记下：这个订单 (ref: XXX) 是属于这次交易流程 (ID: YYY) 的。
                            self.order_ref_to_trade_id_map[self.order.ref] = self.current_trade_cycle_id
                            self.buy_price = self.order.created.price # 记录近似买入价
                        else:
                            # 下单失败或未创建订单的情况
                            self.current_trade_cycle_id = None # 重置 ID
                            self.log_event(event_type=TRADE_SKIPPED, data_feed=data, reason="Order creation failed or returned None", details={'trade_size_calculated': trade_size})

                    else:
                        # **红色字体**: 记录 `TRADE_SKIPPED` 事件 (因仓位大小为0)。
                        # **讲人话**: 虽然有信号，但计算后发现买不了（可能是风险太大或资金不足），在日志里记下这次“跳过交易”。
                        self.log_event(
                            event_type=TRADE_SKIPPED,
                            data_feed=data,
                            trade_cycle_id=self.current_trade_cycle_id, # 记录关联的交易周期ID
                            reason='Calculated trade size is zero or less',
                            details={
                                'signal_type': 'BUY_SIGNAL',
                                'calculated_size': trade_size,
                                'risk_per_trade': self.p.risk_per_trade,
                                'stop_loss_distance': abs(entry_price - stop_loss_price) if stop_loss_price else None,
                                'portfolio_value': self.broker.getvalue(),
                                'cash': self.broker.getcash()
                            }
                        )
                        self.current_trade_cycle_id = None # 重置 ID

                # 2. **蓝色字体**: 如果持有仓位且出现卖出信号 (平多仓)。
                #    **讲人话**: 如果现在手里有货 (买入的)，并且指标说该卖了。
                elif pos_size > 0 and sell_signal:
                    # 获取与当前持仓关联的 trade_cycle_id
                    # **红色字体**: 查找与当前持仓关联的交易周期 ID。
                    # **讲人话**: 找到这笔持仓是属于哪个交易流程的。
                    # 注意：这里简化处理，假设只有一个持仓。如果允许多个并发交易，需要更复杂的逻辑。
                    active_trade_cycle_id = None
                    # 尝试从最后一次开仓的 ID 获取，或者从映射中查找（如果能关联到订单）
                    # 这是一个简化的假设，实际可能需要更可靠的方式追踪当前活动交易的 ID
                    if hasattr(self, 'last_opened_trade_id') and self.last_opened_trade_id:
                         active_trade_cycle_id = self.last_opened_trade_id
                    # 备选：如果能通过 position 对象关联到开仓订单的 ref
                    # for order_ref, trade_id in self.order_ref_to_trade_id_map.items():
                    #    # 需要逻辑判断 order_ref 是否是当前 position 的开仓单
                    #    pass # 实现查找逻辑

                    # 如果找不到，则使用一个标记
                    active_trade_cycle_id = active_trade_cycle_id or self.current_trade_cycle_id or 'UNKNOWN_ACTIVE_TRADE'


                    # **红色字体**: 记录 `SIGNAL_TRIGGERED` 事件 (用于平仓)。
                    # **讲人话**: 在日志里记下："发现了卖出信号，准备把手里的多单平掉。"
                    self.log_event(
                        event_type=SIGNAL_TRIGGERED,
                        data_feed=data,
                        trade_cycle_id=active_trade_cycle_id, # 关联到要平仓的交易周期
                        signal_type='CLOSE_LONG_SIGNAL', # 或 'SELL_SIGNAL' 如果也用于开空
                        triggering_data={
                             'close': close_price,
                            'ema_short': ema_short,
                            'ema_medium': ema_medium,
                            'ema_long': ema_long,
                            'rsi': rsi_value,
                            'bb_mid': bb_mid,
                            'condition': 'EMA crossover and RSI confirmation for exit'
                        }
                    )
                    # **红色字体**: 执行市价平仓订单。
                    # **讲人话**: 下单卖出，把手里的股票全卖掉。
                    self.order = self.close(data=data) # 市价平仓
                    if self.order:
                         # **红色字体**: 记录 `ORDER_SUBMITTED` 事件 (平仓)。
                         # **讲人话**: 在日志里记下："提交了一个平仓单，订单号 XXX。"
                         self.log_event(
                             event_type=ORDER_SUBMITTED,
                             data_feed=data,
                             # **红色字体**: 关联到正在关闭的交易周期 ID。
                             # **讲人话**: 记清楚这个平仓单是属于哪个交易流程的。
                             trade_cycle_id=active_trade_cycle_id, #【强制】关联平仓周期
                             order_ref=self.order.ref, #【强制】
                             order_details={
                                 'type': 'CLOSE',
                                 'size': self.order.created.size, # 记录请求的平仓大小
                                 'exectype': self.order.getordername(),
                                 # ...
                             }
                         )
                         # **红色字体**: 将平仓订单的 `order.ref` 关联到相应的 `trade_cycle_id`。
                         # **讲人话**: 在小本本上记下：这个平仓订单 (ref: XXX) 也是属于这次交易流程 (ID: YYY) 的。
                         self.order_ref_to_trade_id_map[self.order.ref] = active_trade_cycle_id
                    else:
                        # 平仓失败
                        self.log_event(event_type=TRADE_SKIPPED, data_feed=data, reason="Close order creation failed or returned None", details={'position_size': pos_size})


                # --- 这里可以添加开空仓和平空仓的逻辑 ---
                # --- Add logic for opening short positions and closing short positions here ---
                # 示例：开空仓逻辑 (需要 sell_signal 定义)
                # Example: Logic for opening short position (requires sell_signal definition)
                # elif not pos_size and sell_signal: # 如果没有持仓且出现卖出信号 (开空)
                #     self.current_trade_cycle_id = uuid.uuid4().hex
                #     self.log_event(event_type=SIGNAL_TRIGGERED, ...)
                #     stop_loss_price = entry_price + self.p.atr_stop_loss_multiplier * atr_value
                #     trade_size = self._calculate_trade_size(...) # 注意 size 为负
                #     self.log_event(event_type=ORDER_CALCULATION, ...)
                #     if trade_size < 0:
                #         self.order = self.sell(data=data, size=abs(trade_size)) # sell 需要正数 size
                #         if self.order:
                #             self.log_event(event_type=ORDER_SUBMITTED, ...)
                #             self.order_ref_to_trade_id_map[self.order.ref] = self.current_trade_cycle_id
                #         else: ... # log TRADE_SKIPPED
                #     else: ... # log TRADE_SKIPPED

                # 示例：平空仓逻辑 (需要 buy_signal 定义，或者专门的平空信号)
                # Example: Logic for closing short position (requires buy_signal or specific close short signal)
                # elif pos_size < 0 and buy_signal: # 如果持有空仓且出现买入信号 (平空)
                #     active_trade_cycle_id = ... # 查找关联的 trade_cycle_id
                #     self.log_event(event_type=SIGNAL_TRIGGERED, ...)
                #     self.order = self.close(data=data)
                #     if self.order:
                #         self.log_event(event_type=ORDER_SUBMITTED, ...)
                #         self.order_ref_to_trade_id_map[self.order.ref] = active_trade_cycle_id
                #     else: ... # log TRADE_SKIPPED


                # 移动止损逻辑 (如果持有多仓)
                # Trailing stop loss logic (if holding a long position)
                # if pos_size > 0 and self.p.use_trailing_stop:
                    # ... 实现移动止损逻辑 ...
                    # if new_stop_price > current_stop_price:
                        # self.cancel(self.stop_loss_order) # 取消旧止损单
                        # self.stop_loss_order = self.sell(...) # 创建新止损单
                        # self.log_event(event_type=SL_TP_TRIGGERED, trigger_type='STOP_LOSS_ADJUSTED', ...)
                        # 需要管理 self.stop_loss_order 的 ref 和 trade_cycle_id 映射

            # --- 结束单个数据源的处理 ---

            # 更新所有指标和数据线到下一个时间点 (这部分 backtrader 会自动处理)
            # Update all indicators and data lines to the next time point (backtrader handles this automatically)
    ```

4.  **修改 `notify_order` 方法:**
    *   查找 `trade_cycle_id`。
    *   记录 `ORDER_STATUS_UPDATE` 事件。
    *   执行可选的清理逻辑。

    ```python
    class AShareETFStrategy(bt.Strategy):
        # ... (其他方法) ...

        # 178 行
        def notify_order(self, order):
            # 定义订单状态通知函数notify_order，当订单状态发生变化时被调用，参数order是订单对象。 (定义订单通知函数，当订单状态变化的时候，程序会跑这个函数来通知你。)
            # **蓝色字体**: 处理订单状态更新通知。
            # **讲人话**: 当我们下的订单状态有变化时 (比如成交了、被取消了)，这个函数就会被触发。
            # 1. **红色字体**: 查找与此订单关联的 `trade_cycle_id`。
            #    **讲人话**: 从我们的小本本里，根据订单号 (order.ref) 查出这个订单属于哪个交易流程。
            trade_cycle_id = self.order_ref_to_trade_id_map.get(order.ref, 'ORPHANED_ORDER') # 如果找不到，标记为孤儿订单

            # 2. **红色字体**: 记录 `ORDER_STATUS_UPDATE` 事件。
            #    **讲人话**: 在日志里记下："订单 XXX (属于流程 YYY) 的状态更新为 ZZZ 了。"
            exec_details = None
            if order.executed.size: # 如果有执行信息
                 exec_details = {
                     'price': order.executed.price,
                     'size': order.executed.size,
                     'value': order.executed.value,
                     'commission': order.executed.comm,
                     'pnl': order.executed.pnl, # 执行部分产生的 PNL
                 }

            self.log_event(
                event_type=ORDER_STATUS_UPDATE,
                data_feed=order.data, # 使用订单关联的数据源
                order_ref=order.ref, #【强制】
                trade_cycle_id=trade_cycle_id, #【强制】
                status=order.getstatusname(), # 获取订单状态名称
                exec_details=exec_details, # 执行详情 (如果有)
                remaining_size=order.executed.remsize, # 剩余未成交大小
                info=dict(order.info) if hasattr(order, 'info') and order.info else None # 记录订单的 info 属性
            )

            # 如果订单已完成或最终状态，处理相关逻辑
            # If the order is completed or in a final state, handle related logic
            if order.status in [order.Completed, order.Canceled, order.Margin, order.Rejected, order.Expired]:
                # 3. **蓝色字体**: 如果订单是最终状态。
                #    **讲人话**: 如果这个订单彻底结束了 (不管是成交、取消还是过期)。
                if self.order is order:
                    # **讲人话**: 如果这个结束的订单正好是我们当前正在跟踪的那个活动订单。
                    self.order = None # 清除活动订单引用
                    # **讲人话**: 把它从“当前活动订单”的标记中移除。

                # --- 可选清理逻辑 (次要清理点) ---
                # **蓝色字体**: 考虑从映射中移除非 Bracket 订单的 ref。
                # **讲人话**: 如果这个订单不是那种复杂的包含止盈止损的订单 (Bracket Order)，并且它已经结束了，我们可以考虑把它从小本本上擦掉。但是要小心，别擦太早了，尤其是对 Bracket Order。
                # **红色字体**: 优先在 `notify_trade` 中进行清理，这里谨慎操作。
                # **讲人话**: 主要的清理工作还是等整个交易流程结束时 (在 notify_trade 里) 再做，这里只是一个备选方案，需要特别小心。
                is_bracket_related = False # 需要逻辑判断订单是否为 Bracket 的一部分
                # (例如，通过检查 order.parent 或其他关联信息)
                # if not is_bracket_related:
                #    if order.ref in self.order_ref_to_trade_id_map:
                #        # print(f"DEBUG: Removing order ref {order.ref} from map in notify_order (status: {order.getstatusname()})")
                #        # self.order_ref_to_trade_id_map.pop(order.ref, None) # 谨慎移除
                #        pass # 决定是否在此处移除

            elif order.status == order.Partial:
                 # 部分成交，更新状态，但订单仍然活动
                 # Partially filled, update status, but the order is still active
                 pass

            # 调试信息
            # Debug information
            # self.log(f'ORDER STATUS: Ref: {order.ref}, Status: {order.getstatusname()}, Size: {order.size}, Executed: {order.executed.size}, Price: {order.executed.price:.2f}, Cost: {order.executed.value:.2f}, Comm: {order.executed.comm:.2f}', data=order.data)

            # 如果订单被接受，可以记录下来
            # If the order is accepted, it can be recorded
            if order.status == order.Accepted:
                 self.order_refs.add(order.ref)
                 # self.log(f'Order Accepted: Ref {order.ref}', data=order.data)

            # 订单完成逻辑
            # Order completion logic
            if order.status == order.Completed:
                if order.isbuy():
                    # self.log(f'BUY EXECUTED: Ref: {order.ref}, Price: {order.executed.price:.2f}, Cost: {order.executed.value:.2f}, Comm: {order.executed.comm:.2f}', data=order.data)
                    self.buy_price = order.executed.price
                    self.buy_comm = order.executed.comm
                    # # 设置止损和止盈订单 (如果使用 Bracket Order, Backtrader 会自动管理)
                    # # Set stop loss and take profit orders (if using Bracket Order, Backtrader manages automatically)
                    # if not order.parent: # 仅为主订单设置（如果不是 bracket 的一部分）
                    #     sl_price = self.buy_price * (1.0 - self.p.stop_loss_pct)
                    #     tp_price = self.buy_price * (1.0 + self.p.take_profit_pct)
                    #     # self.stop_loss_order = self.sell(exectype=bt.Order.Stop, price=sl_price, size=order.executed.size, parent=order)
                    #     # self.take_profit_order = self.sell(exectype=bt.Order.Limit, price=tp_price, size=order.executed.size, parent=order)
                    #     # self.log(f'StopLoss set at {sl_price:.2f}, TakeProfit set at {tp_price:.2f}', data=order.data)
                elif order.issell():
                    # self.log(f'SELL EXECUTED: Ref: {order.ref}, Price: {order.executed.price:.2f}, Cost: {order.executed.value:.2f}, Comm: {order.executed.comm:.2f}', data=order.data)
                    pass # 空头逻辑

                self.order_refs.discard(order.ref)
                self.trade_entry_bar = len(self) # 记录进入交易的 bar
                self.in_trade = True
                self.trade_direction = 1 if order.isbuy() else -1


            # 处理订单被取消、拒绝或过期的情况
            # Handle cases where the order is canceled, rejected, or expired
            elif order.status in [order.Canceled, order.Margin, order.Rejected, order.Expired]:
                 # self.log(f'Order Canceled/Margin/Rejected/Expired: Ref {order.ref}, Status {order.getstatusname()}', data=order.data)
                 self.order_refs.discard(order.ref)
                 if self.order is order:
                     self.order = None # 清除对该订单的引用
    ```

5.  **修改 `notify_trade` 方法:**
    *   查找 `trade_cycle_id`。
    *   如果交易关闭，记录 `TRADE_CLOSED` 事件。
    *   **执行主要的清理逻辑**: 从映射中移除所有关联的 `order.ref`，并重置 `current_trade_cycle_id`。

    ```python
    class AShareETFStrategy(bt.Strategy):
        # ... (其他方法) ...

        # 248 行
        def notify_trade(self, trade):
            # 定义交易通知函数notify_trade，当交易（一买一卖）完成时被调用，参数trade是交易对象。 (定义交易完成通知函数，当一次完整的买卖结束了，程序会跑这个函数来通知你。)
            # **蓝色字体**: 处理交易完成或更新的通知。
            # **讲人话**: 当一笔完整的买卖 (或者部分买卖导致状态更新时) 结束了，这个函数会被触发。

            # 1. **红色字体**: 查找与此交易关联的 `trade_cycle_id`。
            #    **讲人话**: 根据这笔交易涉及的订单号，从小本本里查出它属于哪个交易流程。注意，一个交易可能涉及多个订单 (比如开仓单和平仓单)，找到第一个匹配的就行。
            trade_cycle_id = 'ORPHANED_TRADE' # 默认为孤儿交易
            if trade.orders: # 确保 trade.orders 非空
                for order_ref in trade.orders:
                    found_id = self.order_ref_to_trade_id_map.get(order_ref)
                    if found_id:
                        trade_cycle_id = found_id
                        break # 找到第一个即可退出循环

            # 记录交易历史 (即使交易未关闭) - 可选，用于详细追踪
            # Record trade history (even if trade is not closed) - optional for detailed tracking
            # self.trade_history.append({
            #     'ref': trade.ref,
            #     'status': trade.status, # 0: Created, 1: Open, 2: Closed
            #     'size': trade.size,
            #     'price': trade.price,
            #     'value': trade.value,
            #     'pnl': trade.pnl,
            #     'pnlcomm': trade.pnlcomm,
            #     'commission': trade.commission,
            #     'barlen': trade.barlen,
            #     'dtopen': trade.dtopen,
            #     'dtclose': trade.dtclose,
            #     'justopened': trade.justopened,
            #     'isopen': trade.isopen,
            #     'isclosed': trade.isclosed,
            #     'trade_cycle_id': trade_cycle_id # 记录关联的 ID
            # })


            if trade.isclosed:
                # 2. **蓝色字体**: 如果交易已关闭。
                #    **讲人话**: 如果这笔买卖彻底完成了。
                # **红色字体**: 记录 `TRADE_CLOSED` 事件。
                # **讲人话**: 在日志里郑重记下："交易流程 YYY 结束了！最终盈利/亏损是 X 元。"
                self.log_event(
                    event_type=TRADE_CLOSED,
                    data_feed=trade.data, # 使用交易关联的数据源
                    trade_cycle_id=trade_cycle_id, #【强制】
                    pnl=trade.pnl, # 盈利/亏损 (毛利)
                    pnlcomm=trade.pnlcomm, # 盈利/亏损 (净利，扣除佣金后)
                    commission=trade.commission, # 总佣金
                    duration_bars=trade.barlen, # 持仓K线数
                    open_datetime=trade.open_datetime().isoformat() if trade.dtopen else None, # 开仓时间
                    close_datetime=trade.close_datetime().isoformat() if trade.dtclose else None, # 平仓时间
                    size=trade.size, # 最终大小应为0
                    price=trade.price, # 最终价格应为0
                    value=trade.value, # 最终价值应为0
                    # 可以添加更多信息，如开仓/平仓订单 refs
                    order_refs=[o.ref for o in getattr(trade, 'orders_obj', []) if o] # 如果 trade 对象能直接访问订单对象
                                       # 或者记录 trade.orders (这是 ref 列表)
                                       # order_refs_list=list(getattr(trade, 'orders', []))
                )

                # 更新风险管理状态：连续亏损计数
                # Update risk management status: consecutive loss count
                if trade.pnlcomm < 0:
                    self.consecutive_losses += 1
                else:
                    self.consecutive_losses = 0 # 盈利则重置计数

                # 记录完成的交易详情
                # Record completed trade details
                self.completed_trades.append({
                    'ref': trade.ref,
                    'pnl': trade.pnl,
                    'pnlcomm': trade.pnlcomm,
                    'commission': trade.commission,
                    'open_dt': trade.open_datetime(),
                    'close_dt': trade.close_datetime(),
                    'len': trade.barlen,
                    'data': trade.getdataname(),
                    'trade_cycle_id': trade_cycle_id # 记录关联 ID
                })
                # self.log(f'TRADE CLOSED: Ref: {trade.ref}, PnL: {trade.pnl:.2f}, PnLComm: {trade.pnlcomm:.2f}, Comm: {trade.commission:.2f}', data=trade.data)

                # --- 主要清理逻辑 ---
                # 3. **红色字体**: 清理 `order_ref_to_trade_id_map` 中与此交易相关的所有条目。
                #    **讲人话**: 这笔交易结束了，把它涉及的所有订单号都从小本本上擦掉，防止混乱。
                refs_to_remove = list(getattr(trade, 'orders', [])) # 获取关联的 order refs
                # print(f"DEBUG: Trade closed (Cycle ID: {trade_cycle_id}). Refs to remove: {refs_to_remove}")
                for order_ref in refs_to_remove:
                    if order_ref in self.order_ref_to_trade_id_map:
                        removed_id = self.order_ref_to_trade_id_map.pop(order_ref)
                        # print(f"DEBUG: Removed order ref {order_ref} (Cycle ID: {removed_id}) from map in notify_trade.")
                    # else:
                        # print(f"DEBUG: Order ref {order_ref} not found in map during cleanup.")


                # 4. **红色字体**: 重置 `current_trade_cycle_id` (除非允许多个并发交易)。
                #    **讲人话**: 这笔交易完成了，把“当前交易流程 ID”清空，准备记录下一笔。
                # 注意: 如果策略设计允许多个独立、并发的交易周期，这里的逻辑需要修改，
                # 不能简单地将 current_trade_cycle_id 设为 None。
                # 需要判断关闭的 trade_cycle_id 是否是当前的 self.current_trade_cycle_id。
                if trade_cycle_id == self.current_trade_cycle_id:
                    self.current_trade_cycle_id = None
                    # print(f"DEBUG: Reset current_trade_cycle_id because closed trade matched.")
                # else:
                    # print(f"DEBUG: Closed trade cycle ID {trade_cycle_id} did not match current {self.current_trade_cycle_id}. Not resetting.")

                # 更新交易状态变量
                # Update trading state variables
                self.in_trade = False
                self.trade_direction = 0
                self.buy_price = None # 清除买入价格信息
                self.buy_comm = None

            elif trade.justopened:
                 # 交易刚刚开仓
                 # Trade just opened
                 # self.log(f'TRADE OPENED: Ref: {trade.ref}, Size: {trade.size}, Price: {trade.price:.2f}', data=trade.data)
                 # 记录最后开仓的交易ID，用于后续平仓信号的关联 (简化处理)
                 self.last_opened_trade_id = trade_cycle_id
                 pass
    ```

6.  **修改 `_calculate_trade_size` 方法 (如果需要记录计算细节):**
    *   此方法已存在，可以在其中添加对计算过程或结果的日志记录，但这会稍微增加代码修改量。如果需要，可以在计算完成返回结果前记录 `ORDER_CALCULATION` 的一部分信息，或者在 `next` 中记录完整信息。鉴于最小化修改原则，建议在 `next` 方法中记录 `ORDER_CALCULATION`。

7.  **修改 `run_backtest` (或其他主执行函数):**
    *   调用 `setup_logging`。
    *   将 `logger` 实例传递给 `cerebro.addstrategy`。
    *   在运行结束后调用 `stop_logging`。

    ```python
    # 1393 行
    def run_backtest():
        start_time = time.time() # 记录开始时间

        # 1. **蓝色字体**: 获取回测配置。
        #    **讲人话**: 读取我们之前设定好的回测参数，比如用哪个策略、多少本金、日志怎么记等等。
        config = get_backtest_config()
        # print("回测配置:", config) # 打印配置用于调试

        # --- 设置日志系统 ---
        # 2. **红色字体**: 配置并启动日志系统。
        #    **讲人话**: 根据配置，把日志记录器准备好，让它开始工作。
        # 提取日志相关配置，并添加策略名和数据名（如果适用）
        log_config = config.get('logging', {}) # 获取日志配置字典
        log_config['strategy_name'] = config.get('strategy_class', AShareETFStrategy).__name__
        # 假设我们主要关心第一个数据源的日志名，或者可以传入 None
        # 实际应用中可能需要更复杂的逻辑来决定 data_name
        first_data_config = config.get('data_feeds', [{}])[0]
        log_config['data_name'] = os.path.splitext(os.path.basename(first_data_config.get('file', 'UnknownData')))[0]

        # print("日志配置:", log_config) # 打印日志配置用于调试
        main_logger = setup_logging(log_config)
        # --- 结束设置日志系统 ---


        # 3. **蓝色字体**: 初始化 Cerebro 引擎和 Broker。
        #    **讲人话**: 创建回测引擎 (Cerebro) 和模拟交易所 (Broker)。
        cerebro = setup_cerebro_and_broker(config)

        # 4. **蓝色字体**: 加载数据到 Cerebro。
        #    **讲人话**: 把我们要回测的股票/ETF 的历史价格数据加载进来。
        # 确保正确传递 fromdate 和 todate
        fromdate = datetime.datetime.strptime(config['time_period']['start_date'], '%Y-%m-%d') if config['time_period']['start_date'] else None
        todate = datetime.datetime.strptime(config['time_period']['end_date'], '%Y-%m-%d') if config['time_period']['end_date'] else None
        # print(f"Loading data from {fromdate} to {todate}") # 调试日期

        all_datas = load_data_to_cerebro(
            cerebro,
            config['data_feeds'],
            config['column_mapping'],
            config['openinterest_col'],
            fromdate=fromdate,
            todate=todate
        )
        # print(f"数据加载完成，共 {len(all_datas)} 个数据源。") # 调试数据加载

        # 5. **蓝色字体**: 添加策略及相关组件（分析器、观察器等）。
        #    **讲人话**: 把我们写好的交易策略，还有一些用来分析结果的工具 (Analyzers) 和画图的工具 (Observers) 都加到引擎里。
        # **红色字体**: 将 logger 实例传递给策略。
        # **讲人话**: 把日志记录工具交给策略，让策略可以用它来写日志。
        add_strategy_components(cerebro, config, logger=main_logger) # <--- 传递 logger

        # 6. **蓝色字体**: 运行回测或优化。
        #    **讲人话**: 让引擎带着策略和数据跑起来！模拟交易过程。
        print("开始运行回测...")
        results = cerebro.run(
            optreturn=config.get('optreturn', True), # 从配置读取 optreturn
            maxcpus=config.get('maxcpus', 1) # 从配置读取 maxcpus
        )
        print("回测运行结束。")

        # 7. **蓝色字体**: 处理并报告结果。
        #    **讲人话**: 回测跑完了，整理结果，看看赚了多少钱，画个图表。
        process_and_report_results(results, cerebro, config, start_time)

        # --- 停止日志系统 ---
        # 8. **红色字体**: 停止日志监听器（如果是异步模式）。
        #    **讲人话**: 回测结束了，告诉后台写日志的小助手可以下班了。
        stop_logging()
        # --- 结束停止日志系统 ---

    if __name__ == '__main__':
        run_backtest()

    ```

8.  **添加 `stop_logging` 调用:** 确保在程序退出前停止日志监听器。这已在 `run_backtest` 的末尾添加。

**四、 总结与核心概念类比**

*   **核心概念: 结构化日志 (JSON Lines)**
    *   **专业表达:** 采用 JSON Lines 格式记录日志，确保每条日志都是一个独立的、机器可读的 JSON 对象，包含清晰的键值对信息。
    *   **<0xE8><0xAE><0xB2><0xE4><0xBA><0xBA><0xE8><0xAF><0x9D>讲人话:** 以前写日志可能就像随手写日记，比较乱，回头找信息费劲。现在我们要求**<font color='blue'>写日志像填表格 (JSON 对象)</font>**，每一行 (`JSON Line`) 就是一张填好的表格，项目 (键) 和内容 (值) 都清清楚楚，电脑很容易就能读懂和整理。
    *   **类比:** 把日志想象成**<font color='red'>超市购物小票</font>**。每张小票 (`JSON Line`) 都是一次完整的记录，上面清楚地列着商品名称 (键)、数量 (值)、单价 (值)、时间 (值) 等等，而不是一堆混在一起的文字描述。这样方便后续统计分析哪些商品卖得好。
*   **核心概念: `trade_cycle_id` (交易周期ID)**
    *   **专业表达:** 为每个独立的交易生命周期（从信号识别到最终平仓）分配一个全局唯一的标识符，并在所有与该周期相关的日志事件中记录此 ID，以实现端到端的追踪和关联分析。
    *   **<0xE8><0xAE><0xB2><0xE4><0xBA><0xBA><0xE8><0xAF><0x9D>讲人话:** 我们做的每一笔完整的交易（从发现机会、下单、成交、到最后卖掉），都要给它起一个**<font color='blue'>独一无二的追踪代号 (`trade_cycle_id`)</font>**。然后，跟这笔交易有关的所有记录（比如什么时候发现信号、什么时候下的单、什么时候成交的、最后赚了还是亏了），都要带上这个代号。
    *   **类比:** `trade_cycle_id` 就像一个**<font color='red'>快递包裹的运单号</font>**。从发货 (信号触发) -> 中转 (下单/计算) -> 派送 (订单成交) -> 签收 (交易关闭/盈利亏损)，这个运单号一直跟着包裹 (交易流程) 相关的所有信息记录，方便我们随时查询这个包裹到哪了，经历了哪些环节。
*   **核心概念: 异步日志写入**
    *   **专业表达:** 利用队列和独立的监听线程，将日志写入操作与策略主执行线程解耦，避免 I/O 阻塞影响策略执行性能。
    *   **<0xE8><0xAE><0xB2><0xE4><0xBA><0xBA><0xE8><0xAF><0x9D>讲人话:** 写日志到文件是比较慢的操作。为了不让写日志这件事拖慢我们做交易决策的速度，我们**<font color='blue'>找个“后台小助手” (监听线程) 专门负责写日志</font>**。策略主程序想记日志时，就把信息快速地扔到一个“篮子” (队列) 里，然后继续干别的。小助手会自己从篮子里拿出信息，慢慢地写到日志文件里去。
    *   **类比:** 这就像**<font color='red'>餐馆的服务员和后厨</font>**。服务员 (策略主线程) 负责快速接收顾客点单 (产生日志信息)，把菜单递给后厨 (放入日志队列)。后厨 (日志监听线程) 则负责按顺序炒菜 (写入日志文件)，服务员不用一直等着后厨做完菜才能接待下一桌客人。这样效率更高。

**五、 记忆口诀**

日志增强要记牢，核心三点不能少：
**表格**清晰 JSON 好 (`JSON Lines`),
**单号**追踪流程跑 (`trade_cycle_id`),
**助手**后台性能高 (`异步写入`).

**说明:**

*   以上代码修改是基于您提供的 `bt_g2.5t_strategy.py` 文件结构和《BT日志系统开发需求文档 v11.txt》进行的。
*   **最小化修改:** 我们主要通过添加新方法 (`log_event`, `setup_logging`, `stop_logging`)、在现有方法中插入 `log_event` 调用以及添加必要的成员变量 (`logger`, `strategy_id`, `order_ref_to_trade_id_map`, `current_trade_cycle_id`) 来实现功能，尽量避免重构现有策略逻辑。
*   **`trade_cycle_id` 管理:** 这是最复杂的部分，特别是清理逻辑。目前的实现假设非并发交易，并在 `notify_trade` 中清理。如果未来策略支持并发交易，需要调整 `current_trade_cycle_id` 的重置逻辑和映射管理。
*   **事件覆盖:** 代码示例覆盖了需求文档中大部分关键事件的记录点。您可以根据具体策略逻辑，在需要的地方（如特定的风险判断、复杂的信号组合逻辑后）添加更多的 `log_event` 调用。
*   **错误处理:** `log_event` 中添加了基础的 `try...except` 来保证日志系统的健壮性。
*   **配置:** 日志的具体配置（路径、文件名、异步开关等）现在通过 `run_backtest` 中的 `config` 字典传入 `setup_logging` 函数，这符合需求文档中外部配置的要求。您需要确保 `get_backtest_config` 函数能提供这些配置项。
*   **注释:** 已按照要求在修改和添加的代码下方添加了详细注释，并用中英文结合的方式解释。重点内容使用了颜色标记和“讲人话”的解释。

请将这些修改应用到您的 `bt_g2.5t_strategy.py` 文件中，并确保在运行前回测的主脚本部分正确调用 `setup_logging` 和 `stop_logging`，并将 `logger` 实例传递给策略。
