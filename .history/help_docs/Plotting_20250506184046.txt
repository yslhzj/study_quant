  

该观察器跟踪当前的基金份额。  

参数  ：无  

Plotting-绘图 #  

尽管回测主要是基于数学计算的自动化过程，但人们常常希望能够实际可视化所发生 

的一切。不论是使用已经经过回测的现有算法，还是查看数据所产生的内置或自定义 

指标，绘图都能帮助人们更好地理解所发生的事情，剔除、修改或创建新的想法。  

由于所有操作背后都是人类，绘制数据馈送、指标、操作、现金流动和投资组合价值 

的演变图表有助于人们更好地理解过程，从而做出更明智的决策。因此，backtrader  

使用 matplotlib 提供的功能，内置了绘图设施。  

如何绘图 #  

任何回测运行都可以通过调用一个方法进行绘图：  

当然，这通常是最后一个命令。例如，以下简单代码使用了 backtrader 源代码中的一 

个示例数据：  

Python  
from __future__ import (absolute_import, division, print_function,  
unicode_literals)  
import backtrader as bt  
class St(bt.Strategy):  
    def __init__(self):  
        self.sma = bt.indicators.SimpleMovingAverage(self.data)  
data = bt.feeds .BacktraderCSVData(dataname='../../datas/2005-2006- 
day-001.txt')  
cerebro = bt.Cerebro()  
cerebro.adddata(data)  
cerebro.addstrategy(St)  
cerebro.run()  
cerebro.plot()  

这将生成以下图表：  

  

  

  

图表包含了 3 个观察器，由于缺乏任何交易，它们在这种情况下几乎没有意义：  

1.  CashValue 观察器：跟踪回测运行期间的现金和总投资组合价值（包括现金）。  

  
﻿  

2.  Trade 观察器：在交易结束时显示实际的利润和亏损。交易定义为开仓并将仓位 

归零（直接或从多头转为空头或从空头转为多头）。  

3.  BuySell 观察器：在价格图上绘制买入和卖出操作的位置。  

这 3 个观察器由 cerebro  自动添加，可以通过 stdstats 参数控制（默认：True）。如 

果希望禁用它们，可以如下操作：  

Python  
cerebro = bt.Cerebro(stdstats=False)  

或在运行时：  

Python  
cerebro = bt.Cerebro()  
...cerebro.run(stdstats=False)  

绘图元素 #  

尽管前面提到了观察器，它们并不是唯一被绘制的元素。以下 3 种元素会被绘制：  

1.  使用 adddata  、  replaydata 和  resampledata 添加到 Cerebro 的数据馈送。  

2.  在策略级别声明的指标（或通过 addindicator 添加到 cerebro 的指标，这纯粹 

用于实验目的，并将指标添加到一个虚拟策略中）。  

3.  使用 addobserver 添加到 cerebro 的观察器。  

观察器是与策略同步运行的线性对象，并且可以访问整个生态系统，以便跟踪现金和 

价值等内容。  

绘图选项 #  

指标和观察器有几个选项可以控制它们在图表上的绘制方式，分为 3 大类：  

1.  影响整个对象绘图行为的选项。  

2.  影响单个线条绘图行为的选项。  

3.  影响系统级别绘图选项的选项。  

对象级绘图选项 #  

这些选项由指标和观察器中的 plotinfo 数据集控制：  

Python  
plotinfo = dict(  

  
﻿  

    plot=True,  
    subplot=True,  
    plotname='',  
    plotskip=False,  
    plotabove=False,  
    plotlinelabels=False,  
    plotlinevalues=True,  
    plotvaluetags=True,  
    plotymargin=0.0,  
    plotyhlines=[],  
    plotyticks=[],  
    plothlines=[],  
    plotforce=False,  
    plotmaster=None,  
    plotylimited=True,  
)  

尽管 plotinfo 在类定义时显示为字典，但 backtrader 的元类机制将其转变为一个可 

以继承的对象，并且可以进行多重继承。例如：  

如果子类将 subplot=True 更改为 subplot=False  ，则层级结构中的进一步子类将 

具有后者作为 subplot  的默认值。  

有两种方法为这些参数赋值。让我们看一下 SimpleMovingAverage 实例化的第一种 

方法：  

Python  
sma = bt.indicators.SimpleMovingAverage(self.data, period=15,  
plotname='mysma')  

从示例中可以推断， SimpleMovingAverage 构造函数未消耗的任何 **kwargs 都将被 

解析（如果可能）为 plotinfo 值。 SimpleMovingAverage 只有一个定义的参数， 

即 period  。这意味着 plotname 将匹配 plotinfo  中同名的参数。  

第二种方法：  

Python  
sma = bt.indicators.SimpleMovingAverage(self.data, period=15)  
sma.plotinfo.plotname =  'mysma'  

与 SimpleMovingAverage 一起实例化的 plotinfo 对象可以被访问，并且其中的参 

数也可以通过标准的 Python 点符号访问。与上面的语法相比，这种方法更容易理解。  

参数含义 #  

  
﻿  

•  plot ：是否绘制该对象。  

•  subplot  ：是否与数据一起绘制或在独立的子图中绘制。例如，移动平均线是绘 

制在数据上的，而随机指标和 RSI 则是在不同的刻度上绘制的。  

•  plotname  ：在图表上使用的名称，而不是类名。例如上面的 mysma 而不是  

SimpleMovingAverage  。  

•  plotskip  （已弃用）： plot  的旧别名。  

•  plotabove  ：是否在数据之上绘制，否则在数据下方绘制。这仅在  

subplot=True  时有效。  

•  plotlinelabels  ：是否在图表的图例中显示单个线条的名称，当 subplot=False  

时。  

•  plotlinevalues  ：控制图例中是否包含指标和观察器线条的最后绘制值。可以通 

过每条线的 _plotvalue 控制。  

•  plotvaluetags  ：控制是否在线条的右侧绘制带有最后值的标签。可以通过每条线 

的 _plotvaluetag 控制。  

•  plotymargin  ：在图表上单个子图顶部和底部添加的边距。它是一个以  1 为基数 

的百分比。例如：0.05 表示 5%。  

•  plothlines  ：一个包含值的可迭代对象（在刻度内），在这些值处绘制水平线。例 

如，经典指标的超买、超卖区域通常在 70 和 30 处绘制线。  

•  plotyticks  ：一个包含值的可迭代对象（在刻度内），在这些值处特意放置刻度值。 

例如，强制刻度有 50 以识别刻度的中点。  

•  plotyhlines  ：一个包含值的可迭代对象（在刻度内），在这些值处绘制水平线。 

如果未定义上述任何项，那么水平线和刻度的位置将完全由此值控制。  

•  plotforce  ：如果所有其他方法都失败，这是一个最后的强制绘图机制。  

•  plotmaster  ：一个指标/观察器有一个主控，它是工作的数据。在某些情况下，可 

能希望与不同的主控一起绘图。  

•  plotylimited  ：目前仅适用于数据馈送。如果为 True        （默认），其他线条在数据 

图上的绘图不会改变刻度。  

线条特定绘图选项 #  

指标/观察器有线条，如何绘制这些线条可以通过 plotlines 对象进行影响。大多数  

plotlines  中的选项旨在直接传递给 matplotlib。文档主要通过示例进行说明。  

重要：选项是按每条线条指定的。  

一些选项由 backtrader 直接控制，这些选项都以 _ 开头：  

  
﻿  

•   _plotskip   （布尔值）：如果设置为 True  ，表示跳过绘制特定线条。  

•   _plotvalue   （布尔值）：控制此线条的图例是否包含最后绘制的值（默认值为  

True ）。  

•   _plotvaluetag   （布尔值）：控制是否在线条右侧绘制带有最后值的标签（默认值 

为 True ）。  

•   _name    （字符串）：更改特定线条的绘图名称。  

•   _skipnan    （布尔值，默认：  False ）：跳过绘制 NaN 值。  

•   _samecolor    （布尔值）：强制下一条线条使用与前一条相同的颜色，避免  

matplotlib 为每个新绘制的元素循环颜色图。  

•   _method    （字符串）：选择 matplotlib 用于绘制元素的方法。  

示例：  

•   MACDHisto 使用 `_  

method=‘bar’` 绘制直方图。  

•   BuySell 观察器：  

Python  
plotlines = dict(  
    buy=dict(marker='^', markersize=8.0, color='lime',  
fillstyle='full'),  
    sell=dict(marker='v', markersize=8.0, color='red',  
fillstyle='full')  
)  

•   Trades 观察器：  

Python  
lines = ('pnlplus', 'pnlminus')  
plotlines = dict(  
    pnlplus=dict(_name='Positive', marker='o', color='blue',  
markersize=8.0, fillstyle='full'),  
    pnlminus=dict(_name='Negative', marker='o', color='red',  
markersize=8.0, fillstyle='full')  
)  

系统级绘图选项 #  

cerebro 的 plot 方法签名：  

  
﻿  

Python  
def plot(self, plotter=None, numfigs=1, iplot=True, **kwargs):  

•   plotter ：一个包含控制系统级绘图选项的对象/类。如果为 None  ，则创建默认  

PlotScheme 对象。  

•   numfigs ：将图表分解为多少个独立的图表。  

•   iplot ：如果在 Jupyter Notebook  中运行，自动内联绘图。  

•   kwargs  ：将用于更改 plotter 或默认 PlotScheme 对象的属性值。  

PlotScheme #  

包含控制系统级绘图的所有选项的对象。选项在代码中有文档说明。  

颜色 #  

PlotScheme 类定义了一个方法，可以在子类中重写，该方法返回要使用的下一个颜 

色：  

其中 idx 是当前线条的索引。默认颜色方案是 Tableau 10 颜色调色板，索引修改为：  

Python  
tab10_index =  [3, 0, 2, 1, 2, 4, 5, 6, 7, 8, 9]  

🔗 原文链接： https://www.poloxue.com/backtrader/...  

⏰ 剪存时间：2025-03- 15 15:57:21 (UTC+8)  

✂️ 本文档由 飞书剪存 一键生成  

Plotting-在同轴绘图 #  

在之前的文章“future-spot” 中，我们在同一空间上绘制了原始数据和略微（随机）修改 

后的数据，但它们并没有在同一轴上绘制。  

恢复该文章的第一张图片：  

  

  

  

我们可以看到：  

•   图表的左右两侧有不同的刻度。  

  
﻿  

•   当观察摆动的红线（随机化数据）时最明显，它在原始数据周围上下摆动大约 50  

个点。  

•   在图表上，视觉印象是这种随机化数据大部分时间都在原始数据上方。这只是由 

于不同刻度导致的视觉印象。  

虽然  1.9.32.116  版本已经初步支持完全在同一轴上绘图，但图例标签会重复（仅标签， 

不是数据），这会让人感到困惑。  

1.9.33.116 版本修复了这个问题，允许完全在同一轴上绘图。使用模式类似于选择使 

用哪个数据进行绘图。在之前的文章中：  

Python  
import backtrader as bt  
cerebro = bt.Cerebro()  
data0 = bt.feeds .MyFavouriteDataFeed(dataname='futurename')  
cerebro.adddata(data0)  
data1 = bt.feeds .MyFavouriteDataFeed(dataname='spotname')  
data1.compensate(data0)  # 告诉系统 data1 的操作影响  
data0data1.plotinfo.plotmaster = data0  
data1.plotinfo.sameaxis = Truecerebro.adddata(data1)  
...  
cerebro.run()  

data1 获取一些 plotinfo 值来：  

•   与 plotmaster    （即 data0）在同一空间绘图。  

•   获取使用 sameaxis  的指示。  

原因是平台无法提前知道每个数据的刻度是否兼容。因此，它们会在独立的刻度上绘 

图。  

在之前的示例中，增加了一个选项在 sameaxis 上绘图。示例执行：  

Shell  
$ ./future-spot.py --sameaxis  

结果图表：  

  

  

  

需要注意的是：  

•   右侧只有一个刻度。  

  
﻿  

•   现在，随机化数据似乎明显在原始数据周围摆动，这是预期的视觉行为。  

示例用法 #  

Shell  
$ ./future-spot.py --help  
usage: future-spot.py [-h] [--no-comp] [--sameaxis]  
Compensation example  
optional arguments:  
  -h, --help  show this help message and exit  
  --no-comp  
  --sameaxis  

示例代码 #  

Python  
from __future__ import (absolute_import, division, print_function,  
unicode_literals)  
import argparse  
import random  
import backtrader as bt  
# 修改收盘价的过滤器 def close_changer(data, *args, **kwargs):  
    data.close[0] += 50.0 * random.randint(-1, 1)  

    return False  # 流长度不变  

# 重写标准标记 class BuySellArrows(bt.observers.BuySell):  
    plotlines = dict(buy=dict(marker='$\u21E7$', markersize=12.0),  
                     sell=dict(marker='$\u21E9$',  
markersize=12.0))  
class St(bt.Strategy):  
    def __init__(self):  
        bt.obs.BuySell(self.data0, barplot=True)  # 在此处完成         

BuySellArrows(self.data1, barplot=True)  # 为不同的数据设置不同的标 

记  
    def next(self):  
        if not self.position:  
            if random.randint(0, 1):  
                self.buy(data=self.data0)  
                self.entered = len(self)  

        else:  # 在市场中            if (len(self) -  
self.entered) >= 10:  
                self.sell(data=self.data1)  
def runstrat(args=None):  

  
﻿  

    args = parse_args(args)  
    cerebro = bt.Cerebro()  

    dataname =  '../../datas/2006-day-001.txt'  # 数据馈送  
    data0 = bt.feeds .BacktraderCSVData(dataname=dataname,  
name='data0')  
    cerebro.adddata(data0)  
    data1 = bt.feeds .BacktraderCSVData(dataname=dataname,  
name='data1')  
    data1.addfilter(close_changer)  
    if not args.no_comp:  
        data1.compensate(data0)  
    data1.plotinfo.plotmaster = data0  
    if args.sameaxis:  
        data1.plotinfo.sameaxis = True    cerebro.adddata(data1)  
    cerebro.addstrategy(St)  # 示例策略  

    cerebro.addobserver(bt.obs.Broker)  # 通过 stdstats=False 移除     

cerebro.addobserver(bt.obs.Trades)  # 通过 stdstats=False 移除  
    cerebro.broker.set_coc(True)  
    cerebro.run(stdstats=False)  # 执行     

cerebro.plot(volume=False)  # 并绘图  
def parse_args(pargs=None):  
    parser = argparse.ArgumentParser(  
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  
        description=('Compensation example'))  
    parser.add_argument('--no-comp', required=False,  
action='store_true')  
    parser.add_argument('--sameaxis', required=False,  
action='store_true')  
    return parser.parse_args(pargs)  
if __name__ ==  '__main__':  
    runstrat()  

🔗 原文链接： https://www.poloxue.com/backtrader/...  

⏰ 剪存时间：2025-03- 15 16:06:48 (UTC+8)  

✂️ 本文档由 飞书剪存 一键生成  

Plotting- 日期范围 #  

在  1.9.31.x 版本中，backtrader 增加了部分绘图的功能。  

可以使用策略实例中保存的完整时间戳数组的索引来指定绘图范围  

也可以使用实际的 datetime.date 或 datetime.datetime 实例来限制绘图范围。  

  
﻿  

仍然通过标准的 cerebro.plot 进行。例如：  

Python  
cerebro.plot(start=datetime.date(2005, 7, 1),  
end=datetime.date(2006, 1, 31))  

这对人类来说是最直接的方法。具有扩展能力的人类实际上可以尝试使用时间戳的索 

引，如下所示：  

Python  
cerebro.plot(start=75, end=185)  

下面是一个非常标准的示例，其中包含一个简单移动平均线（在数据上绘图）、一个随 

机指标（独立绘图）以及随机指标线的交叉。在命令行参数中传递给 cerebro.plot  

的参数。  

使用日期方法的执行：  

Shell  
./partial-plot.py --plot 'start=datetime.date(2005, 7,  
1),end=datetime.date(2006, 1, 31)'  

Python 中的 eval 魔法允许直接在命令行中编写 datetime.date 并将其映射到实际有 

意义的内容。输出图表如下所示：  

  

  

  

让我们将其与完整的绘图进行比较，以查看数据是否确实从两端跳过：  

Python 中的 eval 魔法允许直接在命令行中编写 datetime.date 并将其映射到实际有 

意义的内容。输出图表如下所示：  

  

  

  

示例用法 #  

Shell  
$ ./partial-plot.py --help  
usage: partial-plot.py [-h] [--data0 DATA0] [--fromdate FROMDATE]                        

  
﻿  

[--todate TODATE] [--cerebro kwargs] [--broker kwargs]                        
[--sizer kwargs] [--strat kwargs] [--plot [kwargs]]  
Sample for partial plotting  
optional arguments:  
  -h, --help           show this help message and exit  
  --data0 DATA0        Data to read in (default:  
                        ../../datas/2005-2006-day-001.txt)  -- 
fromdate FROMDATE  Date[time] in YYYY-MM-DD[THH:MM:SS] format  
(default: )  --todate TODATE      Date[time] in YYYY-MM- 
DD[THH:MM:SS] format (default: )  --cerebro kwargs     kwargs in  
key=value format (default: )  --broker kwargs      kwargs in  
key=value format (default: )  --sizer kwargs       kwargs in  
key=value format (default: )  --strat kwargs       kwargs in  
key=value format (default: )  --plot [kwargs]      kwargs in  
key=value format (default: )  

示例代码 #  

Python  
from __future__ import (absolute_import, division, print_function,  
unicode_literals)  
import argparse  
import datetime  
import backtrader as bt  
class St(bt.Strategy):  
    params = ()  
    def __init__(self):  
        bt.ind.SMA()  
        stoc = bt.ind.Stochastic()  
        bt.ind.CrossOver(stoc.lines.percK, stoc.lines.percD)  
    def next(self):  
        pass  
def runstrat(args=None):  
    args = parse_args(args)  
    cerebro = bt.Cerebro()  
    # 数据馈送 kwargs    kwargs = dict()  

    # 解析 from/to-date    dtfmt, tmfmt =  '%Y-%m-%d', 'T%H:%M:%S'     
for a, d in ((getattr(args, x), x) for x in ['fromdate',  
'todate']):  
        if a:  
            strpfmt = dtfmt + tmfmt * ('T' in a)  
            kwargs[d] = datetime.datetime.strptime(a, strpfmt)  
    # 数据馈送    data0 =  

  
﻿  

bt.feeds .BacktraderCSVData(dataname=args.data0, **kwargs)  
    cerebro.adddata(data0)  

    # 经纪人    cerebro.broker =  
bt.brokers.BackBroker(**eval('dict(' + args.broker +  ')'))  
    # 大小调整器    cerebro.addsizer(bt.sizers.FixedSize,  
**eval('dict(' + args.sizer +  ')'))  
    # 策略    cerebro.addstrategy(St, **eval('dict(' + args.strat  
+  ')'))  
    # 执行    cerebro.run(**eval('dict(' + args.cerebro +  ')'))  

    if args.plot:  # 如果请求绘图，则绘制         
cerebro.plot(**eval('dict(' + args.plot +  ')'))  
def parse_args(pargs=None):  
    parser = argparse.ArgumentParser(  
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  
        description=(  
             'Sample for partial plotting'        )  
    )  
    parser.add_argument('--data0', default='../../datas/2005-2006- 
day-001.txt',  
                        required=False, help='Data to read in')  
    #  日期的默认值    parser.add_argument('--fromdate',  
required=False, default='',  
                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  
format')  
    parser.add_argument('--todate', required=False, default='',  
                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  
format')  
    parser.add_argument('--cerebro', required=False, default='',  
                        metavar='kwargs', help='kwargs in  
key=value format')  
    parser.add_argument('--broker', required=False, default='',  
                        metavar='kwargs', help='kwargs in  
key=value format')  
    parser.add_argument('--sizer', required=False, default='',  
                        metavar='kwargs', help='kwargs in  
key=value format')  
    parser.add_argument('--strat', required=False, default='',  
                        metavar='kwargs', help='kwargs in  
key=value format')  
    parser.add_argument('--plot', required=False, default='',  
                        nargs='?', const='{}',  
                        metavar='kwargs', help='kwargs in  
key=value format')  
    return parser.parse_args(pargs)  

  
Although _backtesting_ is meant to be an automated process based on mathematical calculations, it is often the case that one wants to actually visualize what’s going on. Be it with an existing algorithm which has undergone a backtesting run or looking at what really indicators (built-in or custom) deliver with the data.

And because everything has a human being behind it, charting the data feeds, indicators, operations, evolution of cash and portfolio value can help the humans to better appreciate what’s going on, discard/modify/create ideas and whatever the human looking at the chart may do with the visual information.

That’s why _backtrader_, using the facilities provided by `matplotlib`, provides built-in charting facilities.

## How to plot

Any backtesting run can be plotted with the invocation of a single method:

Of course this is usually the last command issued like in this simple code which uses one of the sample data from the _backtrader_ sources.

```
<span></span><code><span>from</span> <span>__future__</span> <span>import</span> <span>(</span><span>absolute_import</span><span>,</span> <span>division</span><span>,</span> <span>print_function</span><span>,</span>
                        <span>unicode_literals</span><span>)</span>

<span>import</span> <span>backtrader</span> <span>as</span> <span>bt</span>


<span>class</span> <span>St</span><span>(</span><span>bt</span><span>.</span><span>Strategy</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>):</span>
        <span>self</span><span>.</span><span>sma</span> <span>=</span> <span>bt</span><span>.</span><span>indicators</span><span>.</span><span>SimpleMovingAverage</span><span>(</span><span>self</span><span>.</span><span>data</span><span>)</span>


<span>data</span> <span>=</span> <span>bt</span><span>.</span><span>feeds</span><span>.</span><span>BacktraderCSVData</span><span>(</span><span>dataname</span><span>=</span><span>'../../datas/2005-2006-day-001.txt'</span><span>)</span>

<span>cerebro</span> <span>=</span> <span>bt</span><span>.</span><span>Cerebro</span><span>()</span>
<span>cerebro</span><span>.</span><span>adddata</span><span>(</span><span>data</span><span>)</span>
<span>cerebro</span><span>.</span><span>addstrategy</span><span>(</span><span>St</span><span>)</span>
<span>cerebro</span><span>.</span><span>run</span><span>()</span>
<span>cerebro</span><span>.</span><span>plot</span><span>()</span>
</code>
```

And this yields the following chart.

[![image](https://www.backtrader.com/docu/plotting/01-sample-code.png)](https://www.backtrader.com/docu/plotting/01-sample-code.png)

The chart includes 3 _Observers_ which in this case and given the lack of any trading are mostly pointless

- A `CashValue` observer which as the name implies keeps track of the `Cash` and total portolio `Value` (including cash) during the life of the backtesting run

- A `Trade` Observer which shows, at the end of a trade, the actual _Profit and Loss_

  A trade is defined as opening a position and taking the position back to `0` (directly or crossing over from long to short or short to long)

- A `BuySell` observer which plots (on top of the prices) where _buy_ and _sell_ operations have taken place

These _3 Observers_ are automatically added by `cerebro`, and are controlled with the `stdstats` parameter (default: `True`). Do the following to disable them if you wish:

```
<span></span><code><span>cerebro</span> <span>=</span> <span>bt</span><span>.</span><span>Cerebro</span><span>(</span><span>stdstats</span><span>=</span><span>False</span><span>)</span>
</code>
```

or later when _running_ as in:

```
<span></span><code><span>cerebro</span> <span>=</span> <span>bt</span><span>.</span><span>Cerebro</span><span>()</span>
<span>...</span>
<span>cerebro</span><span>.</span><span>run</span><span>(</span><span>stdstats</span><span>=</span><span>False</span><span>)</span>
</code>
```

## Plotted Elements

Although the `Observers` have already been mentioned above in the introduction, they are not the only elements to get plotted. These 3 things get plotted:

- _Data Feeds_ added to Cerebro with `adddata`, `replaydata` and `resampledata`

- _Indicators_ declared at strategy level (or added to cerebro with `addindicator` which is purely meant for experimentation purposes and has the indicator added to a dummy strategy)

- _Observers_ added to cerebro with `addobserver`

  The Observers are _lines_ objects which run in sync with the _strategy_ and have access to the entire ecosystem, to be able to track things like `Cash` and `Value`

## Plotting Options

_Indicators_ and _Observers_ have several options that control how they have to be plotted on the chart. There are 3 big groups:

-   Options affecting the plotting behavior of the entire object

-   Options affecting the plotting behavior of individual lines

-   Options affecting the SYSTEM wide plotting options

### Object-wide plotting options

These are controlled by this data set in _Indicators_ and _Observers_:

```
<span></span><code><span>plotinfo</span> <span>=</span> <span>dict</span><span>(</span><span>plot</span><span>=</span><span>True</span><span>,</span>
                <span>subplot</span><span>=</span><span>True</span><span>,</span>
                <span>plotname</span><span>=</span><span>''</span><span>,</span>
                <span>plotskip</span><span>=</span><span>False</span><span>,</span>
                <span>plotabove</span><span>=</span><span>False</span><span>,</span>
                <span>plotlinelabels</span><span>=</span><span>False</span><span>,</span>
                <span>plotlinevalues</span><span>=</span><span>True</span><span>,</span>
                <span>plotvaluetags</span><span>=</span><span>True</span><span>,</span>
                <span>plotymargin</span><span>=</span><span>0.0</span><span>,</span>
                <span>plotyhlines</span><span>=</span><span>[],</span>
                <span>plotyticks</span><span>=</span><span>[],</span>
                <span>plothlines</span><span>=</span><span>[],</span>
                <span>plotforce</span><span>=</span><span>False</span><span>,</span>
                <span>plotmaster</span><span>=</span><span>None</span><span>,</span>
                <span>plotylimited</span><span>=</span><span>True</span><span>,</span>
           <span>)</span>
</code>
```

Although `plotinfo` is shown as a `dict` during class definition, the metaclass machinery of _backtrader_ turns that into an object which is inherited and can undergo even multiple inheritance. Than means:

-   If a subclass changes for example a value like `subplot=True` to `subplot=False`, subclasses further down the hierarchy will have the latter as the default value for `subplot`

There are 2 methods of giving value to these parameters. Let’s look at a `SimpleMovingAverage` instantiation for the 1<sup>st</sup> method:

```
<span></span><code><span>sma</span> <span>=</span> <span>bt</span><span>.</span><span>indicators</span><span>.</span><span>SimpleMovingAverage</span><span>(</span><span>self</span><span>.</span><span>data</span><span>,</span> <span>period</span><span>=</span><span>15</span><span>,</span> <span>plotname</span><span>=</span><span>'mysma'</span><span>)</span>
</code>
```

As can be inferred from the example, any `**kwargs` not consumed by the `SimpleMovingAverage` constructor will be parsed (if possible) as `plotinfo` values. The `SimpleMovingAverage` has a single parameter defined which is `period`. And this means that `plotname` will be matched against the parameter of the same name in `plotinfo`.

The 2<sup>nd</sup> method:

```
<span></span><code><span>sma</span> <span>=</span> <span>bt</span><span>.</span><span>indicators</span><span>.</span><span>SimpleMovingAverage</span><span>(</span><span>self</span><span>.</span><span>data</span><span>,</span> <span>period</span><span>=</span><span>15</span><span>)</span>
<span>sma</span><span>.</span><span>plotinfo</span><span>.</span><span>plotname</span> <span>=</span> <span>'mysma'</span>
</code>
```

The `plotinfo` object instantiated along the _SimpleMovingAverage_ can be accessed and the parameters inside can also be accessed with the standard _Python_ dot notation. Easy and possibly clearer than the syntax abve.

#### The meaning of the options

- `plot`: whether the object has to be plotted

- `subplot`: whether to plot along the data or in an independent subchart. _Moving Averages_ are an example of plotting over the data. _Stochastic_ and _RSI_ are examples of things plotted in a subchart on a different scale.

- `plotname`: name to use on the chart instead of the _class_ name. As in the example above `mysma` instead of `SimpleMovingAverage`

- `plotskip` (**deprecated**): and old alias of `plot`

- `plotabove`: whether to plot above the data. Else plot below. This has only effect if `subplot=True`

- `plotlinelabels`: whether to plot the names of the individudal lines along the data in the legend on the chart when `subplot=False`

  Example: The _Bollinger Bands_ have 3 lines but the indicator is plotted on top of the data. It seems sensible to have the legend only display a single name like `BollingerBands` rather than having the name of the 3 individual lines displayed (`mid`, `top`, `bot`)

  A use case for this is the `BuySell` observer for which it makes sense to display the name of the 2 lines and its markers: `Buy` and `Sell` to make it clear for the end user what is what.

- `plotlinevalues`: controls whether the legend for the lines in indicators and observers has the last plotted value. Can be controlled on a per-line basis with `_plotvalue` for each line

- `plotvaluetags`: controls whether a value tag with the last value is plotted on the right hand side of the line. Can be controlled on a per-line basis with `_plotvaluetag` for each line

- `plotymargin`: margin to add to the top and bottom of individual subcharts on the graph

  It is a percentage but 1 based. For example: 0.05 -> 5%

- `plothlines`: an _iterable_ containing values (within the scale) at which _horizontal_ lines have to be plotted.

  This for example helps for the classical indicators with _overbought_, _oversold_ areas like the `RSI` which usually has lines plotted at `70` and `30`

- `plotyticks`: an _iterable_ containing values (within the scale) at which value ticks have to specifically be placed on the scale

  For example to force the scale to have a `50` to identify the mid point of the scale. Although this seems obvious, the indicators use an auto-scaling mechanism and the `50` may not be obviously be in the centre if an indicator with a `0-100` scale moves between 30-95 on a regular basis.

- `plotyhlines`: an _iterable_ containing values (within the scale) at which _horizontal_ lines have to be plotted.

  This can take over both `plothlines` and `plotyticks`.

  If none of the above are defined, then where to place _horizontal_ lines and _ticks_ will be entirely controlled by this value

  If any of the above are defined they have precedence over the values present in this option

- `plotforce`: sometimes and thus the complex process of matching data feeds to indicators and bla, bla, bla … a custom indicator may fail to plot. This is a last resort mechanism to try to enforce plotting.

  Use it if all else fails

- `plotmaster`: an _Indicator_/_Observer_ has a master which is the _data_ on which is working. In some cases plotting it with a different master may be wished needed.

  A use case is the `PivotPoint` indicator which is calculated on **Monthly** data but is meant for **Daily** data. It only makes sense to plot it on the _daily_ data which is where the indicator makes sense.

- `plotylimited`: currently only applies to data feeds. If `True` (default), other lines on the data plot don’t change the scale. Example: Bollinger Bands (top and bottom) may be far away from the actual absolute minimum/maximum of the data feed. With `\`plotlimited=True`, those bands remain out of the chart, because the data controls the scaling. If set to`False\`, the bands affects the y-scale and become visible on the chart

  A use case is the `PivotPoint` indicator which is calculated on **Monthly** data but is meant for **Daily** data. It only makes sense to plot it on the _daily_ data which is where the indicator makes sense.

### Line specific plotting options

_Indicators_/_Observers_ have _lines_ and how this _lines_ are plotted can be influenced with the `plotlines` object. Most of options specified in `plotlines` are meant to be directly passed over to `matplotlib` when plotting. The documentation relies therefore on examples of things that have been done.

**IMPORTANT**: The options are specified on a per-line basis.

Some of the options are controlled directly by _backtrader_. These all start with an underscore (`_`):

- `_plotskip` (_boolean_) which indicates that plotting of a specific line has to be skipped if set to `True`

- `_plotvalue` (_boolean_) to control if the legend of this line will contain the last plotted value (default is `True`)

- `_plotvaluetag` (_boolean_) to control if a righ hand side tag with the last value is plotted (default is `True`)

- `_name` (_string_) which changes the plot name of a specific line

- `_skipnan` (_bool_, default: False): to skip `NaN` values when plotting and allowing for example to draw a line between 2 distant points generated by an indicator, which has all intermediate values as `NaN` (default value for new created data points)

- `_samecolor` (_boolean_) this forces the next line to have the same color as the previous one avoiding the `matplotlib` default mechanism of cycling trough a color map for each new plotted element

- `_method` (_string_) which chooses the plotting method `matplotlib` will use for the element. If this is not specified, then the most basic `plot` method will be chosen.

  Example from `MACDHisto`. Here the `histo` line is plotted as a `bar` which is the industry de-facto standard. The following definition can be found in the definition of `MACDHisto`:

  ```
  <span></span><code><span>lines</span> <span>=</span> <span>(</span><span>'histo'</span><span>,)</span>
  <span>plotlines</span> <span>=</span> <span>dict</span><span>(</span><span>histo</span><span>=</span><span>dict</span><span>(</span><span>_method</span><span>=</span><span>'bar'</span><span>,</span> <span>alpha</span><span>=</span><span>0.50</span><span>,</span> <span>width</span><span>=</span><span>1.0</span><span>))</span>
  </code>
  ```

  `alpha` and `width` are options for _matplotlib_

- `_fill_gt` / `_fill_lt`

  Allow filling between the given line and:

  -   Another line

  -   A numeric value

  The arguments is an iterable of 2 elements in which:

  - The 1<sup>st</sup> argument is a _string_ (name of reference line) or a numeric value

    The filling will be done in between the own values and the values of the line or the numeric value

  - The 2<sup>nd</sup> argument is either:

    -   A string with a colour name (_matplotlib_ compatible) or hex specification (see _matloplit_ examples)

    or

    -   An iterable where the 1<sup>st</sup> element is the string/hex value for the colour and the second element is a numeric value specifying the alpha transparency (default: `0.20` controlled with `fillalpha` in a plotting scheme)

  Examples:

  ```
  <span></span><code><span># Fill for myline when above other_line with colour red</span>
  <span>plotlines</span> <span>=</span> <span>dict</span><span>(</span>
      <span>myline</span><span>=</span><span>dict</span><span>(</span><span>_fill_gt</span><span>(</span><span>'other_line'</span><span>,</span> <span>'red'</span><span>))</span>
  <span>)</span>
  
  <span># Fill for myline when above 50 with colour red</span>
  <span>plotlines</span> <span>=</span> <span>dict</span><span>(</span>
      <span>myline</span><span>=</span><span>dict</span><span>(</span><span>_fill_gt</span><span>(</span><span>50</span><span>,</span> <span>'red))</span>
  <span>)</span>
  
  <span># Fill for myline when above other_line with colour red and 50%</span>
  <span># transparency (1.0 means "no transparency")</span>
  
  <span>plotlines</span> <span>=</span> <span>dict</span><span>(</span>
      <span>myline</span><span>=</span><span>dict</span><span>(</span><span>_fill_gt</span><span>(</span><span>'other_line'</span><span>,</span> <span>(</span><span>'red'</span><span>,</span> <span>0.50</span><span>)))</span>
  <span>)</span>
  </code>
  ```

#### Passing options to a not yet known line

-   Ue the name `_X` where `X` stands for a digit in a zero-based index. This means that the options are for line `X`

A use case from `OscillatorMixIn`:

```
<span></span><code><span>plotlines</span> <span>=</span> <span>dict</span><span>(</span><span>_0</span><span>=</span><span>dict</span><span>(</span><span>_name</span><span>=</span><span>'osc'</span><span>))</span>
</code>
```

As the name implies, this is a _mixin_ class intended to be used in multiple inheritance schemes (specifically on the right hand side). The _mixin_ has no knowledge of the actual name of the 1<sup>st</sup> line (index is zero-based) from the other indicator that will be part of the multiple inheritance mix.

And that’s why the options are specified to be for: `_0`. After the subclassing has taken place the 1<sup>st</sup> line of the resulting class will have the name `osc` in plot.

#### Some plotlines examples

The `BuySell` observer has the following:

```
<span></span><code><span>plotlines</span> <span>=</span> <span>dict</span><span>(</span>
    <span>buy</span><span>=</span><span>dict</span><span>(</span><span>marker</span><span>=</span><span>'^'</span><span>,</span> <span>markersize</span><span>=</span><span>8.0</span><span>,</span> <span>color</span><span>=</span><span>'lime'</span><span>,</span> <span>fillstyle</span><span>=</span><span>'full'</span><span>),</span>
    <span>sell</span><span>=</span><span>dict</span><span>(</span><span>marker</span><span>=</span><span>'v'</span><span>,</span> <span>markersize</span><span>=</span><span>8.0</span><span>,</span> <span>color</span><span>=</span><span>'red'</span><span>,</span> <span>fillstyle</span><span>=</span><span>'full'</span><span>)</span>
<span>)</span>
</code>
```

The `buy` and `sell` lines have options which are passed directly to `matplotlib` to define _marker_, _markersize_, _color_ and _fillstyle_. All these options are defined in _matplotlib_

The `Trades` observer has the following:

```
<span></span><code><span>...</span>
<span>lines</span> <span>=</span> <span>(</span><span>'pnlplus'</span><span>,</span> <span>'pnlminus'</span><span>)</span>
<span>...</span>

<span>plotlines</span> <span>=</span> <span>dict</span><span>(</span>
    <span>pnlplus</span><span>=</span><span>dict</span><span>(</span><span>_name</span><span>=</span><span>'Positive'</span><span>,</span>
                 <span>marker</span><span>=</span><span>'o'</span><span>,</span> <span>color</span><span>=</span><span>'blue'</span><span>,</span>
                 <span>markersize</span><span>=</span><span>8.0</span><span>,</span> <span>fillstyle</span><span>=</span><span>'full'</span><span>),</span>
    <span>pnlminus</span><span>=</span><span>dict</span><span>(</span><span>_name</span><span>=</span><span>'Negative'</span><span>,</span>
                  <span>marker</span><span>=</span><span>'o'</span><span>,</span> <span>color</span><span>=</span><span>'red'</span><span>,</span>
                  <span>markersize</span><span>=</span><span>8.0</span><span>,</span> <span>fillstyle</span><span>=</span><span>'full'</span><span>)</span>
<span>)</span>
</code>
```

Here the names of the lines have been redefined from for example `pnlplus` to `Positive` by using `_name`. The rest of the options are for _matplotlib_

The `DrawDown` observer:

```
<span></span><code><span>lines</span> <span>=</span> <span>(</span><span>'drawdown'</span><span>,</span> <span>'maxdrawdown'</span><span>,)</span>

<span>...</span>

<span>plotlines</span> <span>=</span> <span>dict</span><span>(</span><span>maxdrawdown</span><span>=</span><span>dict</span><span>(</span><span>_plotskip</span><span>=</span><span>'True'</span><span>,))</span>
</code>
```

This one defines two lines to let the end users access not only the value of the current `drawdown` but also its maximum value (`maxdrawdown`). But the latter is not plotted due to `_plotskip=True`

The `BollingerBands` indicator:

```
<span></span><code><span>plotlines</span> <span>=</span> <span>dict</span><span>(</span>
    <span>mid</span><span>=</span><span>dict</span><span>(</span><span>ls</span><span>=</span><span>'--'</span><span>),</span>
    <span>top</span><span>=</span><span>dict</span><span>(</span><span>_samecolor</span><span>=</span><span>True</span><span>),</span>
    <span>bot</span><span>=</span><span>dict</span><span>(</span><span>_samecolor</span><span>=</span><span>True</span><span>),</span>
<span>)</span>
</code>
```

Here the `mid` line will have a _dashed_ style and the `top` and `bot` lines will have the same color as the `mid` line.

The `Stochastic` (defined in `_StochasticBase` and inherited):

```
<span></span><code><span>lines</span> <span>=</span> <span>(</span><span>'percK'</span><span>,</span> <span>'percD'</span><span>,)</span>
<span>...</span>
<span>plotlines</span> <span>=</span> <span>dict</span><span>(</span><span>percD</span><span>=</span><span>dict</span><span>(</span><span>_name</span><span>=</span><span>'%D'</span><span>,</span> <span>ls</span><span>=</span><span>'--'</span><span>),</span>
                 <span>percK</span><span>=</span><span>dict</span><span>(</span><span>_name</span><span>=</span><span>'%K'</span><span>))</span>
</code>
```

The slower line `percD` is plotted with a _dashed_ style. And the names of the lines are changed to include fancy `%` signs (`%K` and `%D`) which cannot be used in name definitions in _Python_

### Methods controlling plotting

When dealing with _Indicators_ and _Observers_ the following methods are supported to further control plotting:

- `_plotlabel(self)`

  Which should return a list of things to conform the labels which will be placed in between parentheses after the name of the _Indicators_ or _Observer_

  An example from the `RSI` indicator:

  ```
  <span></span><code><span>def</span> <span>_plotlabel</span><span>(</span><span>self</span><span>):</span>
      <span>plabels</span> <span>=</span> <span>[</span><span>self</span><span>.</span><span>p</span><span>.</span><span>period</span><span>]</span>
      <span>plabels</span> <span>+=</span> <span>[</span><span>self</span><span>.</span><span>p</span><span>.</span><span>movav</span><span>]</span> <span>*</span> <span>self</span><span>.</span><span>p</span><span>.</span><span>notdefault</span><span>(</span><span>'movav'</span><span>)</span>
      <span>return</span> <span>plabels</span>
  </code>
  ```

  As can be seen this method returns:

  - An `int` which indicates the period configured for the `RSI` and if the default moving average has been changed, the specific class

    In the background both will be converted to a string. In the case of the _class_ an effort will be made to just print the name of the class rather than the complete `module.name` combination.

- `_plotinit(self)`

  Which is called at the beginning of plotting to do whatever specific initialization the indicator may need. Again, an example from `RSI`:

  ```
  <span></span><code><span>def</span> <span>_plotinit</span><span>(</span><span>self</span><span>):</span>
      <span>self</span><span>.</span><span>plotinfo</span><span>.</span><span>plotyhlines</span> <span>=</span> <span>[</span><span>self</span><span>.</span><span>p</span><span>.</span><span>upperband</span><span>,</span> <span>self</span><span>.</span><span>p</span><span>.</span><span>lowerband</span><span>]</span>
  </code>
  ```

  Here the code assigns a value to `plotyhlines` to have horizontal lines (the `hlines` part) plotted at specific `y` values.

  The values of the parameters `upperband` and `lowerband` are used for this, which cannot be known in advance, because the parameters can be changed by the end user

### System-wide plotting options

First the _signature_ of `plot` within cerebro:

```
<span></span><code><span>def</span> <span>plot</span><span>(</span><span>self</span><span>,</span> <span>plotter</span><span>=</span><span>None</span><span>,</span> <span>numfigs</span><span>=</span><span>1</span><span>,</span> <span>iplot</span><span>=</span><span>True</span><span>,</span> <span>**</span><span>kwargs</span><span>):</span>
</code>
```

Which means:

- `plotter`: an object/class containing as attributes the options controlling the system wide plotting

  If `None` is passed a default `PlotScheme` object (see below) will be instantiated

- `numfigs`: in how many independent charts a plot has to be broken

  Sometimes a chart contains too many bars and will not be easily readable if packed in a single figure. This breaks it down in as many pieces as requested

- `iplot`: automatically plot inline if running inside a Jupyter Notebook

- `**kwargs`: the args will be used to change the values of the attributes of `plotter` or the default `PlotScheme` object created if no `plotter` is passed.

#### PlotScheme

This object contains all the options that contol system-wide plotting. The options are documented in the code:

```
<span></span><code><span>class</span> <span>PlotScheme</span><span>(</span><span>object</span><span>):</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>):</span>
        <span># to have a tight packing on the chart wether only the x axis or also</span>
        <span># the y axis have (see matplotlib)</span>
        <span>self</span><span>.</span><span>ytight</span> <span>=</span> <span>False</span>

        <span># y-margin (top/bottom) for the subcharts. This will not overrule the</span>
        <span># option plotinfo.plotymargin</span>
        <span>self</span><span>.</span><span>yadjust</span> <span>=</span> <span>0.0</span>
        <span># Each new line is in z-order below the previous one. change it False</span>
        <span># to have lines paint above the previous line</span>
        <span>self</span><span>.</span><span>zdown</span> <span>=</span> <span>True</span>
        <span># Rotation of the date labes on the x axis</span>
        <span>self</span><span>.</span><span>tickrotation</span> <span>=</span> <span>15</span>

        <span># How many "subparts" takes a major chart (datas) in the overall chart</span>
        <span># This is proportional to the total number of subcharts</span>
        <span>self</span><span>.</span><span>rowsmajor</span> <span>=</span> <span>5</span>

        <span># How many "subparts" takes a minor chart (indicators/observers) in the</span>
        <span># overall chart. This is proportional to the total number of subcharts</span>
        <span># Together with rowsmajor, this defines a proportion ratio betwen data</span>
        <span># charts and indicators/observers charts</span>
        <span>self</span><span>.</span><span>rowsminor</span> <span>=</span> <span>1</span>

        <span># Distance in between subcharts</span>
        <span>self</span><span>.</span><span>plotdist</span> <span>=</span> <span>0.0</span>

        <span># Have a grid in the background of all charts</span>
        <span>self</span><span>.</span><span>grid</span> <span>=</span> <span>True</span>

        <span># Default plotstyle for the OHLC bars which (line -&gt; line on close)</span>
        <span># Other options: 'bar' and 'candle'</span>
        <span>self</span><span>.</span><span>style</span> <span>=</span> <span>'line'</span>

        <span># Default color for the 'line on close' plot</span>
        <span>self</span><span>.</span><span>loc</span> <span>=</span> <span>'black'</span>
        <span># Default color for a bullish bar/candle (0.75 -&gt; intensity of gray)</span>
        <span>self</span><span>.</span><span>barup</span> <span>=</span> <span>'0.75'</span>
        <span># Default color for a bearish bar/candle</span>
        <span>self</span><span>.</span><span>bardown</span> <span>=</span> <span>'red'</span>
        <span># Level of transparency to apply to bars/cancles (NOT USED)</span>
        <span>self</span><span>.</span><span>bartrans</span> <span>=</span> <span>1.0</span>

        <span># Wether the candlesticks have to be filled or be transparent</span>
        <span>self</span><span>.</span><span>barupfill</span> <span>=</span> <span>True</span>
        <span>self</span><span>.</span><span>bardownfill</span> <span>=</span> <span>True</span>

        <span># Wether the candlesticks have to be filled or be transparent</span>
        <span>self</span><span>.</span><span>fillalpha</span> <span>=</span> <span>0.20</span>

        <span># Wether to plot volume or not. Note: if the data in question has no</span>
        <span># volume values, volume plotting will be skipped even if this is True</span>
        <span>self</span><span>.</span><span>volume</span> <span>=</span> <span>True</span>

        <span># Wether to overlay the volume on the data or use a separate subchart</span>
        <span>self</span><span>.</span><span>voloverlay</span> <span>=</span> <span>True</span>
        <span># Scaling of the volume to the data when plotting as overlay</span>
        <span>self</span><span>.</span><span>volscaling</span> <span>=</span> <span>0.33</span>
        <span># Pushing overlay volume up for better visibiliy. Experimentation</span>
        <span># needed if the volume and data overlap too much</span>
        <span>self</span><span>.</span><span>volpushup</span> <span>=</span> <span>0.00</span>

        <span># Default colour for the volume of a bullish day</span>
        <span>self</span><span>.</span><span>volup</span> <span>=</span> <span>'#aaaaaa'</span>  <span># 0.66 of gray</span>
        <span># Default colour for the volume of a bearish day</span>
        <span>self</span><span>.</span><span>voldown</span> <span>=</span> <span>'#cc6073'</span>  <span># (204, 96, 115)</span>
        <span># Transparency to apply to the volume when overlaying</span>
        <span>self</span><span>.</span><span>voltrans</span> <span>=</span> <span>0.50</span>

        <span># Transparency for text labels (NOT USED CURRENTLY)</span>
        <span>self</span><span>.</span><span>subtxttrans</span> <span>=</span> <span>0.66</span>
        <span># Default font text size for labels on the chart</span>
        <span>self</span><span>.</span><span>subtxtsize</span> <span>=</span> <span>9</span>

        <span># Transparency for the legend (NOT USED CURRENTLY)</span>
        <span>self</span><span>.</span><span>legendtrans</span> <span>=</span> <span>0.25</span>
        <span># Wether indicators have a leged displaey in their charts</span>
        <span>self</span><span>.</span><span>legendind</span> <span>=</span> <span>True</span>
        <span># Location of the legend for indicators (see matplotlib)</span>
        <span>self</span><span>.</span><span>legendindloc</span> <span>=</span> <span>'upper left'</span>

        <span># Plot the last value of a line after the Object name</span>
        <span>self</span><span>.</span><span>linevalues</span> <span>=</span> <span>True</span>

        <span># Plot a tag at the end of each line with the last value</span>
        <span>self</span><span>.</span><span>valuetags</span> <span>=</span> <span>True</span>

        <span># Default color for horizontal lines (see plotinfo.plothlines)</span>
        <span>self</span><span>.</span><span>hlinescolor</span> <span>=</span> <span>'0.66'</span>  <span># shade of gray</span>
        <span># Default style for horizontal lines</span>
        <span>self</span><span>.</span><span>hlinesstyle</span> <span>=</span> <span>'--'</span>
        <span># Default width for horizontal lines</span>
        <span>self</span><span>.</span><span>hlineswidth</span> <span>=</span> <span>1.0</span>

        <span># Default color scheme: Tableau 10</span>
        <span>self</span><span>.</span><span>lcolors</span> <span>=</span> <span>tableau10</span>

        <span># strftime Format string for the display of ticks on the x axis</span>
        <span>self</span><span>.</span><span>fmt_x_ticks</span> <span>=</span> <span>None</span>

        <span># strftime Format string for the display of data points values</span>
        <span>self</span><span>.</span><span>fmt_x_data</span> <span>=</span> <span>None</span>
</code>
```

#### Colors in PlotScheme

The `PlotScheme` class defines a method which can be overriden in subclasses which returns the next color to be used:

Where `idx` is the current index to the line being plotted on a individual subchart. The `MACD` for example plots 3 lines and hence the `idx` variable will only have the following values: `0`, `1` and `2`. The next chart (maybe another indicator) will star the count again at `0`.

The default color scheme used in _backtrader_ uses (as seen above) is the `Tableau 10 Color Palette` with the index modified to be:

```
<span></span><code><span>tab10_index</span> <span>=</span> <span>[</span><span>3</span><span>,</span> <span>0</span><span>,</span> <span>2</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>]</span>
</code>
```

By overriding the `color` method or passing a `lcolors` variable to `plot` (or in a subclass of `PlotScheme`) the colouring can be completely changed.

The source code contains also the defintions for the `Tableau 10 Light` and the `Tableau 20` color palettes.

Plotting Date Ranges
The release, 1.9.31.x added the capability to make partial plots.

Either with indices to the full length array of timestamps kept in strategy instances

Or with actual datetime.date or datetime.datetime instances that limit what has to be plotted.

Everything still over the standard cerebro.plot. Example:


cerebro.plot(start=datetime.date(2005, 7, 1), end=datetime.date(2006, 1, 31))
Being that the straightforward way to do it for humans. Humans with extended capabilities can actually try indices to the datetime timestamps as in:


cerebro.plot(start=75, end=185)
A very standard sample containing a Simple Moving Average (on-data plotting), a Stochastic (independent plotting) and a CrossOver of the Stochastic lines is presented below. The arguments to cerebro.plot are passed as command line arguments.

An execution with the date approach:


./partial-plot.py --plot 'start=datetime.date(2005, 7, 1),end=datetime.date(2006, 1, 31)'
The eval magic in python allows to directly write datetime.date in the command line and map actually that to something sensible. The output chart

image

Let’s compare it with the full plot to see that data was actually skipped from both ends:


./partial-plot.py --plot
The eval magic in python allows to directly write datetime.date in the command line and map actually that to something sensible. The output chart

image

Sample Usage

$ ./partial-plot.py --help
usage: partial-plot.py [-h] [--data0 DATA0] [--fromdate FROMDATE]
                       [--todate TODATE] [--cerebro kwargs] [--broker kwargs]
                       [--sizer kwargs] [--strat kwargs] [--plot [kwargs]]

Sample for partial plotting

optional arguments:
  -h, --help           show this help message and exit
  --data0 DATA0        Data to read in (default:
                       ../../datas/2005-2006-day-001.txt)
  --fromdate FROMDATE  Date[time] in YYYY-MM-DD[THH:MM:SS] format (default: )
  --todate TODATE      Date[time] in YYYY-MM-DD[THH:MM:SS] format (default: )
  --cerebro kwargs     kwargs in key=value format (default: )
  --broker kwargs      kwargs in key=value format (default: )
  --sizer kwargs       kwargs in key=value format (default: )
  --strat kwargs       kwargs in key=value format (default: )
  --plot [kwargs]      kwargs in key=value format (default: )
Sample Code

from __future__ import (absolute_import, division, print_function,
                        unicode_literals)


import argparse
import datetime

import backtrader as bt


class St(bt.Strategy):
    params = (
    )

    def __init__(self):
        bt.ind.SMA()
        stoc = bt.ind.Stochastic()
        bt.ind.CrossOver(stoc.lines.percK, stoc.lines.percD)

    def next(self):
        pass


def runstrat(args=None):
    args = parse_args(args)

    cerebro = bt.Cerebro()

    # Data feed kwargs
    kwargs = dict()

    # Parse from/to-date
    dtfmt, tmfmt = '%Y-%m-%d', 'T%H:%M:%S'
    for a, d in ((getattr(args, x), x) for x in ['fromdate', 'todate']):
        if a:
            strpfmt = dtfmt + tmfmt * ('T' in a)
            kwargs[d] = datetime.datetime.strptime(a, strpfmt)

    # Data feed
    data0 = bt.feeds.BacktraderCSVData(dataname=args.data0, **kwargs)
    cerebro.adddata(data0)

    # Broker
    cerebro.broker = bt.brokers.BackBroker(**eval('dict(' + args.broker + ')'))

    # Sizer
    cerebro.addsizer(bt.sizers.FixedSize, **eval('dict(' + args.sizer + ')'))

    # Strategy
    cerebro.addstrategy(St, **eval('dict(' + args.strat + ')'))

    # Execute
    cerebro.run(**eval('dict(' + args.cerebro + ')'))

    if args.plot:  # Plot if requested to
        cerebro.plot(**eval('dict(' + args.plot + ')'))


def parse_args(pargs=None):
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description=(
            'Sample for partial plotting'
        )
    )

    parser.add_argument('--data0', default='../../datas/2005-2006-day-001.txt',
                        required=False, help='Data to read in')

    # Defaults for dates
    parser.add_argument('--fromdate', required=False, default='',
                        help='Date[time] in YYYY-MM-DD[THH:MM:SS] format')

    parser.add_argument('--todate', required=False, default='',
                        help='Date[time] in YYYY-MM-DD[THH:MM:SS] format')

    parser.add_argument('--cerebro', required=False, default='',
                        metavar='kwargs', help='kwargs in key=value format')

    parser.add_argument('--broker', required=False, default='',
                        metavar='kwargs', help='kwargs in key=value format')

    parser.add_argument('--sizer', required=False, default='',
                        metavar='kwargs', help='kwargs in key=value format')

    parser.add_argument('--strat', required=False, default='',
                        metavar='kwargs', help='kwargs in key=value format')

    parser.add_argument('--plot', required=False, default='',
                        nargs='?', const='{}',
                        metavar='kwargs', help='kwargs in key=value format')

    return parser.parse_args(pargs)


if __name__ == '__main__':
    runstrat()
