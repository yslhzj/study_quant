<!-- Generated by SpecStory -->

# BT日志系统开发与实现 (2025-04-14 10:48:35)

_**User**_

@analyzer.py
@feed.py
@cerebro.py
@observer.py
@analyzer.py
@strategy.py
@indicator.py 
@position.py 
@trade.py 
@order.py 
@signal.py 
请先仔细阅读<BT日志系统开发需求文档 v11.txt>中的开发需求,依据所提供backtrader库中的源码文件,以此为基础,在bt_g2.5t_strategy.py文件中,严格按照<<BT日志系统开发需求文档v11.txt>>的开发需求进行step by step 实现,并将代码的改变应用到原文件中,最小化修改bt_g2.5t_strategy.py文件中的代码. 特别要实现在各日志中必须有统一索引字段,要充分的考虑到是要将日志保存在csv文件中,用于使用pandas进行后续的量化交易质量的分析.

---

_**Assistant**_



---

好的，我们来一步步地在 `bt_g2.5t_strategy.py` 文件中实现这个增强的日志系统，严格遵循 `BT日志系统开发需求文档 v11.txt` 的要求，并尽量减少对现有代码的改动。

**第一步：添加必要的库导入和常量定义**

我将首先在 `bt_g2.5t_strategy.py` 文件的顶部添加所需的 Python 库导入和日志事件类型常量。

```python
import logging
import logging.handlers
import json
import os
import datetime
import uuid
import threading
import queue
import atexit
from collections import OrderedDict
import backtrader as bt
# ... (保留原有的其他导入)

# 定义日志事件类型常量 (根据文档)
LOG_EVENT_TYPES = {
    "STRATEGY_INIT": "STRATEGY_INIT",
    "MARKET_STATE_ASSESSED": "MARKET_STATE_ASSESSED",
    "SIGNAL_TRIGGERED": "SIGNAL_TRIGGERED",
    "ORDER_CALCULATION": "ORDER_CALCULATION",
    "ORDER_SUBMITTED": "ORDER_SUBMITTED",
    "ORDER_STATUS_UPDATE": "ORDER_STATUS_UPDATE",
    "SL_TP_TRIGGERED": "SL_TP_TRIGGERED",
    "TRADE_CLOSED": "TRADE_CLOSED",
    "RISK_EVENT": "RISK_EVENT",
    "TRADE_SKIPPED": "TRADE_SKIPPED",
    "STRATEGY_STOP": "STRATEGY_STOP", # 新增策略停止事件
    "LOGGING_ERROR": "LOGGING_ERROR", # 日志系统内部错误
}
```

**第二步：实现自定义 JSON Formatter**

这个 Formatter 负责将日志记录转换为单行的 JSON 字符串。

```python
# 自定义JSON Formatter
class JsonFormatter(logging.Formatter):
    # (定义一个叫做JsonFormatter的格式化器，继承自logging.Formatter。)
    def format(self, record):
        # (定义format方法，用于将日志记录转换为JSON字符串。)
        log_entry = {
            'timestamp': datetime.datetime.utcfromtimestamp(record.created).strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z', # 使用 record.created 获取精确时间并转为UTC ISO格式 (使用日志记录创建时的精确时间，并把它变成UTC国际标准时间格式。)
            'level': record.levelname, # 日志级别 (日志的严重程度，比如INFO, ERROR。)
            'message': record.getMessage(), # 日志消息本身 (日志的具体内容。)
        }
        # 如果日志消息本身是字典 (比如通过 log_event 传递的)，则合并它们
        # (If the log message itself is a dictionary (e.g., passed via log_event), merge them)
        # (如果日志内容是个字典，就把里面的键值对拿出来，放到日志条目里。)
        if isinstance(record.msg, dict):
            log_entry.update(record.msg)
            # 移除原始的 'message' 键，因为它已经被合并了
            # (Remove the original 'message' key as it's merged)
            # (原始的message键就不需要了，因为内容已经合并进去了。)
            del log_entry['message']

        # 安全地处理无法序列化为JSON的字段
        # (Safely handle fields that cannot be serialized to JSON)
        # (把日志条目变成JSON字符串，如果遇到不能转换的类型，就把它变成字符串"非JSON序列化"。)
        return json.dumps(log_entry, default=lambda o: f"<not serializable: {type(o).__name__}>")

```

**第三步：实现日志系统设置函数**

这个函数将负责配置和初始化 logger。

```python
# --- 日志系统设置 ---
log_queue = queue.Queue(-1)  # 无限大小队列 (创建一个队列，用来放日志记录，想放多少放多少。)
log_listener = None # 日志监听器，稍后初始化 (先留个空位，后面再创建监听器。)
log_handler = None # 日志处理器，确保能关闭 (先留个空位，后面再创建处理器。)

def setup_logging(log_path='logs', log_filename_pattern='strategy_log_{strategy_name}_{timestamp:%Y%m%d_%H%M%S}.jsonl', log_level='INFO', log_async_write=True, strategy_name='default_strategy'):
    # (定义一个设置日志的函数，可以指定日志放哪里、文件名、记录级别、是否异步、策略名字。)
    global log_listener, log_handler
    # (告诉函数我们要用全局的监听器和处理器。)

    # 确保日志目录存在
    # (Make sure the log directory exists)
    # (检查放日志的文件夹在不在，不在就创建一个。)
    os.makedirs(log_path, exist_ok=True)

    # 生成日志文件名
    # (Generate log filename)
    # (根据模板生成日志文件的名字，包含策略名和时间戳。)
    timestamp_str = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
    log_filename = log_filename_pattern.format(strategy_name=strategy_name, timestamp=datetime.datetime.now())
    log_filepath = os.path.join(log_path, log_filename)

    # 获取根logger或特定logger
    # (Get the root logger or a specific logger)
    # (拿到一个日志记录器，名字叫'StrategyLogger'。)
    logger = logging.getLogger('StrategyLogger')
    logger.setLevel(getattr(logging, log_level.upper(), logging.INFO)) # 设置日志级别 (设置这个记录器只记录指定级别以上的信息。)
    logger.propagate = False # 防止日志向上传递给根logger (不让它把消息告诉上级记录器。)

    # 清理旧的 handlers，防止重复添加
    # (Clean up old handlers to prevent duplicates)
    # (如果这个记录器之前有处理器了，先把它们都拿掉。)
    for handler in logger.handlers[:]:
        logger.removeHandler(handler)
        handler.close()

    # 创建File Handler
    # (Create File Handler)
    # (创建一个文件处理器，用来把日志写到文件里。)
    log_handler = logging.FileHandler(log_filepath, encoding='utf-8')
    formatter = JsonFormatter() # 使用自定义Formatter (用我们自己定义的JSON格式。)
    log_handler.setFormatter(formatter)

    if log_async_write:
        # 使用异步写入
        # (Use asynchronous writing)
        # (如果配置了异步写入...)
        queue_handler = logging.handlers.QueueHandler(log_queue) # 创建队列处理器 (创建一个队列处理器，把日志先扔到队列里。)
        logger.addHandler(queue_handler) # 添加到logger (把队列处理器加给记录器。)

        # 确保只有一个 Listener 在运行
        # (Ensure only one Listener is running)
        # (如果监听器还没启动...)
        if log_listener is None:
            log_listener = logging.handlers.QueueListener(log_queue, log_handler, respect_handler_level=True) # 创建监听器 (创建一个监听器，负责从队列里拿日志，交给文件处理器去写。)
            log_listener.start() # 启动监听器 (启动监听器开始工作。)
            # 注册退出处理函数，确保队列被处理完毕且handler关闭
            # (Register exit handler to ensure queue is processed and handler is closed)
            # (注册一个程序退出时要做的事：停止监听器，关闭文件处理器。)
            atexit.register(stop_logging)
    else:
        # 使用同步写入
        # (Use synchronous writing)
        # (如果配置了同步写入...)
        logger.addHandler(log_handler) # 直接添加文件处理器 (直接把文件处理器加给记录器。)
        atexit.register(stop_logging) # 同样注册退出处理

    # (返回配置好的记录器。)
    return logger

def stop_logging():
    # (定义一个停止日志记录的函数。)
    global log_listener, log_handler
    # (告诉函数我们要用全局的监听器和处理器。)
    if log_listener:
        try:
            log_listener.stop() # 停止监听器 (停止监听器。)
            log_listener = None # 重置为None (把它设回空值。)
        except Exception as e:
            print(f"Error stopping logging listener: {e}", file=sys.stderr) # 打印错误信息到标准错误流 (如果停止时出错了，就打印错误信息。)
    if log_handler:
        try:
            log_handler.close() # 关闭文件处理器 (关闭文件处理器。)
            log_handler = None # 重置为None (把它设回空值。)
        except Exception as e:
            print(f"Error closing logging handler: {e}", file=sys.stderr) # 打印错误信息到标准错误流 (如果关闭时出错了，就打印错误信息。)

```

**第四步：修改 `run_backtest` 函数**

在这里，我们将初始化日志系统，并将 logger 实例传递给策略。

```python
# 在 run_backtest 函数开头附近
def run_backtest():
    # (定义运行回测的函数。)
    start_time = time.time() # 记录开始时间 (记一下现在几点了。)
    # ... (原有的配置加载代码)
    config = get_backtest_config() # 加载配置 (读取配置文件。)

    # --- 初始化日志系统 ---
    strategy_name_for_log = config.get('strategy_name', 'AShareETFStrategy') # 获取策略名用于日志文件名 (从配置里拿策略名字，没有就用默认的。)
    log_config = config.get('logging', {}) # 获取日志配置 (从配置里拿日志相关的设置。)
    logger = setup_logging(
        log_path=log_config.get('log_path', 'logs'), # 日志路径 (日志文件放哪。)
        log_filename_pattern=log_config.get('log_filename_pattern', 'strategy_log_{strategy_name}_{timestamp:%Y%m%d_%H%M%S}.jsonl'), # 文件名模板 (日志文件名怎么起。)
        log_level=log_config.get('log_level', 'INFO'), # 日志级别 (记录啥级别的日志。)
        log_async_write=log_config.get('log_async_write', True), # 是否异步 (要不要异步写。)
        strategy_name=strategy_name_for_log # 策略名 (策略叫啥名。)
    )
    # (设置好日志系统，拿到记录器。)

    # ... (原有的 Cerebro 设置代码)
    cerebro = setup_cerebro_and_broker(config) # 设置Cerebro和Broker (准备好回测大脑和交易账户模拟器。)

    # --- 加载数据 ---
    load_data_to_cerebro(cerebro, config['data_files'], config['column_mapping'], config['openinterest_col'], config['fromdate'], config['todate']) # 加载数据到Cerebro (把交易数据喂给回测大脑。)

    # --- 添加策略和组件 ---
    # 修改这里，将 logger 传递给策略
    # (Modify here to pass the logger to the strategy)
    # (修改这里，把记录器传给策略。)
    strategy_params = config.get('strategy_params', {}) # 获取策略参数 (从配置里拿策略参数。)
    strategy_params['logger'] = logger # 添加logger到策略参数 (把记录器加到策略参数里。)
    strategy_params['strategy_id'] = str(uuid.uuid4()) # 添加唯一策略ID (给策略一个独一无二的身份证号。)
    strategy_params['log_config'] = log_config # 将日志配置也传入，策略可能需要 (把日志配置也传进去，万一策略要用呢。)

    if config.get('optimize', False):
        # ... (优化逻辑)
        strats = cerebro.optstrategy(
            AShareETFStrategy,
            **config['optimization_params'], # 将优化参数解包传入 (把优化要调的参数传进去。)
            # --- 传递非优化参数，包括 logger 和 strategy_id ---
            **strategy_params # 将普通策略参数（包含logger和ID）也传入optstrategy (把普通参数，包括记录器和ID，也传给优化。)
        )
        # ... (优化运行和结果处理)
    else:
        # 添加单个策略实例，传递参数，包括 logger
        # (Add a single strategy instance, passing parameters including logger)
        # (添加单个策略，把参数，包括记录器，传进去。)
        cerebro.addstrategy(AShareETFStrategy, **strategy_params)
        # ... (添加其他组件的代码)
        add_strategy_components(cerebro, config) # 添加策略组件 (给策略加上指标、分析器啥的。)

        # --- 运行回测 ---
        print("Running single backtest...") # 打印提示信息 (告诉大家要开始跑回测了。)
        results = cerebro.run() # 运行Cerebro (启动回测大脑开始跑。)
        # ... (结果处理)
        process_and_report_results(results, cerebro, config, start_time) # 处理和报告结果 (处理回测结果并展示。)

    # --- 确保日志在程序结束前停止 ---
    # atexit 应该会处理，但可以显式调用以防万一
    # (atexit should handle it, but call explicitly just in case)
    # (正常情况下atexit会自动处理，但以防万一，再手动调用一次停止日志。)
    stop_logging()

```

**第五步：修改 `AShareETFStrategy` 类**

这是改动最多的部分，需要添加日志初始化、`log_event` 方法，并在关键位置插入日志记录。

```python
# --- AShareETFStrategy 类 ---
class AShareETFStrategy(bt.Strategy):
    # (定义AShareETFStrategy策略类。)
    params = (
        ('ema_short_period', 12),
        ('ema_medium_period', 26),
        ('ema_long_period', 52),
        ('bbands_period', 20),
        ('bbands_dev', 2.0),
        ('rsi_period', 14),
        ('atr_period', 14),
        ('risk_per_trade_percent', 0.02), # 每笔交易风险百分比 (每笔交易最多亏本金的百分之多少。)
        ('max_total_risk_percent', 0.1), # 最大总风险百分比 (所有持仓加起来最多亏本金的百分之多少。)
        ('max_drawdown_percent', 0.2), # 最大回撤百分比 (账户从最高点最多亏多少就停手。)
        ('stop_loss_atr_multiplier', 2.0), # ATR止损倍数 (用ATR指标的几倍来设置止损。)
        ('take_profit_atr_multiplier', 3.0), # ATR止盈倍数 (用ATR指标的几倍来设置止盈。)
        ('partial_exit_percent', 0.5), # 部分退出百分比 (达到止盈一半时先卖掉多少。)
        ('partial_exit_target_multiplier', 1.5), # 部分退出目标倍数 (用ATR的几倍作为部分退出的目标。)
        ('rsi_oversold', 30), # RSI超卖阈值 (RSI指标低于多少算超卖。)
        ('rsi_overbought', 70), # RSI超买阈值 (RSI指标高于多少算超买。)
        ('use_dynamic_risk', True), # 是否使用动态风险 (要不要根据市场波动调整风险。)
        ('dynamic_risk_atr_period', 10), # 动态风险ATR周期 (计算动态风险用的ATR周期。)
        ('dynamic_risk_multiplier', 1.0), # 动态风险乘数 (动态风险调整的倍数。)
        ('enable_partial_exit', True), # 是否启用部分退出 (要不要用部分退出策略。)
        ('min_trade_interval_bars', 5), # 最小交易间隔期 (两次交易之间最少隔多少根K线。)
        ('trailing_stop_enabled', True), # 是否启用追踪止损 (要不要用追踪止损。)
        ('trailing_stop_atr_multiplier', 1.5), # 追踪止损ATR倍数 (追踪止损距离用ATR的几倍。)
        ('risk_reward_ratio_min', 1.5), # 最小风险回报比 (潜在盈利至少是潜在亏损的几倍才做。)
        # --- 日志系统参数 ---
        ('logger', None), # 日志记录器实例 (用来记录日志的对象。)
        ('strategy_id', None), # 策略实例的唯一ID (这个策略实例的身份证号。)
        ('log_config', {}), # 日志配置字典 (日志相关的设置。)
        # --- 其他参数 ---
        ('printlog', True), # 是否打印标准日志到控制台 (要不要在控制台打印买卖信息。)
    )

    def __init__(self, **kwargs): # 接受 **kwargs 以兼容 addstrategy 传递的参数 (接受可变参数，让addstrategy传参更灵活。)
        # (策略初始化函数。)
        # --- 处理传入的参数 ---
        # 如果 kwargs 包含 params 的键，优先使用 kwargs 中的值
        # (If kwargs contains keys from params, prioritize values from kwargs)
        # (如果通过addstrategy传了参数，就用传进来的值，否则用默认值。)
        for param, default_value in self.params._getitems():
            setattr(self.p, param, kwargs.get(param, default_value))

        # --- 日志系统初始化 ---
        self.logger = self.p.logger # 获取传入的 logger (拿到传进来的记录器。)
        self.strategy_id = self.p.strategy_id or str(uuid.uuid4()) # 获取或生成 strategy_id (拿到传进来的ID，没有就自己生成一个。)
        self.order_ref_to_trade_id_map = {} # 初始化订单引用到交易周期ID的映射 (创建一个空字典，用来存订单号和交易周期ID的对应关系。)
        self.current_trade_id = None # 当前激活的交易周期ID (记录当前正在进行的交易是哪个周期的，初始为空。)
        self.log_enabled = self.logger is not None # 判断日志是否启用 (看看记录器有没有成功传进来，有就启用日志。)
        self.current_data_id = None # 当前处理的数据ID (记录当前正在处理的数据的名字。)

        # 记录策略初始化事件
        # (Log strategy initialization event)
        # (记录一条策略初始化的日志。)
        if self.log_enabled:
            init_params = {k: getattr(self.p, k) for k, v in self.params._getitems() if k not in ['logger', 'log_config']} # 提取非日志相关的参数 (把策略参数提取出来，除了日志相关的。)
            self.log_event(
                event_type=LOG_EVENT_TYPES["STRATEGY_INIT"],
                data_feed=None, # 初始化时可能没有特定的 data_feed (初始化的时候可能还没有具体的数据。)
                strategy_name=self.__class__.__name__, # 策略类名 (策略的类名叫啥。)
                params=init_params, # 策略参数 (策略的参数是啥。)
                data_ids=[d._name for d in self.datas], # 所有数据源的ID列表 (这个策略用了哪些数据源。)
                strategy_id_assigned=self.strategy_id # 记录分配的ID (记录一下分配给这个策略实例的ID。)
            )


        # --- 原有初始化逻辑 ---
        # 引用数据源。
        # (Reference the data feeds.)
        # (把数据源方便地存起来。)
        self.data_close = {d._name: d.close for d in self.datas}
        self.data_open = {d._name: d.open for d in self.datas}
        self.data_high = {d._name: d.high for d in self.datas}
        self.data_low = {d._name: d.low for d in self.datas}
        self.data_volume = {d._name: d.volume for d in self.datas}
        self.data_datetime = {d._name: d.datetime for d in self.datas}

        # 初始化指标字典
        # (Initialize indicator dictionaries)
        # (创建空字典，用来存放每个数据源对应的指标。)
        self.ema_short = {}
        self.ema_medium = {}
        self.ema_long = {}
        self.bbands = {}
        self.rsi = {}
        self.atr = {}
        self.dynamic_atr = {} # 用于动态风险 (For dynamic risk) (用于动态风险计算的ATR。)
        self.position_size = {} # 用于存储每个数据源的持仓量 (To store position size for each data feed) (记录每个数据源现在持仓多少。)
        self.entry_price = {} # 用于存储每个数据源的入场价格 (To store entry price for each data feed) (记录每个数据源的买入价。)
        self.stop_loss_price = {} # 用于存储每个数据源的止损价格 (To store stop loss price for each data feed) (记录每个数据源的止损价。)
        self.take_profit_price = {} # 用于存储每个数据源的止盈价格 (To store take profit price for each data feed) (记录每个数据源的止盈价。)
        self.partial_exit_triggered = {} # 用于跟踪部分退出是否已触发 (To track if partial exit has triggered) (记录每个数据源的部分退出有没有触发过。)
        self.last_trade_bar = {} # 用于跟踪上次交易的bar索引 (To track the bar index of the last trade) (记录每个数据源上次交易是在第几根K线。)
        self.active_stop_loss_order = {} # 用于存储激活的止损订单引用 (To store active stop loss order reference) (记录每个数据源当前有效的止损单是哪个。)
        self.active_take_profit_order = {} # 用于存储激活的止盈订单引用 (To store active take profit order reference) (记录每个数据源当前有效的止盈单是哪个。)
        self.trailing_stop_price = {} # 用于存储追踪止损价格 (To store trailing stop price) (记录每个数据源的追踪止损价。)

        # 为每个数据源创建指标和初始化状态
        # (Create indicators and initialize state for each data feed)
        # (为咱们策略用到的每个股票/ETF数据，都创建一套指标和初始状态。)
        for data in self.datas:
            dname = data._name # 获取数据源名称 (拿到这个数据的名字，比如'sh510300'。)
            self.ema_short[dname] = bt.indicators.ExponentialMovingAverage(data.close, period=self.p.ema_short_period) # 短期EMA (计算短期指数移动平均线。)
            self.ema_medium[dname] = bt.indicators.ExponentialMovingAverage(data.close, period=self.p.ema_medium_period) # 中期EMA (计算中期指数移动平均线。)
            self.ema_long[dname] = bt.indicators.ExponentialMovingAverage(data.close, period=self.p.ema_long_period) # 长期EMA (计算长期指数移动平均线。)
            self.bbands[dname] = bt.indicators.BollingerBands(data.close, period=self.p.bbands_period, devfactor=self.p.bbands_dev) # 布林带 (计算布林带指标。)
            self.rsi[dname] = bt.indicators.RelativeStrengthIndex(data.close, period=self.p.rsi_period) # RSI (计算相对强弱指数。)
            self.atr[dname] = bt.indicators.AverageTrueRange(data, period=self.p.atr_period) # ATR (计算平均真实波幅。)
            self.dynamic_atr[dname] = bt.indicators.AverageTrueRange(data, period=self.p.dynamic_risk_atr_period) if self.p.use_dynamic_risk else None # 动态ATR (如果启用了动态风险，计算一个不同周期的ATR。)
            self.position_size[dname] = 0 # 初始化持仓量为0 (一开始没持有这个股票/ETF。)
            self.entry_price[dname] = 0.0 # 初始化入场价格为0 (还没买，所以买入价是0。)
            self.stop_loss_price[dname] = 0.0 # 初始化止损价格为0 (还没买，止损价也是0。)
            self.take_profit_price[dname] = 0.0 # 初始化止盈价格为0 (还没买，止盈价也是0。)
            self.partial_exit_triggered[dname] = False # 初始化部分退出状态为False (还没触发过部分退出。)
            self.last_trade_bar[dname] = -self.p.min_trade_interval_bars # 初始化上次交易bar，允许立即交易 (初始化上次交易时间，让一开始就能交易。)
            self.active_stop_loss_order[dname] = None # 初始化止损订单引用为None (还没有有效的止损单。)
            self.active_take_profit_order[dname] = None # 初始化止盈订单引用为None (还没有有效的止盈单。)
            self.trailing_stop_price[dname] = 0.0 # 初始化追踪止损价格为0 (还没买，追踪止损价也是0。)


        # 风险管理变量
        # (Risk management variables)
        # (跟风险控制相关的变量。)
        self.total_risk_percent = 0.0 # 当前总风险百分比 (目前所有持仓加起来的总风险占本金的百分比。)
        self.high_water_mark = self.broker.getvalue() # 最高水位线，用于计算回撤 (记录账户价值的最高点，用来算亏了多少。)
        self.current_drawdown = 0.0 # 当前回撤百分比 (当前账户从最高点亏了多少百分比。)
        self.trading_halted = False # 交易暂停标志 (一个开关，标记现在是不是因为风险太大暂停交易了。)


    # --- 新增 log_event 方法 ---
    def log_event(self, event_type: str, data_feed: bt.DataBase = None, **kwargs):
        # (定义一个记录日志事件的方法。)
        if not self.log_enabled:
            return # 如果日志未启用，直接返回 (如果日志没开，就不记了。)

        # 获取当前数据ID，如果 data_feed 未提供，则尝试使用 self.current_data_id
        # (Get current data ID, try using self.current_data_id if data_feed is not provided)
        # (拿到当前处理的数据的名字，如果调用时没给，就用next方法里存的那个。)
        current_data_id = data_feed._name if data_feed else self.current_data_id
        if current_data_id is None and self.datas:
             # 如果都没有，并且有数据，默认使用第一个数据
             # (If none exist and there is data, default to the first data)
             # (如果还没有名字，并且我们有数据，就用第一个数据的名字。)
             current_data_id = self.datas[0]._name

        log_entry = {
            # 'timestamp' 和 'level' 会由 formatter 添加 (Formatter will add 'timestamp' and 'level')
            'event_type': event_type, # 事件类型 (这是个什么类型的日志事件。)
            'strategy_id': self.strategy_id, # 策略实例ID (这个策略实例的身份证号。)
            'data_id': current_data_id or 'N/A', # 数据源ID (这个事件是关于哪个数据的。)
            'trade_cycle_id': self.current_trade_id if self.current_trade_id else kwargs.get('trade_cycle_id', None), # 交易周期ID (如果当前有交易周期ID，就用它；否则看看kwargs里有没有传，还没有就是空。)
            'bar_index': len(self.data0) if hasattr(self, 'data0') and len(self.data0) > 0 else -1, # 当前 K 线索引 (现在是第几根K线了。)
            'datetime': self.data0.datetime.datetime(0).isoformat() if hasattr(self, 'data0') and len(self.data0) > 0 else datetime.datetime.utcnow().isoformat() + 'Z', # 当前 K 线时间或当前 UTC 时间 (当前K线的时间，或者获取当前UTC时间。)
        }

        # 移除 kwargs 中可能重复的 trade_cycle_id
        # (Remove potentially duplicate trade_cycle_id from kwargs)
        # (如果kwargs里传了trade_cycle_id，就把它删了，免得重复。)
        if 'trade_cycle_id' in kwargs:
            del kwargs['trade_cycle_id']

        log_entry.update(kwargs) # 合并其他信息 (把调用时传进来的其他信息也加到日志里。)

        try:
            # 使用 logger 记录结构化数据
            # (Use logger to record structured data)
            # (用记录器把这条日志信息记下来。)
            self.logger.info(log_entry)
        except Exception as e:
            # 记录日志系统本身的错误到stderr
            # (Log errors from the logging system itself to stderr)
            # (如果记日志的时候出错了，比如数据格式不对，就把错误信息打印到控制台，并记一条专门的错误日志。)
            error_time = datetime.datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z'
            print(f"{error_time} [Logging Error] Failed to log event: {e}. Original entry: {log_entry}", file=sys.stderr)
            # 尝试记录日志错误事件本身
            # (Try logging the logging error event itself)
            try:
                error_log_entry = {
                    'event_type': LOG_EVENT_TYPES["LOGGING_ERROR"],
                    'strategy_id': self.strategy_id,
                    'error_message': str(e),
                    'original_event_type': event_type,
                    # 'original_data': log_entry # 可能导致递归错误，谨慎使用 (May cause recursive errors, use with caution)
                }
                self.logger.error(error_log_entry)
            except Exception as inner_e:
                print(f"{error_time} [Logging Error] Failed to log the logging error itself: {inner_e}", file=sys.stderr) # 打印内部错误信息 (如果记错误日志又出错了，就打印出来。)


    # --- 修改后的 log 方法 ---
    def log(self, txt, dt=None, data=None):
        # (策略自带的简单日志方法。)
        ''' Logging function for this strategy'''
        # (这个策略用来在控制台打印简单信息的方法。)
        if self.p.printlog: # 检查参数是否允许打印 (看看参数允不允许在控制台打印。)
            dt = dt or (data.datetime.date(0) if data else self.datas[0].datetime.date(0)) # 获取日期 (拿到日期。)
            print('%s, %s' % (dt.isoformat(), txt)) # 打印日志信息 (把日期和信息打印出来。)

    # --- notify_order 方法 ---
    def notify_order(self, order):
        # (订单状态通知函数。)
        # 查找与此订单关联的 trade_cycle_id
        # (Find the trade_cycle_id associated with this order)
        # (根据订单号，从我们存的映射关系里找到对应的交易周期ID。)
        order_trade_cycle_id = self.order_ref_to_trade_id_map.get(order.ref, 'ORPHANED_ORDER_' + str(order.ref)) # 获取交易周期ID，处理孤儿订单 (拿到ID，如果找不到，就标记为孤儿订单。)

        # --- 记录订单状态更新事件 ---
        if self.log_enabled:
            # (如果日志功能开了...)
            exec_details = None
            if order.executed.size: # 如果订单有执行部分 (如果订单成交了一部分或者全部...)
                exec_details = {
                    'price': order.executed.price, # 成交价 (成交价格是多少。)
                    'size': order.executed.size, # 成交量 (成交了多少股。)
                    'value': order.executed.value, # 成交金额 (成交金额是多少。)
                    'commission': order.executed.comm, # 手续费 (手续费花了多少。)
                    'pnl': order.executed.pnl, # 产生的盈亏 (这次成交产生了多少利润或亏损。)
                }
            # (记录一条订单状态更新的日志。)
            self.log_event(
                event_type=LOG_EVENT_TYPES["ORDER_STATUS_UPDATE"],
                data_feed=order.data, # 订单关联的数据源 (这个订单是哪个数据的。)
                trade_cycle_id=order_trade_cycle_id, # 交易周期ID (这个订单属于哪个交易周期。)
                order_ref=order.ref, # 订单引用号 (这个订单自己的编号。)
                status=order.getstatusname(), # 订单状态文本 (订单现在的状态是啥，比如 'Accepted', 'Completed'。)
                order_type=order.ordtypename(), # 订单类型 (是买单还是卖单。)
                exec_type=order.getordername(), # 执行类型 (是市价单、限价单还是啥。)
                size=order.size, # 订单总大小 (这个订单总共要买/卖多少。)
                price=order.price, # 订单价格 (订单设定的价格。)
                price_limit=order.pricelimit, # 限制价格 (如果是止损限价单，限制的价格是多少。)
                remaining_size=order.remaining, # 剩余未成交大小 (还有多少没成交。)
                created_time=order.created.dt, # 创建时间戳 (订单是啥时候创建的。)
                exec_details=exec_details, # 执行详情 (如果成交了，成交的细节是啥。)
                parent_ref=order.parent.ref if order.parent else None, # 父订单引用 (如果是子订单，它的父订单是谁。)
                oco_ref=order.oco.ref if order.oco else None, # OCO订单引用 (如果是一取消另一组的订单，同组的是谁。)
                info=dict(order.info) if hasattr(order, 'info') and order.info else None, # 订单附加信息 (订单有没有带啥额外信息。)
                current_position=self.getposition(order.data).size if order.data else None, # 当前持仓 (这个数据当前持仓多少。)
                broker_cash=self.broker.getcash(), # 当前现金 (账户里还有多少钱。)
            )


        # --- 原有 notify_order 逻辑 ---
        dname = order.data._name if order.data else self.datas[0]._name # 获取数据名称 (拿到订单对应数据的名字。)

        if order.status in [order.Submitted, order.Accepted]:
            # Buy/Sell order submitted/accepted to/by broker - Nothing to do
            # (订单已提交或被接受，暂时不用做啥。)
            self.log(f'ORDER ACCEPTED/SUBMITTED ref:{order.ref} for {dname}', data=order.data) # 记录日志 (在控制台打印一下。)
            return

        if order.status in [order.Completed]:
            # (订单完成了。)
            if order.isbuy():
                # (如果是买单完成了。)
                self.log(f'BUY EXECUTED ref:{order.ref}, Price: {order.executed.price:.2f}, Cost: {order.executed.value:.2f}, Comm: {order.executed.comm:.2f}', data=order.data) # 记录买入日志 (在控制台打印买入成交信息。)
                self.entry_price[dname] = order.executed.price # 更新入场价格 (记下买入价格。)
                self.position_size[dname] = self.getposition(order.data).size # 更新持仓量 (更新现在持仓多少。)
                # 撤销可能存在的止盈单 (如果之前有止盈单，先撤掉)
                if self.active_take_profit_order.get(dname):
                    self.cancel(self.active_take_profit_order[dname])
                    self.active_take_profit_order[dname] = None
                # 更新或设置追踪止损初始价格
                if self.p.trailing_stop_enabled and self.atr[dname][0] > 0:
                     self.trailing_stop_price[dname] = order.executed.price - self.p.trailing_stop_atr_multiplier * self.atr[dname][0]
                     self.log(f'BUY COMPLETED ref:{order.ref}: Initial Trailing Stop set at {self.trailing_stop_price[dname]:.2f}', data=order.data)


            elif order.issell():
                # (如果是卖单完成了。)
                self.log(f'SELL EXECUTED ref:{order.ref}, Price: {order.executed.price:.2f}, Cost: {order.executed.value:.2f}, Comm: {order.executed.comm:.2f}', data=order.data) # 记录卖出日志 (在控制台打印卖出成交信息。)
                # 撤销可能存在的止损单 (如果之前有止损单，先撤掉)
                if self.active_stop_loss_order.get(dname):
                    self.cancel(self.active_stop_loss_order[dname])
                    self.active_stop_loss_order[dname] = None
                # 如果是平仓操作，更新持仓状态
                # (If it's a closing operation, update position status)
                # (如果这个卖单是为了平掉之前的买单...)
                current_pos = self.getposition(order.data).size # 获取当前仓位 (看看现在持仓多少。)
                if current_pos == 0:
                    # (如果持仓变成0了，说明完全平仓了。)
                    self.log(f'POSITION CLOSED ref:{order.ref} for {dname}', data=order.data) # 记录平仓日志 (在控制台记录一下。)
                    self.position_size[dname] = 0 # 持仓量归零 (持仓设为0。)
                    self.entry_price[dname] = 0.0 # 入场价归零 (买入价设为0。)
                    self.stop_loss_price[dname] = 0.0 # 止损价归零 (止损价设为0。)
                    self.take_profit_price[dname] = 0.0 # 止盈价归零 (止盈价设为0。)
                    self.partial_exit_triggered[dname] = False # 重置部分退出标志 (部分退出标记重置。)
                    self.trailing_stop_price[dname] = 0.0 # 重置追踪止损价 (追踪止损价设为0。)
                    # 注意：trade_cycle_id 的清理主要在 notify_trade 中进行
                    # (Note: trade_cycle_id cleanup is primarily done in notify_trade)
                else:
                    # (如果持仓没变成0，说明是部分平仓。)
                    self.position_size[dname] = current_pos # 更新部分平仓后的持仓量 (更新一下现在还剩多少仓位。)


            # 记录上次交易的bar索引
            # (Record the bar index of the last trade)
            # (记下这次交易是在第几根K线。)
            self.last_trade_bar[dname] = len(data)

        elif order.status in [order.Canceled, order.Margin, order.Rejected, order.Expired]:
            # (订单被取消、保证金不足、被拒绝或过期了。)
            self.log(f'ORDER FAILED/CANCELLED ref:{order.ref} - Status: {order.getstatusname()}', data=order.data) # 记录失败日志 (在控制台打印失败信息。)
            # 如果这是一个我们追踪的活跃止损/止盈单，需要重置引用
            # (If this is an active SL/TP order we are tracking, reset the reference)
            # (如果这个失败的订单是我们正在用的止损单或止盈单，要把对应的记录清掉。)
            if self.active_stop_loss_order.get(dname) == order:
                self.active_stop_loss_order[dname] = None
                self.log(f'Active stop loss order ref:{order.ref} for {dname} is now inactive due to status {order.getstatusname()}', data=order.data)
            if self.active_take_profit_order.get(dname) == order:
                self.active_take_profit_order[dname] = None
                self.log(f'Active take profit order ref:{order.ref} for {dname} is now inactive due to status {order.getstatusname()}', data=order.data)

            # 考虑清理映射，但要小心Bracket订单，优先在notify_trade中清理
            # Consider cleaning the map, but be careful with Bracket orders, prioritize cleaning in notify_trade
            # if order.ref in self.order_ref_to_trade_id_map:
            #     # Check if it's part of a bracket first? Maybe not needed if cleaned in notify_trade
            #     # del self.order_ref_to_trade_id_map[order.ref]
            #     # self.log(f'Removed mapping for failed order ref:{order.ref}')
            #     pass



    # --- notify_trade 方法 ---
    def notify_trade(self, trade):
        # (交易完成通知函数。)
        # --- 查找与此交易关联的 trade_cycle_id ---
        trade_trade_cycle_id = 'ORPHANED_TRADE' # 默认值 (先假设找不到。)
        related_order_refs = [] # 这个交易涉及的所有订单号 (存一下这个交易包含哪些订单。)
        if hasattr(trade, 'orders'): # 检查 trade 对象是否有 orders 属性 (看看trade对象有没有记录它包含的订单。)
             related_order_refs = [o.ref for o in trade.orders if o] # 获取所有相关订单的ref (把所有订单的编号拿出来。)
             for order_ref in related_order_refs:
                 # (遍历这些订单号。)
                 trade_cycle_id_found = self.order_ref_to_trade_id_map.get(order_ref) # 尝试从映射中查找 (试试从我们存的映射关系里找交易周期ID。)
                 if trade_cycle_id_found:
                     # (如果找到了...)
                     trade_trade_cycle_id = trade_cycle_id_found # 使用找到的第一个ID (就用这个找到的ID。)
                     break # 找到一个即可退出循环 (找到了就不用再找了。)

        # --- 日志记录 ---
        if self.log_enabled:
            # (如果日志功能开了...)
            # (记录一条交易关闭/更新的日志。)
             self.log_event(
                event_type=LOG_EVENT_TYPES["TRADE_CLOSED"] if trade.isclosed else "TRADE_UPDATE", # 如果交易关闭了就记TRADE_CLOSED，否则记TRADE_UPDATE (看看交易是不是结束了，决定日志类型。)
                data_feed=trade.data, # 交易关联的数据源 (这个交易是哪个数据的。)
                trade_cycle_id=trade_trade_cycle_id, # 交易周期ID (这个交易属于哪个周期。)
                trade_ref=trade.ref, # 交易本身的引用号 (这个交易自己的编号。)
                order_refs=related_order_refs, # 关联的订单引用号列表 (这个交易涉及了哪些订单。)
                status=trade.status_names[trade.status], # 交易状态 (交易现在的状态，比如 'Open', 'Closed'。)
                pnl=trade.pnl, # 毛利润/亏损 (这次交易赚了/亏了多少钱（不算手续费）。)
                pnlcomm=trade.pnlcomm, # 净利润/亏损 (扣掉手续费后实际赚了/亏了多少钱。)
                commission=trade.commission, # 总手续费 (这次交易总共花了多少手续费。)
                value=trade.value, # 当前价值 (如果还没平仓，现在值多少钱。)
                size=trade.size, # 当前大小 (如果还没平仓，现在持仓多少。)
                price=trade.price, # 当前平均价格 (如果还没平仓，平均成本价是多少。)
                is_long=trade.long if hasattr(trade, 'long') else None, # 是否多头 (是做多还是做空。)
                is_closed=trade.isclosed, # 是否已关闭 (这个交易是不是结束了。)
                is_open=trade.isopen, # 是否已开仓 (这个交易是不是已经开仓了。)
                just_opened=trade.justopened, # 是否刚开仓 (是不是刚刚才开仓。)
                open_datetime=self.data.num2date(trade.dtopen).isoformat() if trade.dtopen else None, # 开仓时间 (啥时候开仓的。)
                close_datetime=self.data.num2date(trade.dtclose).isoformat() if trade.isclosed and trade.dtclose else None, # 平仓时间 (如果平仓了，是啥时候平的。)
                duration_bars=trade.barlen, # 持仓K线数 (持仓了多少根K线。)
                # history=trade.history # 包含历史记录可能使日志过大，谨慎使用 (包含交易的详细历史记录可能会让日志文件变得很大，小心使用。)
            )


        # --- 原有 notify_trade 逻辑 + ID 清理 ---
        if not trade.isclosed:
            # (如果交易还没结束，比如刚开仓或部分平仓...)
             # 更新风险指标等
             # (Update risk metrics, etc.)
             # (可以加一些更新风险指标的代码。)
            self.log(f'TRADE UPDATED ref:{trade.ref}, Pnl: {trade.pnlcomm:.2f}', data=trade.data) # 记录交易更新日志 (在控制台打印一下交易更新信息。)
            return # 交易未关闭，返回 (交易还没完，先不处理下面的。)

        # --- 交易已关闭 ---
        self.log(f'TRADE CLOSED ref:{trade.ref}, Profit Net: {trade.pnlcomm:.2f}', data=trade.data) # 记录交易关闭日志 (在控制台打印交易结束信息和最终盈亏。)

        # --- 清理 trade_cycle_id 映射 ---
        cleaned_refs = [] # 记录清理了哪些订单号 (存一下清理了哪些订单号。)
        if self.log_enabled:
            # (如果日志功能开了...)
            for order_ref in related_order_refs:
                # (遍历这个交易涉及的所有订单号。)
                if order_ref in self.order_ref_to_trade_id_map:
                    # (如果这个订单号在我们的映射表里...)
                    del self.order_ref_to_trade_id_map[order_ref] # 从映射中移除 (就把它从映射表里删掉。)
                    cleaned_refs.append(order_ref) # 记录已清理 (记下这个订单号已经被清理了。)

            # 检查当前交易周期ID是否与关闭的交易匹配，如果是，则重置
            # (Check if the current trade cycle ID matches the closed trade, if so, reset it)
            # (看看当前记录的交易周期ID是不是刚刚结束的这个交易的ID。)
            if self.current_trade_id == trade_trade_cycle_id:
                 # (如果是的话...)
                self.log(f'Resetting current_trade_id from {self.current_trade_id} as trade is closed.', data=trade.data) # 记录重置日志 (在控制台打印一下重置信息。)
                self.current_trade_id = None # 重置当前交易周期ID (把当前交易周期ID设回空值。)
            # (记录一下清理了哪些订单号和当前的交易周期ID。)
            self.log_event(
                event_type="TRADE_CYCLE_CLEANUP",
                data_feed=trade.data,
                trade_cycle_id_closed=trade_trade_cycle_id,
                cleaned_order_refs=cleaned_refs,
                remaining_mappings=len(self.order_ref_to_trade_id_map), # 还剩多少映射关系 (看看映射表里还剩多少东西。)
                current_active_trade_id=self.current_trade_id # 当前活跃的交易ID (当前活跃的交易周期ID是啥。)
            )


    # --- notify_cashvalue 方法 ---
    def notify_cashvalue(self, cash, value):
        # (现金和总资产值通知函数。)
        # 在每个 bar 结束时更新回撤和其他风险指标
        # (Update drawdown and other risk metrics at the end of each bar)
        # (在每根K线结束的时候，更新一下账户的回撤情况和其他风险指标。)
        self.current_drawdown = (self.high_water_mark - value) / self.high_water_mark if self.high_water_mark > 0 else 0.0 # 计算当前回撤 (算算从最高点亏了多少百分比。)
        self.high_water_mark = max(self.high_water_mark, value) # 更新最高水位线 (如果现在的总资产比之前的最高点还高，就更新最高点。)

        # 检查是否触发最大回撤限制
        # (Check if maximum drawdown limit is triggered)
        # (看看是不是亏得太多，触发了最大回撤限制。)
        if not self.trading_halted and self.current_drawdown >= self.p.max_drawdown_percent:
            # (如果还没暂停交易，并且亏损超过了最大限制...)
            self.trading_halted = True # 暂停交易 (就把交易暂停开关打开。)
            self.log(f'RISK EVENT: Maximum drawdown {self.p.max_drawdown_percent:.2%} reached. Halting trading. Current Drawdown: {self.current_drawdown:.2%}') # 记录风险事件日志 (在控制台打印风险提示。)
            # --- 记录风险事件 ---
            if self.log_enabled:
                # (如果日志功能开了...)
                # (记录一条风险事件的日志。)
                self.log_event(
                    event_type=LOG_EVENT_TYPES["RISK_EVENT"],
                    data_feed=self.data0, # 使用第一个数据作为参考 (用第一个数据的时间等信息。)
                    event_subtype='MAX_DRAWDOWN_REACHED', # 子类型：达到最大回撤 (说明是达到了最大回撤。)
                    account_value=value, # 当前账户总价值 (现在账户总值多少。)
                    cash=cash, # 当前现金 (现在账户里有多少现金。)
                    drawdown_pct=self.current_drawdown, # 当前回撤百分比 (当前亏损百分比。)
                    max_drawdown_limit=self.p.max_drawdown_percent, # 最大回撤限制 (设置的最大亏损限制是多少。)
                    high_water_mark=self.high_water_mark, # 最高水位线 (账户最高到过多少钱。)
                    message="Trading halted due to exceeding maximum drawdown limit." # 附加信息 (补充说明因为亏太多暂停交易了。)
                )

            # 取消所有挂单
            # (Cancel all pending orders)
            # (把所有还没成交的订单都取消掉。)
            self.log("Cancelling all pending orders due to max drawdown.") # 记录取消日志 (在控制台打印一下要取消订单了。)
            for data in self.datas:
                # (遍历所有数据源。)
                dname = data._name # 获取数据名称 (拿到数据名字。)
                if self.active_stop_loss_order.get(dname):
                    self.cancel(self.active_stop_loss_order[dname]) # 取消止损单 (取消这个数据的止损单。)
                if self.active_take_profit_order.get(dname):
                    self.cancel(self.active_take_profit_order[dname]) # 取消止盈单 (取消这个数据的止盈单。)
            # (这里可能还需要取消其他类型的挂单，如果策略中使用的话)
            # (Here you might need to cancel other types of pending orders if used in the strategy)


    # --- _calculate_trade_size 方法 ---
    def _calculate_trade_size(self, data_close_price, entry_price, stop_loss_price, risk_per_trade_percent, data=None):
        # (计算交易仓位大小的函数。)
        dname = data._name # 获取数据名称 (拿到数据名字。)
        cash = self.broker.getcash() # 获取可用现金 (看看现在有多少现金可以用。)
        total_value = self.broker.getvalue() # 获取账户总价值 (看看账户总共有多少钱。)

        # 应用动态风险调整（如果启用）
        # (Apply dynamic risk adjustment (if enabled))
        # (如果开了动态风险调整...)
        current_risk_multiplier = 1.0 # 默认风险乘数 (先假设风险乘数是1。)
        if self.p.use_dynamic_risk and self.dynamic_atr[dname][0] > 0:
            # (如果用了动态风险，并且动态ATR指标有值...)
            # 可以根据ATR或其他波动率指标调整风险百分比
            # Example: reduce risk in high volatility
            # (可以根据ATR或其他市场波动情况来调整风险。)
            # (例子：市场波动大的时候，降低风险。)
            base_atr = self.atr[dname][0] if self.atr[dname][0] > 0 else 1e-6 # 基础ATR (拿到正常的ATR值，如果为0就用一个很小的值代替，防止除零错误。)
            dynamic_atr_val = self.dynamic_atr[dname][0] # 动态ATR值 (拿到动态ATR的值。)
            volatility_ratio = dynamic_atr_val / base_atr # 计算波动率比率 (算算动态ATR和正常ATR的比值。)
            # 简单的示例：波动率高于平均水平时降低风险，低于时略微提高（限制上限）
            # Simple example: reduce risk when volatility is above average, slightly increase when below (with cap)
            # (简单举例：如果波动率比平时大，就把风险乘数调小；如果比平时小，可以稍微调大一点，但不能超过1.5倍。)
            current_risk_multiplier = max(0.5, min(1.5, 1.0 / volatility_ratio)) * self.p.dynamic_risk_multiplier # 计算风险乘数 (根据波动率比值和配置的乘数，算出最终的风险调整乘数，限制在0.5到1.5之间。)


        adjusted_risk_per_trade = risk_per_trade_percent * current_risk_multiplier # 调整后的单笔交易风险 (用基础风险乘以调整乘数，得到这次交易实际承担的风险百分比。)

        # 计算单笔交易最大允许亏损金额
        # (Calculate maximum allowed loss amount per trade)
        # (算算这笔交易最多能亏多少钱。)
        max_loss_per_trade = total_value * adjusted_risk_per_trade

        # 计算每股预期亏损
        # (Calculate expected loss per share)
        # (算算如果买入，每股可能亏多少钱。)
        loss_per_share = abs(entry_price - stop_loss_price) # 每股亏损额 (入场价和止损价的差就是每股可能亏的钱。)
        if loss_per_share <= 1e-9: # 避免除以零 (如果差值太小，接近零...)
            self.log(f"Warning: Loss per share is near zero ({loss_per_share}). Cannot calculate size for {dname}. Entry: {entry_price}, Stop: {stop_loss_price}", data=data) # 打印警告 (就打印个警告，告诉大家算不了仓位。)
             # --- 记录交易跳过事件 ---
            if self.log_enabled:
                self.log_event(
                    event_type=LOG_EVENT_TYPES["TRADE_SKIPPED"],
                    data_feed=data,
                    reason="ZERO_LOSS_PER_SHARE", # 原因：每股预期亏损为零 (原因是每股预期亏损是0。)
                    details={
                        "entry_price": entry_price,
                        "stop_loss_price": stop_loss_price,
                        "adjusted_risk_per_trade": adjusted_risk_per_trade,
                        "current_risk_multiplier": current_risk_multiplier,
                    },
                    # 尝试关联 trade_cycle_id (如果在此阶段之前已生成)
                    # Try to associate trade_cycle_id (if generated before this stage)
                    trade_cycle_id=self.current_trade_id
                )

            return 0 # 返回0表示无法计算大小 (返回0，表示买不了。)

        # 根据风险计算初始仓位大小（股数）
        # (Calculate initial position size (number of shares) based on risk)
        # (根据最多能亏多少钱和每股亏多少钱，算出理论上能买多少股。)
        size = int(max_loss_per_trade / loss_per_share) # 计算股数 (最多亏损金额除以每股亏损金额，取整数。)

        # 检查现金是否足够
        # (Check if there is enough cash)
        # (看看手里的现金够不够买这么多股。)
        required_cash = size * entry_price # 需要的现金 (算算买这么多股需要多少钱。)
        if required_cash > cash:
            # (如果需要的钱比现有的多...)
            size = int(cash / entry_price) # 根据现金调整大小 (就根据现金数量重新计算能买多少股。)
            self.log(f"Warning: Not enough cash for calculated size for {dname}. Reducing size to {size} based on available cash {cash:.2f}. Required: {required_cash:.2f}", data=data) # 打印警告 (打印个警告，说现金不够，减少了购买数量。)


        # 检查是否超过最大总风险限制
        # (Check if maximum total risk limit is exceeded)
        # (看看加上这笔交易后，会不会超过总风险限制。)
        new_trade_risk = size * loss_per_share / total_value if total_value > 0 else 0 # 这笔交易的风险百分比 (算算这笔交易占总资产的风险百分比。)
        if self.total_risk_percent + new_trade_risk > self.p.max_total_risk_percent:
            # (如果总风险超过了限制...)
            self.log(f"Warning: Adding this trade for {dname} would exceed max total risk {self.p.max_total_risk_percent:.2%}. Skipping trade. Current total risk: {self.total_risk_percent:.2%}, New trade risk: {new_trade_risk:.2%}", data=data) # 打印警告 (就打印个警告，说风险太大了，这笔交易不做了。)
            # --- 记录交易跳过事件 ---
            if self.log_enabled:
                 self.log_event(
                    event_type=LOG_EVENT_TYPES["TRADE_SKIPPED"],
                    data_feed=data,
                    reason="MAX_TOTAL_RISK_EXCEEDED", # 原因：超过最大总风险 (原因是超过了总风险限制。)
                    details={
                        "current_total_risk": self.total_risk_percent,
                        "new_trade_risk": new_trade_risk,
                        "max_total_risk_limit": self.p.max_total_risk_percent,
                        "calculated_size_before_risk_check": int(max_loss_per_trade / loss_per_share), # 风险检查前计算的大小 (在检查总风险之前算出来的大小是多少。)
                        "size_after_cash_check": size, # 现金检查后的大小 (检查完现金后的大小是多少。)
                        "entry_price": entry_price,
                        "stop_loss_price": stop_loss_price,
                    },
                    trade_cycle_id=self.current_trade_id # 关联交易周期ID (关联上交易周期ID。)
                )

            return 0 # 返回0表示跳过交易 (返回0，表示不买。)

        # 检查风险回报比
        # Check risk-reward ratio
        if self.p.risk_reward_ratio_min > 0:
            potential_profit_per_share = abs(self.take_profit_price[dname] - entry_price)
            if loss_per_share * self.p.risk_reward_ratio_min > potential_profit_per_share:
                 self.log(f"Warning: Risk/Reward ratio for {dname} is below minimum ({potential_profit_per_share / loss_per_share:.2f} < {self.p.risk_reward_ratio_min}). Skipping trade.", data=data)
                 # --- 记录交易跳过事件 ---
                 if self.log_enabled:
                    self.log_event(
                        event_type=LOG_EVENT_TYPES["TRADE_SKIPPED"],
                        data_feed=data,
                        reason="RISK_REWARD_RATIO_TOO_LOW",
                        details={
                            "entry_price": entry_price,
                            "stop_loss_price": stop_loss_price,
                            "take_profit_price": self.take_profit_price[dname],
                            "calculated_rr_ratio": potential_profit_per_share / loss_per_share if loss_per_share > 0 else float('inf'),
                            "min_rr_ratio": self.p.risk_reward_ratio_min,
                            "calculated_size": size
                        },
                        trade_cycle_id=self.current_trade_id
                    )
                 return 0 # Risk/reward ratio too low


        # --- 记录订单计算事件 ---
        if self.log_enabled:
             # (记录一条订单计算的日志。)
            self.log_event(
                event_type=LOG_EVENT_TYPES["ORDER_CALCULATION"],
                data_feed=data,
                trade_cycle_id=self.current_trade_id, # 关联交易周期ID (关联上交易周期ID。)
                signal_type=kwargs.get('signal_type', 'N/A'), # 触发信号类型 (是啥信号触发的计算。)
                entry_price_approx=entry_price, # 预估入场价 (大概在什么价格买。)
                stop_loss_calc=stop_loss_price, # 计算出的止损价 (算出来的止损价是多少。)
                take_profit_calc=self.take_profit_price[dname], # 计算出的止盈价 (算出来的止盈价是多少。)
                risk_inputs={ # 风险计算输入 (计算风险用了哪些数据。)
                    "risk_per_trade_param": risk_per_trade_percent, # 配置的单笔风险参数 (配置的单笔风险是多少。)
                    "use_dynamic_risk": self.p.use_dynamic_risk, # 是否用动态风险 (有没有用动态风险。)
                    "dynamic_risk_multiplier_param": self.p.dynamic_risk_multiplier, # 动态风险乘数参数 (配置的动态风险乘数是多少。)
                    "calculated_risk_multiplier": current_risk_multiplier, # 计算出的风险乘数 (算出来的实际风险乘数是多少。)
                    "adjusted_risk_per_trade": adjusted_risk_per_trade, # 调整后的单笔风险 (调整后的实际单笔风险是多少。)
                    "total_value": total_value, # 账户总值 (账户总资产。)
                    "max_loss_per_trade_calc": max_loss_per_trade, # 计算的单笔最大亏损金额 (算出来这笔最多亏多少钱。)
                    "loss_per_share_calc": loss_per_share, # 计算的每股亏损 (算出来每股亏多少。)
                },
                size_raw=int(max_loss_per_trade / loss_per_share) if loss_per_share > 0 else 0, # 原始计算大小 (最初根据风险算出来的大小。)
                size_after_cash_check=int(cash / entry_price) if required_cash > cash else int(max_loss_per_trade / loss_per_share), # 现金检查后的大小 (检查现金后的大小。)
                size_final=size, # 最终大小 (最终决定买多少。)
                adjustment_reasons= [ # 大小调整原因列表 (为啥调整了购买数量。)
                    "Cash limit reduced size" if required_cash > cash else None, # 如果现金不够，记录原因 (如果是因为现金不够减少的。)
                    "Max total risk limit prevented trade" if self.total_risk_percent + new_trade_risk > self.p.max_total_risk_percent else None, # 如果总风险超限，记录原因 (如果是因为总风险超了没买。)
                    "Risk/Reward ratio too low" if self.p.risk_reward_ratio_min > 0 and loss_per_share * self.p.risk_reward_ratio_min > potential_profit_per_share else None # 如果风险回报比不够，记录原因
                ],
                required_cash=required_cash, # 所需现金 (买这么多需要多少钱。)
                available_cash=cash, # 可用现金 (现在有多少现金。)
                current_total_risk=self.total_risk_percent, # 当前总风险 (现在总风险是多少。)
                new_trade_risk=new_trade_risk, # 新交易风险 (这笔交易的风险是多少。)
                max_total_risk_limit=self.p.max_total_risk_percent # 最大总风险限制 (设置的总风险限制是多少。)
            )


        # 返回最终计算出的、经过所有检查的仓位大小
        # (Return the final calculated position size after all checks)
        # (返回最终算出来能买多少股。)
        return size if size > 0 else 0


    # --- next 方法 ---
    def next(self):
        # (策略的核心逻辑，每个K线运行一次。)
        # 检查是否暂停交易
        # (Check if trading is halted)
        # (看看是不是因为风险太大暂停交易了。)
        if self.trading_halted:
            self.log("Trading halted due to risk event. Skipping current bar.") # 记录暂停日志 (打印一下，这根K线啥也不干。)
            return # 如果暂停，则跳过当前 bar (暂停了就直接结束这次运行。)

        # 遍历所有数据源
        # (Iterate over all data feeds)
        # (对我们关注的每个股票/ETF数据都处理一遍。)
        for data in self.datas:
            dname = data._name # 获取数据名称 (拿到这个数据的名字。)
            self.current_data_id = dname # 更新当前处理的数据ID，供 log_event 使用 (记下当前处理的是哪个数据，方便记日志。)

            # --- 记录市场状态评估 ---
            # (可以在这里加入评估逻辑并记录)
            # (Here you can add assessment logic and log it)
            # (可以在这加一些判断当前市场是涨是跌的代码，并把结果记到日志里。)
            # 示例：
            # market_state = 'TREND_UP' if self.ema_short[dname][0] > self.ema_long[dname][0] else 'TREND_DOWN'
            # if self.log_enabled:
            #     self.log_event(
            #         event_type=LOG_EVENT_TYPES["MARKET_STATE_ASSESSED"],
            #         data_feed=data,
            #         market_state=market_state,
            #         indicators={
            #             f"ema_short({self.p.ema_short_period})": self.ema_short[dname][0],
            #             f"ema_long({self.p.ema_long_period})": self.ema_long[dname][0],
            #         }
            #     )


            # 获取当前持仓信息
            # (Get current position information)
            # (看看现在有没有持有这个股票/ETF。)
            position = self.getposition(data)
            pos_size = position.size # 持仓量 (持有多少股。)

            # 检查最小交易间隔
            # (Check minimum trade interval)
            # (看看距离上次交易是不是过了足够长的时间。)
            if len(data) - self.last_trade_bar[dname] < self.p.min_trade_interval_bars:
                 # self.log(f'Skipping {dname}: Minimum trade interval not met.', data=data) # 暂时不打印间隔跳过信息
                 continue # 如果间隔不够，跳过当前数据 (时间不够就先不处理这个数据。)

            # --- 追踪止损逻辑 (如果持有多头仓位) ---
            if pos_size > 0 and self.p.trailing_stop_enabled:
                # (如果现在持有股票，并且开了追踪止损...)
                current_low = self.data_low[dname][0] # 当前K线最低价 (拿到这根K线的最低价。)
                potential_trailing_stop = current_low - self.p.trailing_stop_atr_multiplier * self.atr[dname][0] # 计算潜在追踪止损价 (根据当前最低价和ATR算一个新的追踪止损价。)

                if potential_trailing_stop > self.trailing_stop_price[dname]: # 如果新止损价比旧的高 (如果新算出来的价比之前的高...)
                    self.trailing_stop_price[dname] = potential_trailing_stop # 更新追踪止损价 (就更新追踪止损价。)
                    # self.log(f'Trailing Stop for {dname} updated to {self.trailing_stop_price[dname]:.2f}', data=data) # 暂时不打印更新信息

                # 检查是否触发追踪止损
                # Check if trailing stop is triggered
                if self.data_close[dname][0] < self.trailing_stop_price[dname]:
                    # (如果收盘价跌破了追踪止损价...)
                    self.log(f'Trailing Stop Triggered for {dname} at {self.data_close[dname][0]:.2f} (Stop: {self.trailing_stop_price[dname]:.2f}). Closing position.', data=data) # 记录触发日志 (打印一下触发了追踪止损。)
                     # --- 记录 SL/TP 触发事件 ---
                    if self.log_enabled:
                         self.log_event(
                            event_type=LOG_EVENT_TYPES["SL_TP_TRIGGERED"],
                            data_feed=data,
                            trade_cycle_id=self.current_trade_id or self.order_ref_to_trade_id_map.get(self.active_stop_loss_order[dname].ref if self.active_stop_loss_order.get(dname) else None, 'UNKNOWN'), # 尝试获取交易周期ID (尝试找到这个交易属于哪个周期。)
                            trigger_type='TRAILING_STOP_LOSS', # 类型：追踪止损 (说明是追踪止损触发的。)
                            current_price=self.data_close[dname][0], # 当前价格 (现在的价格是多少。)
                            trigger_level=self.trailing_stop_price[dname], # 触发水平 (追踪止损设在多少。)
                            position_size=pos_size, # 持仓大小 (当时持仓多少。)
                            # 关联可能存在的止损订单
                            # Associate the potential stop-loss order
                            related_order_ref=self.active_stop_loss_order[dname].ref if self.active_stop_loss_order.get(dname) else None # 关联的止损单号 (如果有关联的止损单，记下它的编号。)
                        )

                    self.close(data=data) # 平仓 (执行平仓操作。)
                    self.last_trade_bar[dname] = len(data) # 更新上次交易bar (记下这次交易的时间。)
                    continue # 处理下一个数据 (处理下一个股票/ETF。)



            # --- 入场信号逻辑 ---
            # (判断要不要买入。)
            if pos_size == 0: # 如果当前没有持仓 (如果现在手上没这个股票/ETF...)
                # 定义买入条件 (这里是例子，可以替换为你的策略逻辑)
                # Define buy conditions (example, replace with your strategy logic)
                # (设置买入的条件，比如短期均线上穿长期均线，并且RSI在50以上。)
                buy_condition = (self.ema_short[dname][0] > self.ema_medium[dname][0] and
                                 self.ema_medium[dname][0] > self.ema_long[dname][0] and
                                 self.rsi[dname][0] > 50)


                if buy_condition:
                    # (如果满足了买入条件...)
                    # --- 记录信号触发事件 ---
                    if self.log_enabled:
                        # (记录一条信号触发的日志。)
                        # 注意：此时 trade_cycle_id 尚未生成
                        # Note: trade_cycle_id is not yet generated at this point
                         signal_details = {
                             f"ema_short({self.p.ema_short_period})": self.ema_short[dname][0],
                             f"ema_medium({self.p.ema_medium_period})": self.ema_medium[dname][0],
                             f"ema_long({self.p.ema_long_period})": self.ema_long[dname][0],
                             f"rsi({self.p.rsi_period})": self.rsi[dname][0],
                         }
                         self.log_event(
                            event_type=LOG_EVENT_TYPES["SIGNAL_TRIGGERED"],
                            data_feed=data,
                            # trade_cycle_id 尚未生成 (trade_cycle_id not generated yet)
                            signal_type='BUY_CONDITION_MET', # 信号类型：满足买入条件 (说明是买入信号。)
                            triggering_data=signal_details # 触发数据 (是哪些指标满足条件触发的。)
                        )


                    # --- 生成交易周期 ID ---
                    # (在确认要开仓时生成ID)
                    # (Generate ID upon confirming to open a position)
                    # (在决定要买的时候，生成一个独一无二的交易周期ID。)
                    self.current_trade_id = str(uuid.uuid4().hex)
                    self.log(f'Attempting to BUY {dname} based on signal. Trade Cycle ID: {self.current_trade_id}', data=data)


                    # 计算入场价格、止损价格和止盈价格
                    # (Calculate entry price, stop loss price, and take profit price)
                    # (算算大概的买入价、止损价和止盈价。)
                    entry_price = self.data_close[dname][0] # 假设以收盘价入场 (假设按收盘价买。)
                    atr_value = self.atr[dname][0] # 获取ATR值 (拿到当前的ATR值。)
                    if atr_value <= 1e-9: # 防止ATR为0 (如果ATR是0或者太小...)
                        self.log(f"Warning: ATR value is near zero for {dname}. Cannot calculate SL/TP. Skipping trade.", data=data) # 打印警告 (就打印警告，算不了止损止盈，不买了。)
                         # --- 记录交易跳过事件 ---
                        if self.log_enabled:
                             self.log_event(
                                event_type=LOG_EVENT_TYPES["TRADE_SKIPPED"],
                                data_feed=data,
                                reason="ZERO_ATR_VALUE", # 原因：ATR值为零 (原因是ATR是0。)
                                details={"atr_period": self.p.atr_period}, # ATR周期 (计算ATR用的周期是多少。)
                                trade_cycle_id=self.current_trade_id # 关联交易周期ID (关联上交易周期ID。)
                            )

                        self.current_trade_id = None # 重置ID，因为交易被跳过 (交易没做成，把ID重置为空。)
                        continue # 跳过当前数据 (处理下一个数据。)

                    # 计算止损和止盈
                    # (Calculate stop loss and take profit)
                    # (用ATR计算止损价和止盈价。)
                    self.stop_loss_price[dname] = entry_price - self.p.stop_loss_atr_multiplier * atr_value # 止损价 (买入价减去几倍ATR。)
                    self.take_profit_price[dname] = entry_price + self.p.take_profit_atr_multiplier * atr_value # 止盈价 (买入价加上几倍ATR。)

                    # 计算仓位大小
                    # (Calculate position size)
                    # (算算这次买多少股。)
                    size_to_buy = self._calculate_trade_size(
                        data_close_price=self.data_close[dname][0],
                        entry_price=entry_price,
                        stop_loss_price=self.stop_loss_price[dname],
                        risk_per_trade_percent=self.p.risk_per_trade_percent,
                        data=data,
                        signal_type='BUY_CONDITION_MET' # 传递信号类型给计算函数 (把信号类型传给计算函数，方便记日志。)
                    )


                    if size_to_buy > 0:
                        # (如果算出来能买的数量大于0...)
                        self.log(f'Buy Signal for {dname}: Size={size_to_buy}, Entry={entry_price:.2f}, SL={self.stop_loss_price[dname]:.2f}, TP={self.take_profit_price[dname]:.2f}', data=data) # 记录买入信号日志 (在控制台打印买入信号信息。)

                        # --- 下单 ---
                        # 使用 bracket order 来同时设置止损和止盈
                        # Use bracket order to set stop loss and take profit simultaneously
                        # (用一个 ब्रैकेट订单（包含一个主订单和两个附加订单）来下单，这样买入、止损、止盈能一起设置好。)
                        buy_order_args = {'trade_cycle_id': self.current_trade_id} # 传递 trade_cycle_id 给订单信息 (把交易周期ID带上。)
                        stop_args = {'trade_cycle_id': self.current_trade_id}
                        limit_args = {'trade_cycle_id': self.current_trade_id}

                        orders = self.buy_bracket(
                            data=data,
                            size=size_to_buy, # 买入数量 (买多少股。)
                            price=entry_price, # 买入价格 (按什么价格买，这里用的是收盘价估算，实际会用市价或限价。)
                            exectype=bt.Order.Market, # 执行类型：市价单 (用市价单尽快成交。)
                            # 止损单设置
                            # Stop Loss order settings
                            stopprice=self.stop_loss_price[dname], # 止损触发价 (止损设在多少钱。)
                            stopexec=bt.Order.Stop, # 止损执行类型 (用止损单类型。)
                            stopargs=stop_args, # 止损单附加信息 (给止损单带上交易周期ID。)
                            # 止盈单设置
                            # Take Profit order settings
                            limitprice=self.take_profit_price[dname], # 止盈触发价 (止盈设在多少钱。)
                            limitexec=bt.Order.Limit, # 止盈执行类型 (用限价单类型。)
                            limitargs=limit_args, # 止盈单附加信息 (给止盈单带上交易周期ID。)
                            # 主订单附加信息
                            # Main order additional info
                            oargs=buy_order_args # 给主买单带上交易周期ID。
                        )

                        # --- 更新订单映射并记录提交事件 ---
                        if orders and self.log_enabled:
                            # (如果成功创建了订单组，并且日志功能开了...)
                             submitted_orders_info = [] # 存一下提交的订单信息 (创建一个列表存提交的订单信息。)
                             for order in orders:
                                 # (遍历订单组里的每个订单（主订单、止损单、止盈单）。)
                                if order: # 确保订单对象存在 (如果这个订单确实创建成功了...)
                                    self.order_ref_to_trade_id_map[order.ref] = self.current_trade_id # 记录订单引用和交易周期ID的映射 (把订单号和交易周期ID对应起来存好。)
                                    submitted_orders_info.append({
                                        "order_ref": order.ref, # 订单号 (订单的编号。)
                                        "order_type": order.ordtypename(), # 订单类型 (买单还是卖单。)
                                        "exec_type": order.getordername(), # 执行类型 (市价、限价、止损等。)
                                        "size": order.size, # 大小 (订单数量。)
                                        "price": order.price, # 价格 (订单价格。)
                                        "price_limit": order.pricelimit, # 限价 (止损限价单的限价。)
                                        "stop_price": order.created.price if order.exectype in [bt.Order.Stop, bt.Order.StopLimit] else None, # 止损触发价 (如果是止损单，触发价是多少。)
                                    })

                             # 记录订单提交事件 (只记录一次，包含所有子订单信息)
                             # Log order submitted event (log once, including all child order info)
                             # (记录一条订单提交的日志，把这组订单的信息都放进去。)
                             self.log_event(
                                event_type=LOG_EVENT_TYPES["ORDER_SUBMITTED"],
                                data_feed=data,
                                trade_cycle_id=self.current_trade_id, # 交易周期ID (这组订单属于哪个交易周期。)
                                order_ref=orders[0].ref if orders[0] else 'N/A', # 主订单引用号 (主订单的编号。)
                                order_details={ # 订单详情 (这组订单的具体信息。)
                                    "is_bracket": True, # 是不是Bracket订单 (标记这是一组Bracket订单。)
                                    "submitted_orders": submitted_orders_info, # 提交的订单列表 (包含主订单、止损单、止盈单的信息。)
                                    "calculated_size": size_to_buy, # 计算出的购买数量 (算出来要买多少股。)
                                    "entry_price_target": entry_price, # 目标入场价 (计划的买入价。)
                                    "stop_loss_target": self.stop_loss_price[dname], # 目标止损价 (计划的止损价。)
                                    "take_profit_target": self.take_profit_price[dname] # 目标止盈价 (计划的止盈价。)
                                }
                            )

                        # 存储活跃的止损和止盈订单引用 (如果订单成功创建)
                        # Store active stop loss and take profit order references (if orders were created successfully)
                        # (如果订单组创建成功了，把止损单和止盈单的引用存起来，方便后面管理。)
                        if orders:
                             self.active_stop_loss_order[dname] = orders[1] # 存储止损单 (存下止损单。)
                             self.active_take_profit_order[dname] = orders[2] # 存储止盈单 (存下止盈单。)

                        # 更新总风险
                        # (Update total risk)
                        # (更新一下当前的总风险。)
                        self.total_risk_percent += (size_to_buy * abs(entry_price - self.stop_loss_price[dname]) / self.broker.getvalue()) if self.broker.getvalue() > 0 else 0 # 累加风险 (把这笔交易的风险加到总风险里。)

                        self.last_trade_bar[dname] = len(data) # 更新上次交易bar (记下这次交易的时间。)
                        # 注意：current_trade_id 在交易关闭时才重置
                        # Note: current_trade_id is reset only when the trade is closed

                    else:
                        # 如果计算出的 size <= 0，重置 trade_cycle_id
                        # If calculated size <= 0, reset trade_cycle_id
                        # (如果算出来买不了（比如风险太大、钱不够），就把交易周期ID重置为空。)
                         self.log(f'Trade for {dname} skipped due to calculated size {size_to_buy}. Resetting trade cycle ID.', data=data)
                         self.current_trade_id = None # 重置ID (把ID设回空。)


            # --- 退出和部分退出逻辑 ---
            # (判断要不要卖出。)
            elif pos_size > 0: # 如果持有多头仓位 (如果现在正持有这个股票/ETF...)
                # 检查是否达到部分退出目标
                # (Check if partial exit target is reached)
                # (看看是不是涨到了部分退出的目标价位。)
                partial_exit_target = self.entry_price[dname] + self.p.partial_exit_target_multiplier * self.atr[dname][0] # 计算部分退出目标价 (算算部分退出的目标价。)
                if (self.p.enable_partial_exit and
                        not self.partial_exit_triggered[dname] and
                        self.data_high[dname][0] >= partial_exit_target):
                    # (如果启用了部分退出，并且还没触发过，并且当前最高价达到了目标价...)
                    partial_size = int(pos_size * self.p.partial_exit_percent) # 计算部分退出数量 (算算要卖掉多少股。)
                    if partial_size > 0:
                        # (如果要卖的数量大于0...)
                        self.log(f'Partial Exit Signal for {dname}: Size={partial_size}, Target Price={partial_exit_target:.2f}, Current High={self.data_high[dname][0]:.2f}', data=data) # 记录部分退出信号日志 (在控制台打印部分退出信号。)
                        # --- 记录部分退出信号 (技术上是订单计算/提交前兆) ---
                        if self.log_enabled:
                             self.log_event(
                                event_type="SIGNAL_TRIGGERED", # 事件类型：信号触发 (记为信号触发事件。)
                                data_feed=data,
                                trade_cycle_id=self.current_trade_id or self.order_ref_to_trade_id_map.get(order.ref if order else None, 'UNKNOWN'), # 尝试获取交易周期ID (尝试找到这个交易属于哪个周期。)
                                signal_type='PARTIAL_EXIT_TARGET_REACHED', # 信号类型：达到部分退出目标 (说明是达到了部分退出目标。)
                                triggering_data={ # 触发数据 (触发条件是啥。)
                                    "current_high": self.data_high[dname][0], # 当前最高价 (当前最高价。)
                                    "partial_exit_target": partial_exit_target, # 部分退出目标价 (目标价是多少。)
                                    "entry_price": self.entry_price[dname], # 入场价 (买入价是多少。)
                                    "atr_value": self.atr[dname][0], # ATR值 (当时的ATR值是多少。)
                                    "partial_exit_multiplier": self.p.partial_exit_target_multiplier # 部分退出乘数 (设置的部分退出ATR倍数。)
                                },
                                intended_action_details={ # 计划操作详情 (打算怎么操作。)
                                    "action": "SELL", # 操作：卖出 (打算卖出。)
                                    "size_to_sell": partial_size, # 卖出数量 (打算卖多少。)
                                    "position_before": pos_size # 操作前持仓 (卖之前持有多少。)
                                }
                            )

                        # 部分退出下单
                        # (Place partial exit order)
                        # (执行部分卖出。)
                        sell_order = self.sell(
                            data=data,
                            size=partial_size, # 卖出数量 (卖掉算出来的数量。)
                            exectype=bt.Order.Market # 执行类型：市价单 (用市价单。)
                        )
                        # --- 更新订单映射并记录提交 ---
                        if sell_order and self.log_enabled:
                            # (如果成功下单并且日志功能开了...)
                             self.order_ref_to_trade_id_map[sell_order.ref] = self.current_trade_id # 更新映射 (把这个卖单的编号和交易周期ID对应起来。)
                             self.log_event(
                                event_type=LOG_EVENT_TYPES["ORDER_SUBMITTED"],
                                data_feed=data,
                                trade_cycle_id=self.current_trade_id, # 交易周期ID (这个订单属于哪个交易周期。)
                                order_ref=sell_order.ref, # 订单引用号 (订单编号。)
                                order_details={ # 订单详情 (订单具体信息。)
                                    "is_bracket": False, # 不是Bracket订单 (标记这不是Bracket订单。)
                                    "is_partial_exit": True, # 是部分退出订单 (标记这是个部分退出订单。)
                                    "order_type": sell_order.ordtypename(), # 订单类型 (卖单。)
                                    "exec_type": sell_order.getordername(), # 执行类型 (市价单。)
                                    "size": sell_order.size, # 订单大小 (订单数量。)
                                    "price": sell_order.price, # 订单价格 (市价单价格是None。)
                                    "reason": "Partial exit target reached" # 原因：达到部分退出目标 (原因是达到了部分退出目标。)
                                }
                            )


                        self.partial_exit_triggered[dname] = True # 标记已部分退出 (记下已经部分退出了。)
                        self.last_trade_bar[dname] = len(data) # 更新上次交易bar (记下这次交易的时间。)

                        # 部分退出后，可以考虑调整止损到盈亏平衡点
                        # After partial exit, consider adjusting stop loss to break-even
                        # (部分卖出后，可以考虑把止损提到买入价，保证不亏钱。)
                        # if self.stop_loss_price[dname] < self.entry_price[dname]:
                        #     self.stop_loss_price[dname] = self.entry_price[dname]
                        #     # Cancel existing stop order and place a new one? Or modify?
                        #     # 取消现有止损单并重新下单？还是修改？
                        #     # (需要取消旧的止损单，下一个新的止损单。)
                        #     if self.active_stop_loss_order[dname]:
                        #         self.cancel(self.active_stop_loss_order[dname])
                        #         # Place new stop order at breakeven
                        #         # (下单新的止损单)
                        #         stop_order = self.sell(data=data, size=self.position_size[dname], price=self.stop_loss_price[dname], exectype=bt.Order.Stop)
                        #         self.active_stop_loss_order[dname] = stop_order
                        #         # --- 更新订单映射和日志 ---
                        #         if stop_order and self.log_enabled:
                        #             self.order_ref_to_trade_id_map[stop_order.ref] = self.current_trade_id
                        #             # Log the new stop order submission
                        #             # (记录新的止损单提交日志)
                        #     self.log(f'Stop loss for {dname} moved to breakeven ({self.entry_price[dname]:.2f}) after partial exit.', data=data)


            # 可以添加其他退出条件，例如基于指标的反转信号
            # Can add other exit conditions, e.g., reversal signals based on indicators


    # --- stop 方法 ---
    def stop(self):
        # (策略结束时调用的函数。)
        final_value = self.broker.getvalue() # 获取最终账户价值 (看看最后账户剩多少钱。)
        self.log(f'(Short Period: {self.p.ema_short_period}, Medium Period: {self.p.ema_medium_period}, Long Period: {self.p.ema_long_period}, BB Period: {self.p.bbands_period}, BB Dev: {self.p.bbands_dev}) Ending Value: {final_value:.2f}', dt=self.datas[0].datetime.date(0)) # 记录结束日志 (在控制台打印结束信息和最终账户价值。)

        # --- 记录策略结束事件 ---
        if self.log_enabled:
             # (记录一条策略结束的日志。)
             self.log_event(
                event_type=LOG_EVENT_TYPES["STRATEGY_STOP"],
                data_feed=self.data0, # 使用第一个数据作为参考 (用第一个数据的时间信息。)
                final_portfolio_value=final_value, # 最终组合价值 (最终账户总值。)
                final_cash=self.broker.getcash(), # 最终现金 (最后剩多少现金。)
                final_drawdown=self.current_drawdown, # 最终回撤 (最后的回撤是多少。)
                high_water_mark=self.high_water_mark, # 最高水位线 (账户最高到过多少钱。)
                total_bars_processed=len(self.data0) # 处理的总K线数 (总共处理了多少根K线。)
            )
             # 尝试停止日志记录器 (保险起见)
             # Try stopping the logger (just in case)
             # (以防万一，再调用一次停止日志。)
             stop_logging()


# --- 其他辅助函数保持不变 ---
# (保持 load_data_to_cerebro, analyze_optimization_results, print_optimization_summary, print_backtest_summary, get_backtest_config, setup_cerebro_and_broker, add_strategy_components, process_and_report_results 不变)
# ... (Keep other helper functions unchanged)
```

**总结与后续步骤：**

1.  **代码整合:** 将以上修改后的代码块整合到你的 `bt_g2.5t_strategy.py` 文件中，替换或补充原有代码。确保导入语句、类定义、方法定义都放置在正确的位置。
2.  **配置:**
    *   创建一个 YAML 配置文件（例如 `config.yaml`）或者直接在 `get_backtest_config` 函数中定义日志配置。
    *   确保 `run_backtest` 函数能正确加载和使用这些配置。示例配置：
        ```yaml
        strategy_name: 'MyAwesomeStrategy'
        logging:
          log_path: 'strategy_logs' # 日志文件存放目录
          log_filename_pattern: '{strategy_name}_{timestamp:%Y%m%d_%H%M%S}_run.jsonl' # 日志文件名格式
          log_level: 'INFO' # 日志级别 (DEBUG 会更详细)
          log_async_write: True # 启用异步写入
        # ... 其他策略和回测参数
        ```
3.  **测试:**
    *   运行你的回测脚本。
    *   检查日志文件是否在指定的 `log_path` 下生成，文件名是否符合 `log_filename_pattern`。
    *   检查日志文件内容是否为有效的 JSON Lines 格式（每行一个 JSON 对象）。
    *   验证关键事件（初始化、信号、计算、下单、状态更新、关闭、风险、跳过）是否被记录。
    *   **重点验证 `trade_cycle_id`**:
        *   是否在开仓前生成？
        *   是否正确关联到 `ORDER_CALCULATION`, `ORDER_SUBMITTED`, `ORDER_STATUS_UPDATE`, `SL_TP_TRIGGERED`, `TRADE_CLOSED` 事件？
        *   Bracket 订单的所有部分是否共享同一个 ID？
        *   `order_ref -> trade_cycle_id` 映射是否在 `notify_trade` 中被正确清理？
        *   孤儿订单/交易是否被正确标记？
    *   使用 Pandas 或其他工具尝试读取和分析日志文件，确保数据结构符合预期，便于后续分析。例如：
        ```python
        import pandas as pd
        import json

        log_file = 'path/to/your/strategy_log_....jsonl' # 替换为你的日志文件路径
        records = []
        with open(log_file, 'r', encoding='utf-8') as f:
            for line in f:
                try:
                    records.append(json.loads(line))
                except json.JSONDecodeError as e:
                    print(f"Error decoding JSON: {e} in line: {line.strip()}")

        df = pd.json_normalize(records, sep='_') # 使用下划线分隔嵌套字段
        print(df.head())
        print(df['event_type'].value_counts()) # 查看各种事件的数量

        # 示例：查找特定交易周期的所有事件
        # target_trade_id = '...' # 替换为你想查找的 trade_cycle_id
        # trade_cycle_df = df[df['trade_cycle_id'] == target_trade_id].sort_values('timestamp')
        # print(trade_cycle_df)
        ```
4.  **性能评估:** 对比开启/关闭日志以及同步/异步模式下的回测运行时间。
5.  **健壮性测试 (可选但推荐):** 模拟日志写入错误（例如，临时移除日志目录的写权限），检查策略是否继续运行，以及错误是否输出到 stderr。

这个实现覆盖了需求文档中的核心功能和关键点，特别是 `trade_cycle_id` 的管理。请仔细测试，特别是 ID 映射和清理逻辑，确保其在各种场景下的正确性。

---



---

