<!-- Generated by SpecStory -->

# BT日志系统开发需求实现 (2025-04-14 12:20:42)

_**User**_

@BT日志系统开发需求文档 v11.txt @analyzer.py
@feed.py
@cerebro.py
@observer.py
@analyzer.py
@strategy.py
@indicator.py 
@position.py 
@trade.py 
@order.py 
@signal.py 
请先仔细阅读<BT日志系统开发需求文档 v11.txt>中的开发需求,依据所提供backtrader库中的源码文件,以此为基础,在bt_g2.5t_strategy0414.py文件中,严格按照<<BT日志系统开发需求文档v11.txt>>的开发需求进行step by step 实现,在最小化修改bt_g2.5t_strategy0414.py文件中的代码的基础上实现开发需求文档中的内容. 特别要实现在各日志中必须有统一索引字段,要充分的考虑到是要将日志保存在csv文件中,用于使用pandas进行后续的量化交易质量的分析.用中文回复.

---

_**Assistant**_



---

好的，我们来一步步实现《BT日志系统开发需求文档 v11.txt》中定义的增强日志系统。

**核心目标:** 在 `bt_g2.5t_strategy0414.py` 文件中，以**最小化修改**现有代码为原则，集成一个结构化、可配置、支持异步写入的日志系统，特别是要实现 `trade_cycle_id` 来追踪完整的交易流程，并将日志保存为 JSON Lines 格式，方便后续使用 Pandas 进行分析。

**原文出处:** 《BT日志系统开发需求文档 v11.txt》

**详细解读与实例提供:**

该需求文档的核心是解决 Backtrader 内建日志系统的不足，提供更详细、结构化、易于分析的策略运行过程记录。

*   **痛点 (Pain Point):** 内建日志主要关注结果（订单成交、盈亏），难以深入了解策略的决策逻辑、中间状态和失败原因。 <font color='blue'>就像看病只看最后结果（治好了/没治好），却不知道中间医生是怎么诊断、用了什么药、为什么用这个药。</font>
*   **解决方案 (Solution):** 构建一个专门的日志系统。
    *   **结构化 (Structured):** 使用 JSON Lines (JSONL)，每条日志都是一个独立的 JSON 对象，机器友好。 <font color='blue'>好比给每条信息都贴上标准标签（姓名、年龄、事件），而不是混在一起写日记。</font>
    *   **强关联 (Strong Correlation):** 引入 `trade_cycle_id`，把从信号产生到交易结束的所有相关事件串联起来。 <font color='blue'>就像给一个包裹分配一个唯一的快递单号，从发货到签收，所有环节都能通过这个单号追踪。</font> (这是**核心和难点**)
    *   **全面捕获 (Comprehensive Capture):** 定义多种事件类型（初始化、信号触发、订单计算、提交、状态更新、风险事件、交易关闭、交易跳过等），记录关键信息。 <font color='blue'>如同详细记录开车过程：启动引擎、看到红灯、踩刹车、计算路线、打方向盘、到达目的地、油耗多少等等。</font>
    *   **高性能 (High Performance):** 采用异步写入，避免日志记录影响策略执行速度。 <font color='blue'>好比请个秘书专门负责记录，而不是司机一边开车一边手忙脚乱地写笔记，保证开车效率。</font>
    *   **可配置 (Configurable):** 日志路径、文件名格式等可以通过外部配置（虽然本次我们先硬编码，但设计上要考虑）。 <font color='blue'>像是提供设置选项，让用户决定日志文件存哪里、叫什么名字。</font>

**全面详细实例 (Conceptual):**

假设一个交易流程：

1.  **信号触发 (SIGNAL_TRIGGERED):** 策略发现金叉信号。
    *   *日志内容可能包含:* `timestamp`, `event_type: SIGNAL_TRIGGERED`, `strategy_id`, `data_id`, `trade_cycle_id` (新生成), `signal_type: GoldenCross`, `triggering_data: {close: 10.5, short_ma: 10.2, long_ma: 10.1}`
2.  **订单计算 (ORDER_CALCULATION):** 根据风险规则计算仓位。
    *   *日志内容可能包含:* `timestamp`, `event_type: ORDER_CALCULATION`, `strategy_id`, `data_id`, `trade_cycle_id` (沿用), `signal_type: GoldenCross`, `entry_price_approx: 10.5`, `stop_loss_calc: 10.0`, `size_raw: 100`, `size_final: 100`, `risk_inputs: {...}`
3.  **订单提交 (ORDER_SUBMITTED):** 发出买入指令。
    *   *日志内容可能包含:* `timestamp`, `event_type: ORDER_SUBMITTED`, `strategy_id`, `data_id`, `trade_cycle_id` (沿用), `order_ref` (Backtrader 生成), `order_details: {type: Market, size: 100, ...}`
    *   **关联:** 此时记录 `order.ref` 和 `trade_cycle_id` 的映射关系。
4.  **订单状态更新 (ORDER_STATUS_UPDATE):** 订单被接受。
    *   *日志内容可能包含:* `timestamp`, `event_type: ORDER_STATUS_UPDATE`, `strategy_id`, `data_id`, `trade_cycle_id` (通过 `order.ref` 查找到), `order_ref`, `status: Accepted`
5.  **订单状态更新 (ORDER_STATUS_UPDATE):** 订单完全成交。
    *   *日志内容可能包含:* `timestamp`, `event_type: ORDER_STATUS_UPDATE`, `strategy_id`, `data_id`, `trade_cycle_id` (通过 `order.ref` 查找到), `order_ref`, `status: Completed`, `exec_details: {price: 10.55, size: 100, ...}`
6.  **交易关闭 (TRADE_CLOSED):** 后续卖出订单完成，交易周期结束。
    *   *日志内容可能包含:* `timestamp`, `event_type: TRADE_CLOSED`, `strategy_id`, `data_id`, `trade_cycle_id` (通过卖出订单的 `order.ref` 查找到), `pnl: 50.0`, `pnlcomm: 45.0`, `duration_bars: 10`, ...
    *   **清理:** 从映射关系中移除与此交易相关的所有 `order.ref`。

**实现步骤:**

我们将按照以下步骤，逐步在 `bt_g2.5t_strategy0414.py` 中添加代码：

一、 **导入所需模块**
二、 **设置日志记录器 (Logger Setup)**
三、 **实现核心日志记录方法 `log_event`**
四、 **管理 `trade_cycle_id` 及订单映射**
五、 **在策略生命周期中嵌入日志记录点**
六、 **确保日志系统停止**

---

**开始实施:**

我将修改 `bt_g2.5t_strategy0414.py` 文件来实现这些功能。

**一、 导入所需模块**

在文件开头添加必要的库导入。

```python
# ================= 日志系统所需导入 START =================
import logging
import logging.handlers
import json
import datetime
import uuid
import os
import threading
import queue
import pytz  # 用于处理时区
# ================= 日志系统所需导入 END ===================
```

**二、 设置日志记录器 (Logger Setup) & 三、 实现核心日志记录方法 `log_event`**

我们将创建一个自定义的 Formatter 类用于输出 JSON，并设置异步日志处理。然后将日志设置和 `log_event` 方法添加到 `AShareETFStrategy` 类中。

```python
# ================= 自定义 JSON Formatter START =================
class JsonFormatter(logging.Formatter):
    # 定义一个名为 JsonFormatter 的类，继承自 logging.Formatter，用于将日志记录格式化为 JSON 字符串。 (创建一个日志格式化工具，专门把日志信息变成 JSON 格式。)
    def format(self, record):
        # 定义 format 方法，负责将单个日志记录（record）转换为字符串。 (定义如何转换一条日志记录。)
        log_entry = {}
        # 创建一个空字典，用于存放最终的日志条目。 (准备一个空的盒子，放日志信息。)
        if isinstance(record.msg, dict):
            # 检查日志消息主体（record.msg）是否已经是字典格式。 (看看传进来的日志信息是不是已经是整理好的盒子了。)
            log_entry.update(record.msg)
            # 如果是字典，直接将其内容更新到 log_entry 中。 (如果是，直接把里面的东西倒进我们的最终盒子。)
        else:
            # 如果不是字典，将其作为 'message' 字段的值。 (如果不是，就把这条原始信息当作一个叫 'message' 的标签放进盒子里。)
            log_entry['message'] = record.getMessage()

        # 添加一些标准的日志记录信息，如果它们不在消息主体中。 (补充一些标准信息，比如时间、日志级别等，如果最终盒子里还没有的话。)
        if 'timestamp' not in log_entry:
            # 如果 'timestamp' 不在，添加 ISO 8601 格式的 UTC 时间戳。 (如果没记时间，就记下现在的 UTC 标准时间。)
            log_entry['timestamp'] = datetime.datetime.now(pytz.utc).isoformat() + 'Z'
        if 'level' not in log_entry:
            # 如果 'level' 不在，添加日志级别名称（例如 'INFO', 'ERROR'）。 (如果没记重要程度，就记一下。)
            log_entry['level'] = record.levelname
        if hasattr(record, 'strategy_id') and 'strategy_id' not in log_entry:
             # 如果记录对象有 strategy_id 属性且最终日志条目没有，添加它。 (如果记录里有策略 ID 但最终盒子里没有，加上。)
            log_entry['strategy_id'] = record.strategy_id
        if hasattr(record, 'data_id') and 'data_id' not in log_entry:
            # 如果记录对象有 data_id 属性且最终日志条目没有，添加它。 (如果记录里有数据 ID 但最终盒子里没有，加上。)
            log_entry['data_id'] = record.data_id

        # 处理日志记录中的异常信息。 (如果记录中有错误信息，也加到盒子里。)
        if record.exc_info:
            # 如果存在异常信息。
            if not record.exc_text:
                # 如果异常文本不存在，则格式化异常信息。
                record.exc_text = self.formatException(record.exc_info)
        if record.exc_text:
            # 如果异常文本存在，将其添加到日志条目中。
            log_entry['exception'] = record.exc_text
        if record.stack_info:
             # 如果存在堆栈信息，格式化并添加到日志条目中。
            log_entry['stack_trace'] = self.formatStack(record.stack_info)

        # 将字典转换为 JSON 字符串，确保使用 ASCII 编码并按键排序。 (把整理好的盒子里的所有东西变成一行 JSON 文本。)
        return json.dumps(log_entry, sort_keys=True, ensure_ascii=False)

# ================= 自定义 JSON Formatter END ===================

# ================== 日志队列处理线程 START ==================
# (这个部分是异步写入日志的核心，确保日志写入不阻塞策略运行)
log_queue = queue.Queue(-1)  # 使用无限大小的队列 (创建一个队列，用来临时存放日志)
log_listener = None # 初始化日志监听器变量 (准备一个监听器，后面会用到)

def setup_log_listener(handler):
    # 定义一个函数来设置和启动日志监听器。 (定义一个启动监听器的函数。)
    global log_listener
    # 声明 log_listener 是全局变量。 (告诉程序我们要用全局的那个监听器。)
    log_listener = logging.handlers.QueueListener(log_queue, handler, respect_handler_level=True)
    # 创建 QueueListener 实例，连接队列和处理器。 (创建监听器，让它看着队列，并告诉它日志要交给哪个处理器处理。)
    log_listener.start()
    # 启动监听器线程。 (让监听器开始工作。)

def stop_log_listener():
    # 定义一个函数来停止日志监听器。 (定义一个停止监听器的函数。)
    global log_listener
    # 声明 log_listener 是全局变量。 (告诉程序我们要用全局的那个监听器。)
    if log_listener:
        # 如果监听器存在。 (如果监听器在工作。)
        log_listener.stop()
        # 停止监听器线程。 (让监听器停止工作。)
# ================== 日志队列处理线程 END ==================


# ... （原有的 imports 和其他代码）

class AShareETFStrategy(bt.Strategy):
    # 定义一个名为AShareETFStrategy的类，它继承自bt.Strategy，表示这是一个Backtrader交易策略类。 (创建一个叫做AShareETFStrategy的策略类，它继承了bt.Strategy，说明这是个交易策略。)
    params = (
        # ... (原有的参数)
        # ================= 日志系统参数 START =================
        ('log_path', 'logs'), # 日志文件存放目录 (日志文件放哪里)
        ('log_filename_pattern', '{strategy_name}_{data_name}_{timestamp:%Y%m%d_%H%M%S}.log.jsonl'), # 日志文件名格式模板 (日志文件叫什么名字的规则)
        ('log_level', logging.INFO), # 日志记录级别 (记录多详细的信息，INFO级别比较常用)
        # ================= 日志系统参数 END ===================
    )

    # ... (原有的 __init__ 之前的方法，如 _calculate_trade_size)

    # ==================== 日志系统核心方法 START ====================
    def _setup_logger(self):
        # 定义一个私有方法 _setup_logger，用于配置和初始化日志记录器。 (定义一个内部工具，用来设置好日志系统。)
        """Sets up the logging system for the strategy."""
        # """为策略设置日志系统。"""
        self.strategy_id = f"{self.__class__.__name__}_{uuid.uuid4().hex[:8]}"
        # 为当前策略实例生成一个唯一的标识符。 (给这个策略起个独一无二的名字，加一串随机码防重复。)
        self.logger = logging.getLogger(self.strategy_id)
        # 获取一个特定于此策略实例的日志记录器。 (拿到这个策略专属的记事本。)
        self.logger.setLevel(self.p.log_level)
        # 设置日志记录器的级别。 (设定这个记事本记录信息的详细程度。)

        # 防止重复添加处理器，特别是在优化运行时。 (避免重复设置记事本的写入方式。)
        if self.logger.hasHandlers():
            # 如果记录器已经有关联的处理器。
            # In optimization, __init__ might be called multiple times for the same logger name.
            # 清理旧的处理器，以防万一。
            # (在优化模式下，同一个策略名可能会初始化多次，先把旧的设置清理掉。)
            # for h in self.logger.handlers[:]:
            #     self.logger.removeHandler(h)
            # 通常不需要清理，因为 getLogger 会返回同一个实例。主要问题是重复添加。
            # (通常不需要清理，因为getLogger会返回同一个记事本实例，主要是避免重复添加写入方式。)
            # 如果已经有 QueueHandler，则假设已经设置好了
            # (If a QueueHandler already exists, assume setup is done)
            if any(isinstance(h, logging.handlers.QueueHandler) for h in self.logger.handlers):
                 # 检查是否已有队列处理器。 (检查是否已经设置了异步写入方式。)
                 # print(f"Logger {self.strategy_id} already has QueueHandler. Skipping setup.") # 用于调试 (打印调试信息)
                 return # 如果有，则跳过后续设置。 (如果已经有了，就不用再设了。)


        # --- 文件处理器和格式化器 ---
        log_dir = self.p.log_path
        # 获取日志目录路径。 (拿到日志文件夹的名字。)
        os.makedirs(log_dir, exist_ok=True)
        # 创建日志目录，如果目录已存在则忽略。 (确保这个文件夹存在，没有就创建一个。)

        # 构建日志文件名 (Construct the log filename)
        now_str = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
        # 获取当前时间字符串。 (拿到现在的时间，格式化成年月日_时分秒。)
        data_name_part = "multi_data" if len(self.datas) > 1 else self.datas[0]._name if self.datas else "no_data"
        # 根据数据源数量确定文件名中的数据部分。 (看看有几个数据源，如果多于一个就叫 multi_data，只有一个就用它的名字，没有就叫 no_data。)
        log_filename = self.p.log_filename_pattern.format(
            strategy_name=self.__class__.__name__,
            data_name=data_name_part,
            timestamp=datetime.datetime.now() # 使用当前时间对象进行格式化 (用当前时间格式化文件名模板。)
            # pid=os.getpid() # 可选：添加进程ID (Optional: Add process ID)
        )
        # 格式化日志文件名模板。 (按照规则拼出完整的日志文件名。)
        log_filepath = os.path.join(log_dir, log_filename)
        # 拼接日志目录和文件名得到完整路径。 (把文件夹名和文件名组合成完整路径。)

        # --- 异步日志处理设置 ---
        # (Async logging setup)
        json_formatter = JsonFormatter()
        # 创建自定义的 JSON 格式化器实例。 (创建我们前面定义的 JSON 格式化工具。)

        # 文件处理器 - 这是最终写入文件的处理器
        # (File handler - this is the handler that writes to the file)
        file_handler = logging.FileHandler(log_filepath, encoding='utf-8')
        # 创建一个文件处理器，指定文件路径和编码。 (创建一个写入文件的工具，告诉它写到哪个文件，用什么编码。)
        file_handler.setFormatter(json_formatter)
        # 为文件处理器设置 JSON 格式化器。 (告诉这个写入工具，要用 JSON 格式写。)

        # 队列处理器 - 将日志发送到队列
        # (Queue handler - sends logs to the queue)
        queue_handler = logging.handlers.QueueHandler(log_queue)
        # 创建一个队列处理器，将日志记录放入全局队列 log_queue。 (创建一个队列处理器，它负责把日志先扔到队列里。)

        # 将队列处理器添加到策略的 logger
        # (Add the queue handler to the strategy's logger)
        self.logger.addHandler(queue_handler)
        # 将队列处理器添加到策略的日志记录器中。 (把这个“扔队列”的工具装到策略的记事本上。)

        # 设置并启动监听器（如果尚未启动）
        # (Setup and start the listener (if not already started))
        global log_listener
        # 声明 log_listener 是全局变量。 (告诉程序我们要用全局的那个监听器。)
        if log_listener is None or not log_listener.is_alive(): # 检查监听器是否已启动 (Check if listener is already running)
            # print(f"Setting up log listener for handler: {file_handler}") # 用于调试 (打印调试信息)
            setup_log_listener(file_handler) # 启动监听器，将文件处理器传给它 (Start the listener, passing the file handler to it)
            # print(f"Log listener started.") # 用于调试 (打印调试信息)
        # else:
            # print(f"Log listener already running.") # 用于调试 (打印调试信息)

        # 记录日志系统初始化完成
        # (Log that the logging system initialization is complete)
        self.log_event('LOGGER_INITIALIZED', details={'log_filepath': log_filepath})
        # 调用 log_event 记录一条初始化完成的日志。 (写一条日志，说日志系统已经准备好了。)


    def log_event(self, event_type, data_feed=None, **kwargs):
        # 定义 log_event 方法，用于记录结构化的日志事件。 (定义一个专门用来记录各种事件的工具。)
        """Logs a structured event."""
        # """记录一个结构化事件。"""
        try:
            # 尝试执行日志记录逻辑。 (试试看能不能记日志。)
            log_entry = {
                # 'timestamp': datetime.datetime.now(pytz.utc).isoformat() + 'Z', # 使用 UTC 时间 (Use UTC time)
                 'timestamp': self.datas[0].datetime.datetime(0).isoformat() if self.datas and len(self.datas[0]) else datetime.datetime.now(pytz.utc).isoformat() + 'Z', # 优先使用回测时间 (Prefer backtest time)
                'event_type': event_type, # 事件类型 (Event type)
                'strategy_id': getattr(self, 'strategy_id', 'unknown'), # 策略实例 ID (Strategy instance ID)
                'data_id': data_feed._name if data_feed else getattr(self.data, '_name', 'default_data'), # 数据源名称 (Data feed name)
            }
            # 创建基础日志条目字典，包含标准字段。 (创建一个日志的基本信息盒子，放上时间、事件类型、策略ID、数据ID。)

            # 尝试添加交易周期ID (Try to add trade cycle ID)
            if hasattr(self, 'current_trade_id') and self.current_trade_id:
                # 如果当前策略实例有 'current_trade_id' 属性且不为空。 (如果现在有一个正在进行的交易追踪号。)
                log_entry['trade_cycle_id'] = self.current_trade_id
                # 将其添加到日志条目中。 (把这个追踪号也放进盒子。)
            elif 'order_ref' in kwargs and hasattr(self, 'order_ref_to_trade_id_map'):
                 # 如果没有进行中的追踪号，但事件信息里有订单引用号 (order_ref)，并且策略有订单引用号到交易ID的映射表。 (如果没有进行中的追踪号，但是这次事件跟某个订单有关，并且我们有订单号到追踪号的对应表。)
                 trade_id = self.order_ref_to_trade_id_map.get(kwargs['order_ref'], None)
                 # 尝试从映射表中查找对应的交易周期ID。 (去对应表里查查这个订单号对应的追踪号。)
                 if trade_id:
                     # 如果找到了。 (如果查到了。)
                     log_entry['trade_cycle_id'] = trade_id
                     # 将找到的交易周期ID添加到日志条目中。 (把找到的追踪号放进盒子。)
                 # else:
                 #     log_entry['trade_cycle_id'] = 'ORPHANED_ORDER_EVENT' # 可选：标记孤儿订单事件 (Optional: Mark orphan order event)

            # 合并额外的关键字参数 (Merge additional keyword arguments)
            log_entry.update(kwargs)
            # 将调用时传入的其他信息（kwargs）也添加到日志条目中。 (把调用这个记录工具时附带的其他信息也放进盒子。)

            # 使用附加信息调用 logger，以便 formatter 可以访问它们
            # (Call logger with extra info so formatter can access them)
            # self.logger.info(log_entry, extra={'strategy_id': log_entry['strategy_id'], 'data_id': log_entry.get('data_id')})
            # 直接传递完整的字典给 info，让 JsonFormatter 处理
            # (Pass the complete dictionary directly to info, let JsonFormatter handle it)
            self.logger.info(log_entry)
            # 调用日志记录器的 info 方法记录日志。 (用记事本的“记录”功能把这个盒子里的信息记下来。)

        except Exception as e:
            # 如果在记录日志时发生任何错误。 (如果在记日志的时候出错了。)
            # Ensure logging errors don't crash the strategy
            # 确保日志错误不会导致策略崩溃
            import sys
            # 导入 sys 模块以访问标准错误流。 (导入 sys 工具包，用来往控制台打错误信息。)
            print(f"CRITICAL: Logging failed! Event: {event_type}, Error: {e}", file=sys.stderr)
            # 在标准错误流中打印错误信息。 (在控制台打印严重的错误信息，说明记日志失败了。)
            # Optionally, log to a fallback logger or handle differently
            # 可选地，记录到备用日志记录器或以其他方式处理

    # ==================== 日志系统核心方法 END ======================


    # ... （其他方法）

    def log(self, txt, dt=None, data=None):
        # 定义 log 方法，用于简单的文本日志记录（保留原有方法，但建议使用 log_event）。 (定义一个简单的文本记录方法，兼容旧代码，但推荐用新的 log_event。)
        ''' Logging function for this strategy'''
        # '''此策略的日志记录功能'''
        # 使用 log_event 记录简单消息
        # (Log simple messages using log_event)
        log_dt = dt or self.datas[0].datetime.date(0)
        # 获取日志时间戳，优先使用传入的 dt，否则使用第一个数据源的当前日期。 (拿到日志时间，有传入的就用，没有就用第一个数据的日期。)
        # print('%s, %s' % (log_dt.isoformat(), txt)) # 旧的打印方式 (Old print method)
        self.log_event('LEGACY_LOG', message=txt, log_timestamp=log_dt.isoformat())
        # 调用 log_event 记录，事件类型为 'LEGACY_LOG'。 (用新的 log_event 来记录，类型标记为旧日志。)


    def __init__(self, **kwargs):  # 接受 **kwargs 以兼容 addstrategy 传递的参数 (Accept **kwargs to be compatible with parameters passed by addstrategy)
        # 定义策略的初始化函数__init__，在策略对象创建时自动执行。 (定义策略初始化要做的事情。)
        # (Define the initialization function __init__, executed automatically when the strategy object is created.)

        # --- 初始化日志系统 ---
        # (Initialize logging system)
        self._setup_logger() # 调用内部方法设置日志记录器 (Call internal method to set up the logger)
        self.log_event('STRATEGY_INIT_START') # 记录初始化开始 (Log initialization start)


        # --- 初始化交易周期 ID 管理 ---
        # (Initialize trade cycle ID management)
        self.order_ref_to_trade_id_map = {} # 订单引用到交易周期ID的映射 (Mapping from order reference to trade cycle ID)
        self.current_trade_id = None # 当前活跃的交易周期ID (Currently active trade cycle ID)


        # 引用数据源。 (Reference the data feeds.)
        # Keep a reference to the "close" line in the data[0] dataseries
        # self.dataclose = self.datas[0].close # 原有代码 (Original code)
        # 引用所有数据源的收盘价、开盘价、最高价、最低价 (Reference close, open, high, low prices for all data feeds)
        self.d_close = {d._name: d.close for d in self.datas}
        # 创建一个字典，存储每个数据源名称到其收盘价序列的映射。 (创建一个字典，记录每个数据源名字和它的收盘价数据。)
        self.d_open = {d._name: d.open for d in self.datas}
        # 创建一个字典，存储每个数据源名称到其开盘价序列的映射。 (创建一个字典，记录每个数据源名字和它的开盘价数据。)
        self.d_high = {d._name: d.high for d in self.datas}
        # 创建一个字典，存储每个数据源名称到其最高价序列的映射。 (创建一个字典，记录每个数据源名字和它的最高价数据。)
        self.d_low = {d._name: d.low for d in self.datas}
        # 创建一个字典，存储每个数据源名称到其最低价序列的映射。 (创建一个字典，记录每个数据源名字和它的最低价数据。)

        # 引用主要数据源（第一个）以便快速访问，如果存在的话
        # (Reference the primary data feed (the first one) for quick access if it exists)
        self.data = self.datas[0] if self.datas else None
        # 将第一个数据源赋值给 self.data，如果数据源列表不为空。 (如果至少有一个数据源，把第一个存到 self.data 方便使用。)
        self.dataclose = self.data.close if self.data else None # 保持原有 self.dataclose 的兼容性 (Maintain compatibility with original self.dataclose)
        # 如果 self.data 存在，将其收盘价序列赋值给 self.dataclose，保持旧代码兼容性。 (如果 self.data 有东西，把它的收盘价存到 self.dataclose，兼容旧代码。)


        # To keep track of pending orders and buy price/commission
        # 跟踪待处理订单和买入价格/佣金 (To keep track of pending orders and buy price/commission)
        self.order = None
        # 初始化 self.order 为 None，用于跟踪最近的待处理订单。 (初始化一个变量 self.order，用来记住最近还没完成的订单。)
        self.buyprice = None
        # 初始化 self.buyprice 为 None，用于记录买入价格。 (初始化一个变量 self.buyprice，用来记买入价。)
        self.buycomm = None
        # 初始化 self.buycomm 为 None，用于记录买入佣金。 (初始化一个变量 self.buycomm，用来记买入佣金。)

        # 实例化指标 (Instantiate Indicators)
        # self.sma_short = bt.indicators.SimpleMovingAverage(self.datas[0], period=self.params.ema_short_period) # 原有代码 (Original code)
        # self.sma_medium = bt.indicators.SimpleMovingAverage(self.datas[0], period=self.params.ema_medium_period) # 原有代码 (Original code)
        # self.sma_long = bt.indicators.SimpleMovingAverage(self.datas[0], period=self.params.ema_long_period) # 原有代码 (Original code)
        # self.bbands = bt.indicators.BollingerBands(self.datas[0], period=self.params.bbands_period, devfactor=self.params.bbands_devfactor) # 原有代码 (Original code)

        # 为每个数据源创建指标实例 (Create indicator instances for each data feed)
        self.inds = {}
        # 初始化一个空字典 self.inds，用于存储每个数据源的指标。 (准备一个空盒子 self.inds，用来放每个数据源对应的指标工具。)
        for d in self.datas:
            # 遍历所有数据源。 (检查每一个数据源。)
            self.inds[d._name] = {} # 为每个数据源创建一个内部字典 (Create an inner dictionary for each data feed)
            # 在 self.inds 中为当前数据源 d 创建一个专属的小盒子。 (给当前数据源 d 在 self.inds 里创建一个专属小盒子。)

            # 使用 self.p 访问参数 (Access parameters using self.p)
            self.inds[d._name]['ema_short'] = bt.indicators.ExponentialMovingAverage(d, period=self.p.ema_short_period)
            # 创建短期 EMA 指标实例，并存入对应数据源的小盒子。 (创建短期 EMA 指标，放到对应数据源的小盒子里。)
            self.inds[d._name]['ema_medium'] = bt.indicators.ExponentialMovingAverage(d, period=self.p.ema_medium_period)
            # 创建中期 EMA 指标实例，并存入对应数据源的小盒子。 (创建中期 EMA 指标，放到对应数据源的小盒子里。)
            self.inds[d._name]['ema_long'] = bt.indicators.ExponentialMovingAverage(d, period=self.p.ema_long_period)
            # 创建长期 EMA 指标实例，并存入对应数据源的小盒子。 (创建长期 EMA 指标，放到对应数据源的小盒子里。)
            self.inds[d._name]['bbands'] = bt.indicators.BollingerBands(d, period=self.p.bbands_period, devfactor=self.p.bbands_devfactor)
            # 创建布林带指标实例，并存入对应数据源的小盒子。 (创建布林带指标，放到对应数据源的小盒子里。)
            self.inds[d._name]['atr'] = bt.indicators.AverageTrueRange(d, period=self.p.atr_period)
            # 创建 ATR 指标实例，并存入对应数据源的小盒子。 (创建 ATR 指标，放到对应数据源的小盒子里。)

        # 风险管理相关变量 (Risk management related variables)
        self.halt_trading_until = None # 暂停交易直到指定时间戳 (Halt trading until specified timestamp)
        # 初始化 self.halt_trading_until 为 None，标记当前是否处于暂停交易状态。 (初始化一个标记，表示现在没暂停交易。)
        self.cumulative_risk_units = 0.0 # 累积风险单位 (Cumulative risk units)
        # 初始化 self.cumulative_risk_units 为 0.0，记录当前累积的总风险。 (初始化一个计数器，记录总共承担了多少风险。)
        self.open_trades = 0 # 当前持仓交易数量 (Number of currently open trades)
        # 初始化 self.open_trades 为 0，记录当前有多少笔交易还在进行中。 (初始化一个计数器，记录当前有几单在手。)
        self.initial_portfolio_value = self.broker.getvalue() # 记录初始投资组合价值 (Record initial portfolio value)
        # 记录策略开始时的总资产。 (记一下开始时有多少钱。)
        self.high_water_mark = self.initial_portfolio_value # 记录最高水位线 (Record high water mark)
        # 初始化最高水位线为初始总资产。 (记一下历史最高赚到过多少钱，初始就是本金。)

        # 使用 kwargs 更新参数，如果它们在 params 中定义了
        # (Update parameters using kwargs if they are defined in params)
        for key, value in kwargs.items():
            # 遍历从 addstrategy 传入的参数。 (检查通过 addstrategy 传进来的每个参数。)
            if hasattr(self.params, key):
                # 如果这个参数是策略本身定义的参数之一。 (如果这个参数是咱们策略认识的。)
                setattr(self.params, key, value)
                # 更新策略参数的值。 (那就更新一下这个参数的值。)
                self.log_event('PARAM_OVERRIDE', param_key=key, param_value=value)
                # 记录参数被覆盖的事件。 (记一笔日志，说这个参数被传进来的值覆盖了。)
            # else:
                # self.log_event('UNKNOWN_PARAM_PASSED', param_key=key, param_value=value) # 可选：记录未知参数 (Optional: log unknown parameters)

        # 记录策略初始化完成和参数
        # (Log strategy initialization completion and parameters)
        param_dict = {p: getattr(self.params, p) for p in dir(self.params) if not p.startswith('_')}
        # 获取所有策略参数及其值。 (把策略的所有参数和它们的值整理到一个字典里。)
        data_ids = [d._name for d in self.datas]
        # 获取所有数据源的名称列表。 (拿到所有数据源的名字。)
        self.log_event('STRATEGY_INIT_COMPLETE', params=param_dict, data_ids=data_ids)
        # 记录策略初始化完成事件，包含参数和数据源信息。 (记录一条日志，说策略初始化完成了，并附上所有参数和数据源名字。)

    # ... （其他方法）
```

**四、 管理 `trade_cycle_id` 及订单映射**

这部分逻辑主要在 `__init__`, `next`, `notify_order`, `notify_trade` 中实现。上面 `__init__` 已包含初始化部分。现在修改其他方法。

```python
# ... (在 AShareETFStrategy 类中)

    def notify_order(self, order):
        # 定义订单状态通知函数notify_order，当订单状态发生变化时被调用，参数order是订单对象。 (定义订单通知函数，当订单状态变化的时候，程序会跑这个函数来通知你。)
        # (Define the order notification function notify_order, called when order status changes, parameter order is the order object.)

        # --- 日志记录：订单状态更新 ---
        # (Logging: Order Status Update)
        trade_id = self.order_ref_to_trade_id_map.get(order.ref, 'ORPHANED_ORDER') # 尝试获取交易周期ID (Try to get trade cycle ID)
        # 查找这个订单对应的交易追踪号，找不到就标记为“孤儿订单”。 (查一下这个订单是哪个交易的，查不到就标为“孤儿”。)
        exec_details = {}
        # 初始化一个空字典，用于存放订单执行详情。 (准备一个空盒子，放订单执行细节。)
        if order.executed.price:
            # 如果订单有执行价格。 (如果订单成交了。)
            exec_details['price'] = order.executed.price
            # 记录执行价格。 (记下成交价。)
            exec_details['value'] = order.executed.value
            # 记录执行价值。 (记下成交金额。)
            exec_details['commission'] = order.executed.comm
            # 记录执行佣金。 (记下佣金。)
            exec_details['size'] = order.executed.size # 已执行数量 (Executed size)
            # 记录已执行数量。 (记下成交了多少。)
        self.log_event('ORDER_STATUS_UPDATE',
                       data_feed=order.data, # 关联数据源 (Associate data feed)
                       order_ref=order.ref, # 订单引用 (Order reference)
                       trade_cycle_id=trade_id, # 使用查找到的交易ID (Use the retrieved trade ID)
                       status=order.getstatusname(), # 订单状态名称 (Order status name)
                       exec_details=exec_details if exec_details else None, # 执行详情（如果存在） (Execution details (if any))
                       remaining_size=order.executed.remsize, # 剩余未执行数量 (Remaining size)
                       order_type=order.ordtypename(), # 订单类型 (Order type)
                       order_details={ # 订单创建时的细节 (Details from order creation)
                           'created_price': order.created.price, # 创建时价格 (Creation price)
                           'created_size': order.created.size, # 创建时大小 (Creation size)
                           'isbuy': order.isbuy(), # 是否是买单 (Is it a buy order?)
                           'issell': order.issell() # 是否是卖单 (Is it a sell order?)
                       })
        # 记录订单状态更新事件，包含各种详细信息。 (记录订单状态变化的日志，包括追踪号、状态、成交细节等。)


        if order.status in [order.Submitted, order.Accepted]:
            # Buy/Sell order submitted/accepted to/by broker - Nothing to do
            # 如果订单是已提交或已接受状态，无需操作。 (如果订单只是刚提交或者被接受了，暂时不用做什么。)
            # self.log(f'Order {order.ref} Submitted/Accepted', data=order.data) # 旧日志 (Old log)
            return

        # Check if an order has been completed
        # 检查订单是否已完成 (Check if an order has been completed)
        # Attention: broker could reject order if not enough cash
        # 注意：如果现金不足，经纪商可能会拒绝订单 (Attention: broker could reject order if not enough cash)
        if order.status in [order.Completed]:
            # 如果订单状态是已完成。 (如果订单完成了。)
            if order.isbuy():
                # 如果是买单。 (如果是买单。)
                # self.log(
                #     f'BUY EXECUTED, Price: {order.executed.price:.2f}, Cost: {order.executed.value:.2f}, Comm {order.executed.comm:.2f}',
                #     data=order.data
                # ) # 旧日志 (Old log)
                self.buyprice = order.executed.price
                # 记录买入价格。 (记下买入价。)
                self.buycomm = order.executed.comm
                # 记录买入佣金。 (记下买入佣金。)
                self.open_trades += 1 # 增加持仓交易计数 (Increment open trades count)
                # 当前持仓交易数量加 1。 (手上的单子数量加 1。)
                # risk_per_trade = self.params.risk_per_trade_percent * self.broker.getvalue() / 100.0
                # self.cumulative_risk_units += risk_per_trade # 累加风险 (Accumulate risk) - 移动到下单处更准确 (Moved to order placement for accuracy)
                # self.log_event('RISK_UPDATE_ON_BUY', current_risk_units=self.cumulative_risk_units, added_risk=risk_per_trade, data_feed=order.data)

            elif order.issell():
                # 如果是卖单。 (如果是卖单。)
                # self.log(f'SELL EXECUTED, Price: {order.executed.price:.2f}, Cost: {order.executed.value:.2f}, Comm {order.executed.comm:.2f}', data=order.data) # 旧日志 (Old log)
                self.open_trades -= 1 # 减少持仓交易计数 (Decrement open trades count)
                # 当前持仓交易数量减 1。 (手上的单子数量减 1。)
                # --- 风险在 notify_trade 中根据 PNL 释放或调整更合理 ---
                # --- Risk adjustment based on PNL in notify_trade is more appropriate ---
                # closed_trade_risk = ??? # 难以直接在此处确定关闭交易的初始风险 (Difficult to determine initial risk here)
                # self.cumulative_risk_units -= closed_trade_risk # 释放风险 (Release risk)
                # self.log_event('RISK_UPDATE_ON_SELL', current_risk_units=self.cumulative_risk_units, released_risk=closed_trade_risk, data_feed=order.data)


            self.bar_executed = len(self) # 记录执行时的 K 线索引 (Record bar index when executed)
            # 记下这笔交易完成时是第几根 K 线。 (记下完成时是第几根 K 线。)

        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            # 如果订单被取消、因保证金不足或被拒绝。 (如果订单被取消、钱不够或者被拒了。)
            # self.log(f'Order {order.ref} Canceled/Margin/Rejected', data=order.data) # 旧日志 (Old log)
            # --- 如果是开仓订单失败，需要考虑回滚风险累加 ---
            # --- If an opening order fails, need to consider rolling back risk accumulation ---
            trade_id_for_failed_order = self.order_ref_to_trade_id_map.get(order.ref)
            # 获取失败订单对应的交易 ID。 (拿到这个失败订单的交易追踪号。)
            if trade_id_for_failed_order and trade_id_for_failed_order == self.current_trade_id:
                # 如果找到了交易 ID 且它就是当前正在尝试的交易。 (如果找到了追踪号，而且就是我们当前正在操作的这个。)
                # 这是一个尝试开新仓但失败的订单 (This was an attempt to open a new position that failed)
                # 重置 current_trade_id，因为这个交易周期并未成功开启
                # (Reset current_trade_id as this trade cycle didn't successfully start)
                self.current_trade_id = None
                # 把当前交易追踪号清空，因为这个交易没开始成功。)
                # 注意：风险计算的逻辑需要根据具体实现来调整 (Note: Risk calculation logic needs adjustment based on specific implementation)
                # self.log_event('TRADE_CYCLE_ABORTED', reason=order.getstatusname(), order_ref=order.ref, data_feed=order.data)
                # 记录交易周期中止事件。 (记一笔日志，说这个交易周期被中止了。)

            # 清理映射 (Clean up mapping)
            if order.ref in self.order_ref_to_trade_id_map:
                # 如果订单引用在映射表中。 (如果订单号在我们的对应表里。)
                del self.order_ref_to_trade_id_map[order.ref]
                # 从映射表中删除该订单引用。 (把它从对应表里删掉。)
                # self.log_event('ORDER_REF_MAP_CLEANUP', reason='Order Failed/Cancelled', order_ref=order.ref, data_feed=order.data) # 可选日志 (Optional log)


        # Write down: no pending order
        # 标记：没有待处理订单 (Write down: no pending order)
        self.order = None
        # 将 self.order 设置为 None，表示当前没有待处理订单。 (把 self.order 清空，表示现在没有订单在等结果了。)


    def notify_trade(self, trade):
        # 定义交易通知函数notify_trade，当交易（一买一卖）完成时被调用，参数trade是交易对象。 (定义交易完成通知函数，当一次完整的买卖结束了，程序会跑这个函数来通知你。)
        # (Define the trade notification function notify_trade, called when a trade (buy and sell) is completed, parameter trade is the trade object.)

        # --- 日志记录：交易关闭/更新 ---
        # (Logging: Trade Closed/Update)
        trade_id = 'UNKNOWN_TRADE' # 默认交易 ID (Default trade ID)
        # 设置一个默认的交易追踪号。 (先假设不知道是哪个交易。)
        order_refs_in_trade = [] # 存储交易涉及的订单引用 (Store order references involved in the trade)
        # 准备一个列表，放这个交易涉及到的所有订单号。 (准备一个空列表，放这次交易用到的所有订单号。)

        if hasattr(trade, 'orders') and trade.orders: # 新版 backtrader (Newer backtrader version)
             # 如果 trade 对象有 orders 属性且不为空 (新版 backtrader)。 (如果 trade 对象里有 orders 列表并且不是空的（新版 backtrader）。)
             order_refs_in_trade = [o.ref for o in trade.orders] # 直接获取订单引用列表 (Get the list of order references directly)
             # 直接拿到所有相关订单的引用号。 (直接拿到所有订单的引用号。)
             # 尝试从第一个订单引用获取交易ID (Try to get trade ID from the first order reference)
             if order_refs_in_trade:
                  # 如果订单引用列表不为空。 (如果拿到了订单号。)
                  trade_id = self.order_ref_to_trade_id_map.get(order_refs_in_trade[0], 'ORPHANED_TRADE_BY_ORDER')
                  # 尝试用第一个订单号去查交易追踪号，找不到就标记为“孤儿交易”。 (用第一个订单号去查追踪号，查不到就标为“孤儿”。)
        elif hasattr(trade, 'ref') and trade.ref in self.order_ref_to_trade_id_map: # 兼容旧版或特定情况 (Compatibility for older versions or specific cases)
            # 如果 trade 对象有 ref 属性（可能是订单引用）并且在映射表中。 (如果 trade 对象只有一个 ref 属性并且在我们的对应表里。)
            order_refs_in_trade = [trade.ref] # 将单个引用放入列表 (Put the single reference into a list)
            # 把这个单独的引用号放到列表里。)
            trade_id = self.order_ref_to_trade_id_map.get(trade.ref, 'ORPHANED_TRADE_BY_REF')
            # 查找交易追踪号，找不到标记为“孤儿”。 (用这个引用号去查追踪号，查不到标为“孤儿”。)


        if not trade.isclosed:
            # 如果交易尚未关闭（例如部分平仓更新）。 (如果这笔交易还没完全结束（比如只平了一部分仓）。)
            # 记录交易更新事件 (Log trade update event)
            self.log_event('TRADE_UPDATE',
                           data_feed=trade.data, # 关联数据源 (Associate data feed)
                           trade_cycle_id=trade_id, # 交易周期ID (Trade cycle ID)
                           trade_ref=trade.ref, # 交易引用 (Trade reference)
                           status=trade.status_names[trade.status], # 交易状态 (Trade status)
                           size=trade.size, # 当前大小 (Current size)
                           price=trade.price, # 当前价格 (Current price)
                           value=trade.value, # 当前价值 (Current value)
                           pnl=trade.pnl, # 当前 PNL (Current PNL)
                           pnlcomm=trade.pnlcomm, # 当前净 PNL (Current net PNL)
                           commission=trade.commission # 累积佣金 (Accumulated commission)
                          )
            # 记录交易更新的日志。 (记录交易更新的日志。)
            return # 返回，因为交易还未结束 (Return as the trade is not yet finished)
            # 交易还没结束，先不往下走了。 (交易还没完，先停在这里。)

        # --- 交易已关闭 ---
        # (Trade is closed)
        # self.log(f'OPERATION PROFIT, GROSS {trade.pnl:.2f}, NET {trade.pnlcomm:.2f}', data=trade.data) # 旧日志 (Old log)

        self.log_event('TRADE_CLOSED',
                       data_feed=trade.data, # 关联数据源 (Associate data feed)
                       trade_cycle_id=trade_id, # 交易周期ID (Trade cycle ID)
                       trade_ref=trade.ref, # 交易引用 (Trade reference)
                       pnl=trade.pnl, # 毛利润/亏损 (Gross profit/loss)
                       pnlcomm=trade.pnlcomm, # 净利润/亏损 (Net profit/loss)
                       commission=trade.commission, # 总佣金 (Total commission)
                       duration_bars=trade.barlen, # 持仓 K 线数 (Duration in bars)
                       open_datetime=trade.open_datetime().isoformat() if trade.dtopen else None, # 开仓时间 (Open datetime)
                       close_datetime=trade.close_datetime().isoformat() if trade.dtclose else None, # 平仓时间 (Close datetime)
                       size=trade.size, # 最终大小（应为0） (Final size (should be 0))
                       initial_size = trade.history[0].event.size if trade.history else None, # 初始开仓大小 (Initial open size)
                       position_type='Long' if trade.long else 'Short' # 交易方向 (Position type)
                      )
        # 记录交易关闭事件，包含盈亏、时长等信息。 (记录交易关闭的日志，包括赚了多少钱、持了多久等。)


        # --- 清理 trade_cycle_id 映射 ---
        # (Clean up trade_cycle_id mapping)
        cleaned_refs = [] # 记录已清理的引用 (Record cleaned references)
        # 准备一个列表，记录删掉了哪些订单号。 (准备一个列表，记下删了哪些订单号。)
        if trade_id != 'ORPHANED_TRADE_BY_ORDER' and trade_id != 'ORPHANED_TRADE_BY_REF' and trade_id != 'UNKNOWN_TRADE':
             # 如果交易不是孤儿或未知。 (如果这个交易不是孤儿或者未知的。)
             refs_to_remove = [ref for ref, t_id in self.order_ref_to_trade_id_map.items() if t_id == trade_id]
             # 找到所有与此交易周期ID关联的订单引用。 (找出对应表里所有属于这个交易追踪号的订单号。)
             for ref in refs_to_remove:
                 # 遍历找到的订单引用。 (检查每一个找到的订单号。)
                 del self.order_ref_to_trade_id_map[ref]
                 # 从映射表中删除。 (从对应表里删掉。)
                 cleaned_refs.append(ref)
                 # 添加到已清理列表。 (记一下这个订单号被删了。)

             # 如果这个关闭的交易是当前活跃的交易，则重置 current_trade_id
             # (If this closed trade was the currently active one, reset current_trade_id)
             if self.current_trade_id == trade_id:
                 # 如果关闭的这个正好是当前正在进行的交易。 (如果关掉的正好是当前进行的这个。)
                 self.current_trade_id = None
                 # 将当前交易追踪号设为 None。 (把当前交易追踪号清空。)
                 # self.log_event('CURRENT_TRADE_CYCLE_CLOSED', closed_trade_id=trade_id, data_feed=trade.data) # 可选日志 (Optional log)
        # else:
            # 对于孤儿交易，尝试使用 trade.orders 中的引用进行清理 (For orphaned trades, try cleaning using refs from trade.orders)
            # for ref in order_refs_in_trade:
            #     if ref in self.order_ref_to_trade_id_map:
            #         del self.order_ref_to_trade_id_map[ref]
            #         cleaned_refs.append(ref)
            # pass # 孤儿交易无需特殊处理映射清理，因为它们本就不在映射中或 ID 未知 (Orphaned trades don't need special map cleanup as they weren't mapped or ID was unknown)

        # self.log_event('ORDER_REF_MAP_CLEANUP', reason='Trade Closed', cleaned_refs=cleaned_refs, trade_id=trade_id, data_feed=trade.data) # 可选日志 (Optional log)

        # --- 更新风险状态 ---
        # (Update risk status)
        # 交易关闭，风险单位清零或根据策略调整 (Trade closed, risk units reset or adjusted based on strategy)
        # 这里假设每个关闭的交易完全释放其风险，简化处理 (Assuming each closed trade fully releases its risk for simplicity)
        # 更复杂的逻辑可能需要跟踪每个交易的初始风险 (More complex logic might need to track initial risk per trade)
        # self.cumulative_risk_units = max(0.0, self.cumulative_risk_units - ???) # 需要确定释放多少风险 (Need to determine how much risk to release)
        # self.log_event('RISK_UPDATE_ON_TRADE_CLOSE', current_risk_units=self.cumulative_risk_units, pnlcomm=trade.pnlcomm, data_feed=trade.data)

        # 更新最高水位线 (Update high water mark)
        current_value = self.broker.getvalue()
        # 获取当前总资产。 (拿到现在的总资产。)
        if current_value > self.high_water_mark:
            # 如果当前总资产超过了历史最高。 (如果现在的钱比以前最多的时候还多。)
            # self.log_event('HIGH_WATER_MARK_UPDATE', old_hwm=self.high_water_mark, new_hwm=current_value, data_feed=trade.data) # 可选日志 (Optional log)
            self.high_water_mark = current_value
            # 更新最高水位线。 (更新历史最高纪录。)


    # ... （next 方法修改见下一步）

    def stop(self):
        # 定义 stop 方法，在回测结束时调用。 (定义策略结束时要做的事情。)
        """Strategy stop method."""
        # """策略停止方法。"""
        self.log_event('STRATEGY_STOP', final_value=self.broker.getvalue(), final_cash=self.broker.getcash())
        # 记录策略停止事件，包含最终资产和现金。 (记录策略停止的日志，附上最后的总资产和现金。)
        # --- 停止日志监听器 ---
        # (Stop the log listener)
        # stop_log_listener() # 在 Cerebro 运行结束后停止更合适 (More appropriate to stop after Cerebro run finishes)
        # print("Strategy stop method called.") # 用于调试 (For debugging)

    # ==================== 交易周期ID管理辅助方法 START ====================
    def _generate_trade_cycle_id(self):
        # 定义一个私有方法，用于生成新的交易周期ID。 (定义一个内部工具，用来生成新的交易追踪号。)
        """Generates a new unique trade cycle ID."""
        # """生成一个新的唯一交易周期ID。"""
        return uuid.uuid4().hex
        # 返回一个基于 UUID4 的十六进制字符串作为唯一ID。 (生成并返回一个独一无二的字符串ID。)

    def _map_order_ref_to_trade_id(self, order):
        # 定义一个私有方法，将订单引用映射到当前的交易周期ID。 (定义一个内部工具，把订单号和当前的交易追踪号关联起来。)
        """Maps the order reference to the current trade cycle ID."""
        # """将订单引用映射到当前交易周期ID。"""
        if order and order.ref is not None and self.current_trade_id:
            # 如果订单对象有效，订单引用不为空，且当前交易周期ID存在。 (如果订单有效、订单号存在、并且当前有交易追踪号。)
            self.order_ref_to_trade_id_map[order.ref] = self.current_trade_id
            # 在映射字典中创建或更新条目。 (在对应表里记下：这个订单号 -> 这个交易追踪号。)
            # self.log_event('ORDER_REF_MAPPED', order_ref=order.ref, trade_cycle_id=self.current_trade_id, data_feed=order.data) # 可选日志 (Optional log)

    # ==================== 交易周期ID管理辅助方法 END ======================
```

**五、 在策略生命周期中嵌入日志记录点 (`next` 方法)**

现在修改 `next` 方法，加入信号触发、订单计算、交易跳过等事件的日志记录，并管理 `trade_cycle_id` 的生成。

```python
# ... (在 AShareETFStrategy 类中)

    def next(self):
        # 定义next函数，在每个数据点（通常是每个交易日）都会被调用一次，用于执行策略的主要逻辑。 (定义next函数，这是策略的核心，每天开盘后都要运行一遍，决定今天该干啥。)
        # (Define the next function, called once per data point (usually each trading day), for executing the main strategy logic.)

        # --- 检查是否暂停交易 ---
        # (Check if trading is halted)
        current_dt = self.datas[0].datetime.datetime(0) # 获取当前时间 (Get current time)
        # 拿到当前的回测时间。 (拿到现在的模拟时间。)
        if self.halt_trading_until and current_dt < self.halt_trading_until:
            # 如果设置了暂停交易时间点，并且当前时间还没到那个点。 (如果之前设置了暂停交易，并且还没到恢复时间。)
            # self.log(f'Trading halted until {self.halt_trading_until}. Skipping bar.', dt=current_dt) # 旧日志 (Old log)
            self.log_event('TRADING_HALTED_SKIP', halt_until=self.halt_trading_until.isoformat(), current_time=current_dt.isoformat())
            # 记录交易暂停跳过事件。 (记一笔日志，说因为暂停交易，这根K线跳过了。)
            return # 跳过当前 K 线 (Skip current bar)
            # 直接返回，不做任何操作。 (这根K线啥也不干。)
        elif self.halt_trading_until and current_dt >= self.halt_trading_until:
            # 如果到了或超过了暂停交易的恢复时间点。 (如果到了或者超过了恢复时间。)
            # self.log(f'Trading resumed at {current_dt}.', dt=current_dt) # 旧日志 (Old log)
            self.log_event('TRADING_RESUMED', resume_time=current_dt.isoformat(), previous_halt_until=self.halt_trading_until.isoformat())
            # 记录交易恢复事件。 (记一笔日志，说交易恢复了。)
            self.halt_trading_until = None # 清除暂停标记 (Clear halt flag)
            # 清除暂停交易的标记。 (把暂停标记去掉。)


        # --- 遍历所有数据源执行策略逻辑 ---
        # (Iterate through all data feeds to execute strategy logic)
        for d in self.datas:
            # 遍历每一个数据源。 (检查每一个我们关心的数据（比如不同的股票ETF）。)
            # data_name = d._name # 获取数据源名称 (Get data feed name)
            # # 拿到当前数据源的名字。 (拿到当前这个数据的名字。)
            # close = self.d_close[data_name][0] # 获取当前收盘价 (Get current close price)
            # # 拿到当前这个数据的收盘价。 (拿到它的收盘价。)
            # # open_ = self.d_open[data_name][0] # 获取当前开盘价 (Get current open price)
            # # high = self.d_high[data_name][0] # 获取当前最高价 (Get current high price)
            # # low = self.d_low[data_name][0] # 获取当前最低价 (Get current low price)
            # inds = self.inds[data_name] # 获取当前数据源的指标 (Get indicators for the current data feed)
            # # 拿到当前这个数据对应的所有指标工具。 (拿到跟它相关的指标工具。)

            # # --- 记录市场状态评估 ---
            # # (Log Market State Assessment)
            # market_state_indicators = { # 收集用于市场判断的指标值 (Collect indicator values used for market judgment)
            #     'ema_short': inds['ema_short'][0], # 短期 EMA (Short-term EMA)
            #     'ema_medium': inds['ema_medium'][0], # 中期 EMA (Medium-term EMA)
            #     'ema_long': inds['ema_long'][0], # 长期 EMA (Long-term EMA)
            #     'bb_mid': inds['bbands'].lines.mid[0], # 布林带中轨 (Bollinger Bands Midline)
            #     'bb_top': inds['bbands'].lines.top[0], # 布林带上轨 (Bollinger Bands Top)
            #     'bb_bot': inds['bbands'].lines.bot[0], # 布林带下轨 (Bollinger Bands Bottom)
            #     'atr': inds['atr'][0] # ATR
            # }
            # # 把当前几个关键指标的值收集起来。 (把几个关键指标现在的值收在一起。)
            # self.log_event('MARKET_STATE_ASSESSED', data_feed=d, indicators=market_state_indicators)
            # # 记录市场状态评估事件。 (记一笔日志，说我们评估了市场状态，并附上指标值。)

            # Check if an order is pending ... if yes, we cannot send a 2nd one
            # 检查是否有待处理订单...如果是，则不能发送第二个订单 (Check if an order is pending ... if yes, we cannot send a 2nd one)
            if self.order:
                # 如果 self.order 不是 None（即有待处理订单）。 (如果 self.order 里面有东西（说明有个订单还没完成）。)
                # self.log_event('PENDING_ORDER_SKIP', data_feed=d, order_ref=self.order.ref) # 可选日志 (Optional log)
                continue # 跳过当前数据源的处理 (Skip processing for this data feed)
                # 跳过这个数据，处理下一个。 (这个数据先不处理了，去看下一个。)

            # Check if we are in the market
            # 检查我们是否在市场中（即是否持仓） (Check if we are in the market (i.e., holding a position))
            position_size = self.getposition(d).size
            # 获取当前数据源的持仓大小。 (看看当前这个数据我们手里有多少。)

            # --- 定义入场和出场条件 ---
            # (Define entry and exit conditions)
            # is_bullish = inds['ema_short'][0] > inds['ema_medium'][0] and inds['ema_medium'][0] > inds['ema_long'][0] # 牛市条件 (Bullish condition)
            # # 判断是不是牛市：短期线在中期线之上，中期线在长期线之上。 (判断是不是牛市：短期均线上穿中期，中期上穿长期。)
            # is_bearish = inds['ema_short'][0] < inds['ema_medium'][0] and inds['ema_medium'][0] < inds['ema_long'][0] # 熊市条件 (Bearish condition)
            # # 判断是不是熊市：短期线在中期线之下，中期线在长期线之下。 (判断是不是熊市：短期均线下穿中期，中期下穿长期。)
            # cross_up_medium = bt.indicators.CrossOver(inds['ema_short'], inds['ema_medium'])[0] > 0 # 短期上穿中期 (Short crosses over medium)
            # # 判断短期线是否刚刚上穿中期线。 (判断短期 EMA 是不是刚上穿中期 EMA。)
            # cross_down_medium = bt.indicators.CrossDown(inds['ema_short'], inds['ema_medium'])[0] > 0 # 短期下穿中期 (Short crosses down medium)
            # # 判断短期线是否刚刚下穿中期线。 (判断短期 EMA 是不是刚下穿中期 EMA。)
            # # close_over_long = close > inds['ema_long'][0] # 收盘价在长期均线之上 (Close price is above long-term average)
            # # close_under_long = close < inds['ema_long'][0] # 收盘价在长期均线之下 (Close price is below long-term average)
            # close_over_bb_mid = close > inds['bbands'].lines.mid[0] # 收盘价在布林中轨之上 (Close price is above Bollinger midline)
            # # 判断收盘价是否在布林带中轨之上。 (判断收盘价是不是在中轨上面。)
            # close_under_bb_mid = close < inds['bbands'].lines.mid[0] # 收盘价在布林中轨之下 (Close price is below Bollinger midline)
            # # 判断收盘价是否在布林带中轨之下。 (判断收盘价是不是在中轨下面。)

            # --- 计算止损位和潜在入场价 ---
            # (Calculate stop loss level and potential entry price)
            atr_val = inds['atr'][0] # 获取 ATR 值 (Get ATR value)
            # 拿到当前的 ATR 值。 (拿到现在的 ATR。)
            stop_loss_long = close - self.p.atr_multiplier * atr_val # 多头止损位 (Long stop loss level)
            # 计算做多的止损价位。 (算一下做多的止损价。)
            stop_loss_short = close + self.p.atr_multiplier * atr_val # 空头止损位 (Short stop loss level)
            # 计算做空的止损价位。 (算一下做空的止损价。)
            entry_price = close # 假设以收盘价入场 (Assume entry at close price)
            # 假设用收盘价进场。 (假设按收盘价买入/卖出。)

            # --- 风险检查 ---
            # (Risk Check)
            can_trade = True # 默认可以交易 (Default can trade)
            # 先假设可以交易。 (先假设能交易。)
            risk_check_details = {} # 存储风险检查细节 (Store risk check details)
            # 准备一个盒子放风险检查的细节。 (准备一个空盒子放风险检查的细节。)

            # 1. 检查最大累积风险 (Check maximum cumulative risk)
            #    (需要先计算本次交易的潜在风险)
            #    (Need to calculate potential risk for this trade first)
            portfolio_value = self.broker.getvalue() # 获取当前投资组合价值 (Get current portfolio value)
            # 拿到当前的总资产。 (拿到现在的总资产。)
            # potential_risk_percent = self.p.risk_per_trade_percent # 本次交易风险百分比 (Risk percentage for this trade)
            # # 这次交易打算承担多少风险（百分比）。 (这次交易计划承担的风险比例。)
            # potential_risk_value = portfolio_value * potential_risk_percent / 100.0 # 本次交易风险金额 (Risk amount for this trade)
            # # 这次交易打算承担多少风险（金额）。 (这次交易计划承担的风险金额。)

            # # 检查是否超过最大总风险 (Check if maximum total risk is exceeded)
            # if self.cumulative_risk_units + potential_risk_value > portfolio_value * self.p.max_total_risk_percent / 100.0:
            #     # 如果当前累积风险加上这次潜在风险，超过了设定的最大总风险比例。 (如果目前总风险加上这次的，超过了我们设定的总风险上限。)
            #     can_trade = False # 不可交易 (Cannot trade)
            #     # 不能交易。 (那就不能交易。)
            #     risk_check_details['reason'] = 'MAX_TOTAL_RISK_EXCEEDED' # 原因：超过最大总风险 (Reason: Maximum total risk exceeded)
            #     # 记下原因：总风险超标。 (记下原因：总风险超了。)
            #     risk_check_details['cumulative'] = self.cumulative_risk_units # 当前累积风险 (Current cumulative risk)
            #     # 记下当前的累积风险。 (记下现在的总风险。)
            #     risk_check_details['potential'] = potential_risk_value # 本次潜在风险 (Potential risk for this trade)
            #     # 记下这次交易的潜在风险。 (记下这次的潜在风险。)
            #     risk_check_details['limit'] = portfolio_value * self.p.max_total_risk_percent / 100.0 # 总风险限额 (Total risk limit)
            #     # 记下总风险的上限。 (记下总风险的上限。)


            # 2. 检查最大持仓数量 (Check maximum number of open trades)
            if can_trade and not position_size and self.open_trades >= self.p.max_open_trades:
                 # 如果前面检查通过，并且当前没有持仓，但是已开仓数量达到了最大限制。 (如果前面检查没问题，现在手里没这个数据，但总共开的单子数量已经到顶了。)
                 can_trade = False # 不可交易 (Cannot trade)
                 # 不能交易。 (不能再开新单了。)
                 risk_check_details['reason'] = 'MAX_OPEN_TRADES_REACHED' # 原因：达到最大持仓数量 (Reason: Maximum open trades reached)
                 # 记下原因：开单数量到顶了。 (记下原因：开单数量满了。)
                 risk_check_details['open_trades'] = self.open_trades # 当前持仓数量 (Current open trades)
                 # 记下当前开了多少单。 (记下现在开了几单。)
                 risk_check_details['limit'] = self.p.max_open_trades # 最大持仓限额 (Maximum open trades limit)
                 # 记下最大能开几单。 (记下最多能开几单。)


            # 3. 检查最大回撤 (Check maximum drawdown) - 这个更适合在 notify_cashvalue 中处理，因为需要每个 bar 更新 HWM (More suitable in notify_cashvalue as HWM needs updating per bar)
            # current_drawdown = (self.high_water_mark - portfolio_value) / self.high_water_mark if self.high_water_mark > 0 else 0.0
            # if can_trade and current_drawdown > self.p.max_drawdown_percent / 100.0:
            #     can_trade = False
            #     risk_check_details['reason'] = 'MAX_DRAWDOWN_EXCEEDED'
            #     risk_check_details['current_drawdown'] = current_drawdown * 100
            #     risk_check_details['limit'] = self.p.max_drawdown_percent
            #     # 触发风控暂停交易 (Trigger risk control trading halt)
            #     halt_duration = datetime.timedelta(days=self.p.halt_duration_days)
            #     self.halt_trading_until = current_dt + halt_duration
            #     self.log_event('RISK_EVENT_HALT_TRIGGERED',
            #                    event_subtype='MAX_DRAWDOWN',
            #                    account_value=portfolio_value,
            #                    high_water_mark=self.high_water_mark,
            #                    drawdown_pct=current_drawdown * 100,
            #                    limit_pct=self.p.max_drawdown_percent,
            #                    halt_until=self.halt_trading_until.isoformat(),
            #                    data_feed=d)


            # --- 主要交易逻辑 ---
            # (Main Trading Logic)
            if not position_size: # 没有持仓 (No position)
                # 如果当前没有持有这个数据。 (如果手里没这个货。)

                # --- 潜在入场信号 ---
                # (Potential Entry Signals)
                entry_signal_type = None # 初始化入场信号类型 (Initialize entry signal type)
                # 先假设没有入场信号。 (先假设没信号。)
                triggering_data = {} # 存储触发信号的数据 (Store data that triggered the signal)
                # 准备一个盒子放触发信号的具体数据。 (准备一个盒子放触发信号的数据。)

                if is_bullish and cross_up_medium and close_over_bb_mid: # 多头入场信号 (Long entry signal)
                     # 如果是牛市、短期线上穿中期线、且收盘价在中轨之上。 (如果是牛市，短期均线刚上穿中期，并且收盘价在中轨之上。)
                     entry_signal_type = 'EMA_Cross_BB_Confirm_Long' # 信号类型 (Signal type)
                     # 信号类型：EMA金叉+BB确认做多。 (信号是：EMA金叉+BB确认做多。)
                     triggering_data = {'close': close, 'ema_short': inds['ema_short'][0], 'ema_medium': inds['ema_medium'][0], 'bb_mid': inds['bbands'].lines.mid[0]}
                     # 记录触发时的价格和指标值。 (记下触发时的价格和指标值。)
                     stop_loss_price = stop_loss_long # 使用多头止损 (Use long stop loss)
                     # 用做多的止损价。 (用多头止损。)
                     is_buy = True # 标记为买入 (Mark as buy)
                     # 标记是买入操作。 (标记这是买入。)

                # elif is_bearish and cross_down_medium and close_under_bb_mid: # 空头入场信号（如果允许做空） (Short entry signal (if shorting allowed))
                #     # 如果是熊市、短期线下穿中期线、且收盘价在中轨之下。 (如果是熊市，短期均线刚下穿中期，并且收盘价在中轨之下。)
                #     # 注意：示例策略可能不包含做空逻辑 (Note: Example strategy might not include shorting logic)
                #     # entry_signal_type = 'EMA_Cross_BB_Confirm_Short'
                #     # triggering_data = {'close': close, 'ema_short': inds['ema_short'][0], 'ema_medium': inds['ema_medium'][0], 'bb_mid': inds['bbands'].lines.mid[0]}
                #     # stop_loss_price = stop_loss_short
                #     # is_buy = False
                #     pass # 暂不处理做空 (Do not handle shorting for now)
                #     # 暂时不做空。 (暂时不做空。)


                # --- 如果有入场信号并且风控检查通过 ---
                # (If there is an entry signal and risk checks passed)
                if entry_signal_type and can_trade:
                    # 如果探测到了入场信号，并且风险检查也通过了。 (如果有进场信号，而且风险检查也过了。)

                    # == 生成新的交易周期 ID ==
                    # (Generate new trade cycle ID)
                    self.current_trade_id = self._generate_trade_cycle_id()
                    # 生成一个新的交易追踪号，并存起来。 (生成一个新的交易追踪号，记下来。)

                    # 记录信号触发事件 (Log signal triggered event)
                    self.log_event('SIGNAL_TRIGGERED',
                                   data_feed=d, # 关联数据源 (Associate data feed)
                                   signal_type=entry_signal_type, # 信号类型 (Signal type)
                                   triggering_data=triggering_data, # 触发数据 (Triggering data)
                                   trade_cycle_id=self.current_trade_id # 必须包含新生成的ID (Must include the newly generated ID)
                                  )
                    # 记录信号触发日志，带上新的追踪号。 (记录信号触发的日志，带上新的追踪号。)


                    # == 计算订单大小 ==
                    # (Calculate order size)
                    calculated_size_info = self._calculate_trade_size(
                        data_close_price=close,
                        entry_price=entry_price,
                        stop_loss_price=stop_loss_price,
                        risk_per_trade_percent=self.p.risk_per_trade_percent,
                        data=d # 传递数据对象 (Pass the data object)
                    )
                    # 调用内部工具计算订单大小。 (调用咱们自己写的工具算一下该买多少。)
                    size = calculated_size_info['size'] # 获取计算出的大小 (Get the calculated size)
                    # 拿到计算结果：买多少。 (拿到算出来的数量。)
                    size_calc_details = calculated_size_info['details'] # 获取计算详情 (Get calculation details)
                    # 拿到计算过程的细节。 (拿到计算过程的细节。)

                    # 记录订单计算事件 (Log order calculation event)
                    self.log_event('ORDER_CALCULATION',
                                   data_feed=d, # 关联数据源 (Associate data feed)
                                   signal_type=entry_signal_type, # 关联的信号类型 (Associated signal type)
                                   entry_price_approx=entry_price, # 大致入场价 (Approximate entry price)
                                   stop_loss_calc=stop_loss_price, # 计算出的止损价 (Calculated stop loss price)
                                   take_profit_calc=None, # 未计算止盈价 (Take profit price not calculated)
                                   risk_inputs=size_calc_details['risk_inputs'], # 风险计算输入 (Risk calculation inputs)
                                   size_raw=size_calc_details['raw_size'], # 原始计算大小 (Raw calculated size)
                                   size_final=size, # 最终调整后大小 (Final adjusted size)
                                   adjustment_reasons=size_calc_details['adjustment_reasons'], # 调整原因 (Adjustment reasons)
                                   trade_cycle_id=self.current_trade_id # 必须包含交易ID (Must include trade ID)
                                  )
                    # 记录订单计算日志，包含计算细节和交易追踪号。 (记录算单日志，包括怎么算的、结果多少、带上交易追踪号。)


                    if size > 0:
                        # 如果计算出的下单量大于0。 (如果算出来确实要买。)
                        # self.log(f'BUY CREATE, {close:.2f}, Size: {size}', dt=current_dt, data=d) # 旧日志 (Old log)
                        order_to_place = self.buy(data=d, size=size) if is_buy else self.sell(data=d, size=size) # 发出买入或卖出指令 (Issue buy or sell command)
                        # 发出买入（或卖出）指令。 (那就下单买入（或卖出）。)
                        self.order = order_to_place # 跟踪订单 (Track the order)
                        # 把这个订单记到 self.order 里，表示有个订单发出去了。 (把这个订单记到 self.order，表示有个单子在外面跑。)

                        # == 映射订单引用和交易 ID ==
                        # (Map order reference and trade ID)
                        self._map_order_ref_to_trade_id(self.order) # 调用辅助方法进行映射 (Call helper method for mapping)
                        # 把这个新订单的号和当前的交易追踪号关联起来。 (把这个订单号和当前的交易追踪号对上。)

                        # 记录订单提交事件 (Log order submitted event)
                        if self.order:
                            # 如果订单成功创建。 (如果订单创建成功了。)
                            self.log_event('ORDER_SUBMITTED',
                                           data_feed=d, # 关联数据源 (Associate data feed)
                                           order_ref=self.order.ref, # 订单引用 (Order reference)
                                           trade_cycle_id=self.current_trade_id, # 交易周期ID (Trade cycle ID)
                                           order_details={ # 订单详情 (Order details)
                                               'type': self.order.getordername(), # 类型 (Type)
                                               'size': self.order.created.size, # 大小 (Size)
                                               'price': self.order.created.price, # 价格 (Price)
                                               'pricelimit': self.order.created.pricelimit, # 限价 (Price limit)
                                               'valid': self.order.valid, # 有效期 (Validity)
                                               'isbuy': self.order.isbuy(), # 是否买单 (Is buy?)
                                               'issell': self.order.issell() # 是否卖单 (Is sell?)
                                           })
                            # 记录订单提交日志，包含订单细节和交易追踪号。 (记录下单日志，包括订单细节和交易追踪号。)
                        # else: # 如果 self.buy/sell 返回 None (比如 size 为 0) (If self.buy/sell returns None (e.g., size is 0))
                            # self.log_event('ORDER_SUBMISSION_FAILED', reason='Calculated size was zero or order rejected immediately', trade_cycle_id=self.current_trade_id, data_feed=d)
                            # self.current_trade_id = None # 重置交易ID (Reset trade ID)
                            # # 订单提交失败，可能是计算大小为0或其他原因。 (下单失败，可能是算出来买0股。)
                            # # 重置交易追踪号。 (把交易追踪号清掉。)
                    else:
                        # 如果计算出的尺寸无效 (If calculated size is not valid)
                        # self.log_event('TRADE_SKIPPED', reason='Calculated size is zero or negative', details=size_calc_details, trade_cycle_id=self.current_trade_id, data_feed=d)
                        # self.current_trade_id = None # 重置交易ID (Reset trade ID)
                        # 记录交易跳过事件，因为计算出的数量无效。 (记一笔日志，说这次交易跳过了，因为算出来的数量不对。)
                        # 把交易追踪号清掉。 (把交易追踪号清了。)


                elif entry_signal_type and not can_trade: # 有信号但风控阻止 (Signal exists but risk control prevents)
                     # 如果有入场信号，但是风险检查没通过。 (如果有信号，但风险检查不让交易。)
                     self.log_event('TRADE_SKIPPED',
                                    data_feed=d, # 关联数据源 (Associate data feed)
                                    reason='Risk Control', # 原因：风险控制 (Reason: Risk Control)
                                    details=risk_check_details, # 风险检查细节 (Risk check details)
                                    signal_type=entry_signal_type, # 触发的信号 (Triggered signal)
                                    triggering_data=triggering_data # 信号数据 (Signal data)
                                    # trade_cycle_id 不适用，因为交易未启动 (trade_cycle_id not applicable as trade wasn't initiated)
                                   )
                     # 记录交易跳过事件，因为风险控制。 (记一笔日志，说这次交易跳过了，因为风险控制不让。)

            else: # 持有仓位 (Holding a position)
                # 如果当前持有这个数据。 (如果手里有这个货。)

                # --- 潜在出场信号 ---
                # (Potential Exit Signals)
                exit_signal_type = None # 初始化出场信号类型 (Initialize exit signal type)
                # 先假设没有出场信号。 (先假设没信号。)
                triggering_data = {} # 存储触发信号的数据 (Store data that triggered the signal)
                # 准备一个盒子放触发信号的具体数据。 (准备一个盒子放触发信号的数据。)

                if position_size > 0 and cross_down_medium: # 多头持仓，短期下穿中期 (Long position, short crosses down medium)
                    # 如果是多头持仓，并且短期线下穿了中期线。 (如果是多单，并且短期均线下穿了中期均线。)
                    exit_signal_type = 'EMA_Cross_Exit_Long' # 信号类型：EMA 死叉平多 (Signal type: EMA Death Cross Exit Long)
                    # 信号是：EMA死叉平多仓。 (信号是：EMA 死叉平多。)
                    triggering_data = {'close': close, 'ema_short': inds['ema_short'][0], 'ema_medium': inds['ema_medium'][0]}
                    # 记录触发时的价格和指标值。 (记下触发时的价格和指标值。)
                    is_close = True # 标记为平仓 (Mark as close)
                    # 标记是平仓操作。 (标记这是平仓。)

                # elif position_size < 0 and cross_up_medium: # 空头持仓，短期上穿中期 (Short position, short crosses up medium)
                #     # 如果是空头持仓，并且短期线上穿了中期线。 (如果是空单，并且短期均线上穿了中期均线。)
                #     exit_signal_type = 'EMA_Cross_Exit_Short'
                #     triggering_data = {'close': close, 'ema_short': inds['ema_short'][0], 'ema_medium': inds['ema_medium'][0]}
                #     is_close = True

                # --- 如果有出场信号 ---
                # (If there is an exit signal)
                if exit_signal_type:
                    # 如果探测到了出场信号。 (如果有平仓信号。)

                    # 尝试获取与当前持仓关联的 trade_cycle_id
                    # (Attempt to get the trade_cycle_id associated with the current position)
                    # 注意：简单的策略可能只有一个活跃的 trade_cycle_id
                    # (Note: Simple strategies might only have one active trade_cycle_id)
                    # 如果有多个并发交易，需要更复杂的逻辑来确定哪个交易被关闭
                    # (More complex logic is needed to determine which trade is being closed if multiple concurrent trades exist)
                    exit_trade_id = self.current_trade_id # 假设是当前活跃的交易 (Assume it's the currently active trade)
                    # 先假设要平的是当前正在进行的这个交易。 (先假设要平的是当前这个。)
                    # 实际应用中，可能需要通过 self.getposition(d).tradeid 或其他方式确认
                    # (In practice, might need confirmation via self.getposition(d).tradeid or other means)


                    # 记录信号触发事件 (Log signal triggered event)
                    self.log_event('SIGNAL_TRIGGERED',
                                   data_feed=d, # 关联数据源 (Associate data feed)
                                   signal_type=exit_signal_type, # 信号类型 (Signal type)
                                   triggering_data=triggering_data, # 触发数据 (Triggering data)
                                   trade_cycle_id=exit_trade_id if exit_trade_id else 'UNKNOWN_EXIT' # 关联的交易ID或未知 (Associated trade ID or unknown)
                                  )
                    # 记录信号触发日志，带上关联的交易追踪号（如果知道的话）。 (记录信号触发日志，带上关联的交易追踪号（如果知道）。)


                    # self.log(f'CLOSE CREATE, {close:.2f}, Size: {position_size}', dt=current_dt, data=d) # 旧日志 (Old log)
                    order_to_place = self.close(data=d) # 发出平仓指令 (Issue close command)
                    # 发出平仓指令。 (下单平仓。)
                    self.order = order_to_place # 跟踪订单 (Track the order)
                    # 把这个订单记到 self.order 里。 (把这个订单记到 self.order。)

                    # == 映射订单引用和交易 ID ==
                    # (Map order reference and trade ID)
                    self._map_order_ref_to_trade_id(self.order) # 使用平仓订单关联 (Associate using the closing order)
                    # 把这个平仓订单的号和对应的交易追踪号关联起来。 (把这个平仓单号和对应的追踪号对上。)

                    # 记录订单提交事件 (Log order submitted event)
                    if self.order:
                         # 如果订单成功创建。 (如果订单创建成功了。)
                         self.log_event('ORDER_SUBMITTED',
                                        data_feed=d, # 关联数据源 (Associate data feed)
                                        order_ref=self.order.ref, # 订单引用 (Order reference)
                                        trade_cycle_id=exit_trade_id if exit_trade_id else 'UNKNOWN_EXIT', # 交易周期ID (Trade cycle ID)
                                        order_details={ # 订单详情 (Order details)
                                            'type': self.order.getordername(), # 类型 (Type)
                                            'size': self.order.created.size, # 大小 (Size)
                                            'price': self.order.created.price, # 价格 (Price)
                                            'isclose': True # 标记为平仓单 (Mark as closing order)
                                        })
                         # 记录订单提交日志。 (记录下单日志。)
                    # else:
                         # self.log_event('ORDER_SUBMISSION_FAILED', reason='Close order failed', trade_cycle_id=exit_trade_id, data_feed=d)
                         # 记录平仓失败日志。 (记录平仓失败日志。)
```

**六、 确保日志系统停止**

需要在 Cerebro 运行结束后或者策略明确停止时关闭日志监听器线程。我们可以在 `run_backtest` 函数（如果它是主入口）的末尾添加关闭监听器的调用，或者如果直接运行 Cerebro，在其 `run()` 方法返回后调用。为了简单起见，我们可以在 `run_backtest` 的 `finally` 块中添加。

```python
# ... (在 run_backtest 函数的末尾)
    finally:
        # --- 停止日志监听器 ---
        # (Stop the log listener)
        stop_log_listener() # 确保在程序退出前停止监听器 (Ensure listener is stopped before program exit)
        # print("Log listener stopped.") # 用于调试 (For debugging)

        if start_time:
            # 如果记录了开始时间 (If start time was recorded)
            # ... (原有的时间计算和打印逻辑)
```

**总结:**

*   **核心概念:**
    *   <font color='blue'>**结构化日志 (Structured Logging):**</font> 将日志信息组织成键值对 (JSON)，便于机器读取和分析。<font color='red'> (讲人话: 给每条信息贴上标准标签，电脑能看懂)。</font>
    *   <font color='blue'>**交易周期ID (`trade_cycle_id`):**</font> 一个唯一的标识符，用于串联起从信号产生到交易结束的所有相关日志事件。<font color='red'> (讲人话: 像快递单号，追踪一个交易从头到尾的所有步骤)。</font>
    *   <font color='blue'>**异步日志 (Asynchronous Logging):**</font> 使用队列和单独的线程处理日志写入，避免阻塞策略执行主线程。<font color='red'> (讲人话: 找个秘书专门写日志，不耽误主策略开车)。</font>
*   **思维模型 (类比):**
    *   整个日志系统就像一个 **详细的行车记录仪 (Detailed Dashcam)**。
    *   `log_event` 是 **按下录制按钮 (Pressing Record Button)**，记录特定事件。
    *   `trade_cycle_id` 是每次 **行程的编号 (Trip Number)**，将同一段行程的所有录像关联起来。
    *   JSONL 格式是 **标准化的录像文件格式 (Standardized Video File Format)**，方便后期查看和分析。
    *   异步写入是 **后台自动上传录像 (Background Automatic Upload)**，不影响当前驾驶。
*   **记忆口诀:**
    *   <font color='green'>**事件日志结构化 (Shìjiàn rìzhì jiégòuhuà)，**</font>
    *   <font color='green'>**周期ID一线牵 (Zhōuqī ID yīxiàn qiān)。**</font>
    *   <font color='green'>**异步写入不卡顿 (Yìbù xiěrù bù kǎdùn)，**</font>
    *   <font color='green'>**JSON分析特方便 (JSON fēnxī tè fāngbiàn)。**</font>

现在，我将把这些修改应用到 `bt_g2.5t_strategy0414.py` 文件中。请注意，`_calculate_trade_size` 方法内部可能也需要传递 `data_feed` 参数给 `log_event`（如果它内部有日志记录的话），这里暂时省略了这个细节的修改，但实际应用中需要考虑。

```tool_code
print(default_api.edit_file(target_file='codes/labs/bt_g2.5t_strategy0414.py', instructions="Implement the enhanced logging system as per the requirements document.", code_edit='''\
import backtrader as bt
# 导入backtrader库，用于量化交易策略的回测和开发。 (Import the backtrader library for quantitative trading strategy backtesting and development.)
import backtrader.indicators as btind
# 导入backtrader的指标模块，方便使用内置的技术指标。 (Import the indicators module from backtrader for easy use of built-in technical indicators.)
import pandas as pd
# 导入pandas库，用于数据处理和分析，特别是在处理优化结果时。 (Import the pandas library for data processing and analysis, especially when handling optimization results.)
import numpy as np
# 导入numpy库，提供高效的数值计算功能。 (Import the numpy library for efficient numerical computation.)
import time
# 导入time库，用于计算代码执行时间。 (Import the time library to calculate code execution time.)
import itertools
# 导入itertools库，提供用于创建迭代器的工具，在优化参数组合时使用。 (Import the itertools library for tools to create iterators, used for combining optimization parameters.)
from collections import OrderedDict
# 从collections模块导入OrderedDict，用于保持字典中元素的插入顺序，方便结果展示。 (Import OrderedDict from the collections module to maintain the insertion order of elements in a dictionary, useful for presenting results.)
from concurrent.futures import ProcessPoolExecutor, as_completed
# 从concurrent.futures模块导入ProcessPoolExecutor和as_completed，用于并行执行优化任务，提高效率。 (Import ProcessPoolExecutor and as_completed from the concurrent.futures module for parallel execution of optimization tasks, improving efficiency.)
# ================= 日志系统所需导入 START =================
import logging
# 导入logging库，用于实现日志记录功能。 (Import the logging library for implementing logging functionality.)
import logging.handlers
# 导入logging.handlers模块，提供高级日志处理方式，如队列处理。 (Import the logging.handlers module for advanced logging handlers like queue handling.)
import json
# 导入json库，用于处理JSON数据格式，日志将以此格式存储。 (Import the json library for handling JSON data format, as logs will be stored in this format.)
import datetime
# 导入datetime库，用于处理日期和时间，日志时间戳需要用到。 (Import the datetime library for handling dates and times, needed for log timestamps.)
import uuid
# 导入uuid库，用于生成唯一的标识符，如交易周期ID。 (Import the uuid library for generating unique identifiers, such as trade cycle IDs.)
import os
# 导入os库，用于与操作系统交互，如创建日志目录。 (Import the os library for interacting with the operating system, like creating log directories.)
import threading
# 导入threading库，虽然此处可能未使用，但异步日志有时会涉及。 (Import the threading library; although possibly unused here, async logging sometimes involves it.)
import queue
# 导入queue库，用于创建队列，是异步日志处理的核心组件。 (Import the queue library for creating queues, a core component of asynchronous logging.)
import pytz  # 用于处理时区
# 导入pytz库，用于处理时区信息，确保日志时间戳的一致性。 (Import the pytz library for handling timezone information, ensuring consistency in log timestamps.)
# ================= 日志系统所需导入 END ===================


# ================= 自定义 JSON Formatter START =================
class JsonFormatter(logging.Formatter):
    # 定义一个名为 JsonFormatter 的类，继承自 logging.Formatter，用于将日志记录格式化为 JSON 字符串。 (创建一个日志格式化工具，专门把日志信息变成 JSON 格式。)
    def format(self, record):
        # 定义 format 方法，负责将单个日志记录（record）转换为字符串。 (定义如何转换一条日志记录。)
        log_entry = {}
        # 创建一个空字典，用于存放最终的日志条目。 (准备一个空的盒子，放日志信息。)
        if isinstance(record.msg, dict):
            # 检查日志消息主体（record.msg）是否已经是字典格式。 (看看传进来的日志信息是不是已经是整理好的盒子了。)
            log_entry.update(record.msg)
            # 如果是字典，直接将其内容更新到 log_entry 中。 (如果是，直接把里面的东西倒进我们的最终盒子。)
        else:
            # 如果不是字典，将其作为 'message' 字段的值。 (如果不是，就把这条原始信息当作一个叫 'message' 的标签放进盒子里。)
            log_entry['message'] = record.getMessage()
            # 将原始日志消息作为 'message' 字段的值。 (Store the original log message under the 'message' key.)

        # 添加一些标准的日志记录信息，如果它们不在消息主体中。 (补充一些标准信息，比如时间、日志级别等，如果最终盒子里还没有的话。)
        if 'timestamp' not in log_entry:
            # 如果 'timestamp' 不在，添加 ISO 8601 格式的 UTC 时间戳。 (如果没记时间，就记下现在的 UTC 标准时间。)
            log_entry['timestamp'] = datetime.datetime.now(pytz.utc).isoformat() + 'Z'
            # 如果日志条目中没有 'timestamp' 键，则添加当前 UTC 时间的 ISO 格式字符串。 (If 'timestamp' key is not in the log entry, add the current UTC time in ISO format.)
        if 'level' not in log_entry:
            # 如果 'level' 不在，添加日志级别名称（例如 'INFO', 'ERROR'）。 (如果没记重要程度，就记一下。)
            log_entry['level'] = record.levelname
            # 如果日志条目中没有 'level' 键，则添加日志级别名称。 (If 'level' key is not in the log entry, add the log level name.)
        if hasattr(record, 'strategy_id') and 'strategy_id' not in log_entry:
             # 如果记录对象有 strategy_id 属性且最终日志条目没有，添加它。 (如果记录里有策略 ID 但最终盒子里没有，加上。)
            log_entry['strategy_id'] = record.strategy_id
            # 如果日志记录对象有 strategy_id 属性且日志条目中没有，则添加它。 (If the log record object has a strategy_id attribute and it's not in the log entry, add it.)
        if hasattr(record, 'data_id') and 'data_id' not in log_entry:
            # 如果记录对象有 data_id 属性且最终日志条目没有，添加它。 (如果记录里有数据 ID 但最终盒子里没有，加上。)
            log_entry['data_id'] = record.data_id
            # 如果日志记录对象有 data_id 属性且日志条目中没有，则添加它。 (If the log record object has a data_id attribute and it's not in the log entry, add it.)

        # 处理日志记录中的异常信息。 (如果记录中有错误信息，也加到盒子里。)
        if record.exc_info:
            # 如果存在异常信息。
            if not record.exc_text:
                # 如果异常文本不存在，则格式化异常信息。
                record.exc_text = self.formatException(record.exc_info)
                # 如果记录中有异常信息但没有格式化文本，则格式化它。 (If the record has exception info but no formatted text, format it.)
        if record.exc_text:
            # 如果异常文本存在，将其添加到日志条目中。
            log_entry['exception'] = record.exc_text
            # 如果格式化后的异常文本存在，将其添加到日志条目中。 (If the formatted exception text exists, add it to the log entry.)
        if record.stack_info:
             # 如果存在堆栈信息，格式化并添加到日志条目中。
            log_entry['stack_trace'] = self.formatStack(record.stack_info)
            # 如果记录中有堆栈信息，格式化并添加到日志条目中。 (If the record has stack info, format it and add it to the log entry.)

        # 将字典转换为 JSON 字符串，确保使用 ASCII 编码并按键排序。 (把整理好的盒子里的所有东西变成一行 JSON 文本。)
        return json.dumps(log_entry, sort_keys=True, ensure_ascii=False)
        # 将最终的日志字典转换为 JSON 字符串，按键排序且不强制 ASCII 编码。 (Convert the final log dictionary to a JSON string, with sorted keys and without ensuring ASCII.)

# ================= 自定义 JSON Formatter END ===================

# ================== 日志队列处理线程 START ==================
# (这个部分是异步写入日志的核心，确保日志写入不阻塞策略运行)
log_queue = queue.Queue(-1)  # 使用无限大小的队列 (创建一个队列，用来临时存放日志)
# 创建一个无限大小的队列用于存储待处理的日志记录。 (Create an infinitely sized queue to store pending log records.)
log_listener = None # 初始化日志监听器变量 (准备一个监听器，后面会用到)
# 初始化全局变量 log_listener 为 None。 (Initialize the global variable log_listener to None.)

def setup_log_listener(handler):
    # 定义一个函数来设置和启动日志监听器。 (定义一个启动监听器的函数。)
    """Sets up and starts the log listener thread."""
    # """设置并启动日志监听器线程。"""
    global log_listener
    # 声明 log_listener 是全局变量。 (告诉程序我们要用全局的那个监听器。)
    log_listener = logging.handlers.QueueListener(log_queue, handler, respect_handler_level=True)
    # 创建 QueueListener 实例，连接队列和处理器。 (创建监听器，让它看着队列，并告诉它日志要交给哪个处理器处理。)
    # 创建 QueueListener 实例，它会监听 log_queue 并将记录传递给指定的 handler。 (Create a QueueListener instance that listens to log_queue and passes records to the specified handler.)
    log_listener.start()
    # 启动监听器线程。 (让监听器开始工作。)
    # 启动监听器线程，开始处理队列中的日志记录。 (Start the listener thread to begin processing log records from the queue.)

def stop_log_listener():
    # 定义一个函数来停止日志监听器。 (定义一个停止监听器的函数。)
    """Stops the log listener thread."""
    # """停止日志监听器线程。"""
    global log_listener
    # 声明 log_listener 是全局变量。 (告诉程序我们要用全局的那个监听器。)
    if log_listener:
        # 如果监听器存在。 (如果监听器在工作。)
        # print("Attempting to stop log listener...") # 调试信息 (Debug message)
        log_listener.stop()
        # 停止监听器线程。 (让监听器停止工作。)
        # print("Log listener stopped.") # 调试信息 (Debug message)
        log_listener = None # 重置变量 (Reset variable)
        # 将 log_listener 重置为 None。 (Reset log_listener to None.)
# ================== 日志队列处理线程 END ==================


class AShareETFStrategy(bt.Strategy):
    # 定义一个名为AShareETFStrategy的类，它继承自bt.Strategy，表示这是一个Backtrader交易策略类。 (创建一个叫做AShareETFStrategy的策略类，它继承了bt.Strategy，说明这是个交易策略。)
    params = (
        ('ema_short_period', 10),  # 短期EMA周期 (Short-term EMA period)
        # 定义短期指数移动平均线的周期参数，默认值为10。 (Define the period parameter for the short-term Exponential Moving Average, default value is 10.)
        ('ema_medium_period', 30), # 中期EMA周期 (Medium-term EMA period)
        # 定义中期指数移动平均线的周期参数，默认值为30。 (Define the period parameter for the medium-term Exponential Moving Average, default value is 30.)
        ('ema_long_period', 60),  # 长期EMA周期 (Long-term EMA period)
        # 定义长期指数移动平均线的周期参数，默认值为60。 (Define the period parameter for the long-term Exponential Moving Average, default value is 60.)
        ('bbands_period', 20),    # 布林带周期 (Bollinger Bands period)
        # 定义布林带计算周期参数，默认值为20。 (Define the period parameter for Bollinger Bands calculation, default value is 20.)
        ('bbands_devfactor', 2.0),# 布林带标准差因子 (Bollinger Bands standard deviation factor)
        # 定义布林带通道宽度（标准差倍数）参数，默认值为2.0。 (Define the parameter for Bollinger Bands channel width (standard deviation multiplier), default value is 2.0.)
        ('atr_period', 14),       # ATR周期 (ATR period)
        # 定义平均真实波幅（ATR）计算周期参数，默认值为14。 (Define the period parameter for Average True Range (ATR) calculation, default value is 14.)
        ('atr_multiplier', 3.0),  # ATR止损乘数 (ATR stop loss multiplier)
        # 定义ATR止损计算中使用的乘数因子，默认值为3.0。 (Define the multiplier factor used in ATR stop loss calculation, default value is 3.0.)
        ('risk_per_trade_percent', 1.0), # 单笔交易风险百分比 (Risk percentage per trade)
        # 定义单笔交易允许承担的最大风险占总资产的百分比，默认值为1.0%。 (Define the maximum risk percentage of total assets allowed per single trade, default value is 1.0%.)
        ('max_total_risk_percent', 10.0),# 最大总风险百分比 (Maximum total risk percentage)
        # 定义整个策略允许承担的最大累积风险占总资产的百分比，默认值为10.0%。 (Define the maximum cumulative risk percentage of total assets allowed for the entire strategy, default value is 10.0%.)
        ('max_open_trades', 5),       # 最大同时持仓数量 (Maximum number of simultaneous open trades)
        # 定义策略允许同时持有的最大未平仓交易数量，默认值为5。 (Define the maximum number of open trades the strategy is allowed to hold simultaneously, default value is 5.)
        ('max_drawdown_percent', 20.0), # 最大可接受回撤百分比 (Maximum acceptable drawdown percentage)
        # 定义策略可接受的最大资金回撤百分比，默认值为20.0%。 (Define the maximum acceptable portfolio drawdown percentage for the strategy, default value is 20.0%.)
        ('halt_duration_days', 5) ,   # 触发风控后的暂停交易天数 (Trading halt duration in days after risk trigger)
        # 定义触发风险控制（如最大回撤）后暂停交易的天数，默认值为5天。 (Define the number of days trading is halted after a risk control trigger (e.g., max drawdown), default value is 5 days.)
        # ================= 日志系统参数 START =================
        ('log_path', 'logs'), # 日志文件存放目录 (日志文件放哪里)
        # 定义日志文件的存储目录，默认为 'logs'。 (Define the directory where log files will be stored, default is 'logs'.)
        ('log_filename_pattern', '{strategy_name}_{data_name}_{timestamp:%Y%m%d_%H%M%S}.log.jsonl'), # 日志文件名格式模板 (日志文件叫什么名字的规则)
        # 定义日志文件名的格式模板，包含策略名、数据名和时间戳。 (Define the format template for log filenames, including strategy name, data name, and timestamp.)
        ('log_level', logging.INFO), # 日志记录级别 (记录多详细的信息，INFO级别比较常用)
        # 定义日志记录的最低级别，默认为 INFO。 (Define the minimum logging level, default is INFO.)
        # ================= 日志系统参数 END ===================
    )
    # 定义策略的参数，包括EMA周期、布林带设置、ATR设置、风险管理参数等。 (Define the strategy parameters, including EMA periods, Bollinger Bands settings, ATR settings, risk management parameters, etc.)


    # ==================== 日志系统核心方法 START ====================
    def _setup_logger(self):
        # 定义一个私有方法 _setup_logger，用于配置和初始化日志记录器。 (定义一个内部工具，用来设置好日志系统。)
        """Sets up the logging system for the strategy."""
        # """为策略设置日志系统。"""
        self.strategy_id = f"{self.__class__.__name__}_{uuid.uuid4().hex[:8]}"
        # 为当前策略实例生成一个唯一的标识符。 (给这个策略起个独一无二的名字，加一串随机码防重复。)
        # Generate a unique identifier for the current strategy instance.
        self.logger = logging.getLogger(self.strategy_id)
        # 获取一个特定于此策略实例的日志记录器。 (拿到这个策略专属的记事本。)
        # Get a logger instance specific to this strategy instance.
        self.logger.setLevel(self.p.log_level)
        # 设置日志记录器的级别。 (设定这个记事本记录信息的详细程度。)
        # Set the logging level for the logger.

        # 防止重复添加处理器，特别是在优化运行时。 (避免重复设置记事本的写入方式。)
        # Prevent adding handlers multiple times, especially during optimization runs.
        if self.logger.hasHandlers():
            # 如果记录器已经有关联的处理器。
            # In optimization, __init__ might be called multiple times for the same logger name.
            # 清理旧的处理器，以防万一。
            # (在优化模式下，同一个策略名可能会初始化多次，先把旧的设置清理掉。)
            # for h in self.logger.handlers[:]:
            #     self.logger.removeHandler(h)
            # 通常不需要清理，因为 getLogger 会返回同一个实例。主要问题是重复添加。
            # (通常不需要清理，因为getLogger会返回同一个记事本实例，主要是避免重复添加写入方式。)
            # 如果已经有 QueueHandler，则假设已经设置好了
            # (If a QueueHandler already exists, assume setup is done)
            if any(isinstance(h, logging.handlers.QueueHandler) for h in self.logger.handlers):
                 # 检查是否已有队列处理器。 (检查是否已经设置了异步写入方式。)
                 # Check if a QueueHandler already exists.
                 # print(f"Logger {self.strategy_id} already has QueueHandler. Skipping setup.") # 用于调试 (打印调试信息)
                 # Print debug message.
                 return # 如果有，则跳过后续设置。 (如果已经有了，就不用再设了。)
                 # If yes, skip the rest of the setup.


        # --- 文件处理器和格式化器 ---
        # --- File Handler and Formatter ---
        log_dir = self.p.log_path
        # 获取日志目录路径。 (拿到日志文件夹的名字。)
        # Get the log directory path from parameters.
        os.makedirs(log_dir, exist_ok=True)
        # 创建日志目录，如果目录已存在则忽略。 (确保这个文件夹存在，没有就创建一个。)
        # Create the log directory if it doesn't exist.

        # 构建日志文件名 (Construct the log filename)
        now_str = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
        # 获取当前时间字符串。 (拿到现在的时间，格式化成年月日_时分秒。)
        # Get the current time string.
        data_name_part = "multi_data" if len(self.datas) > 1 else self.datas[0]._name if self.datas else "no_data"
        # 根据数据源数量确定文件名中的数据部分。 (看看有几个数据源，如果多于一个就叫 multi_data，只有一个就用它的名字，没有就叫 no_data。)
        # Determine the data name part based on the number of data feeds.
        log_filename = self.p.log_filename_pattern.format(
            strategy_name=self.__class__.__name__,
            # 格式化文件名模板中的策略名称部分。 (Format the strategy name part of the filename template.)
            data_name=data_name_part,
            # 格式化文件名模板中的数据名称部分。 (Format the data name part of the filename template.)
            timestamp=datetime.datetime.now() # 使用当前时间对象进行格式化 (用当前时间格式化文件名模板。)
            # 格式化文件名模板中的时间戳部分。 (Format the timestamp part of the filename template using the current datetime object.)
            # pid=os.getpid() # 可选：添加进程ID (Optional: Add process ID)
            # Optional: Add process ID to the filename.
        )
        # 格式化日志文件名模板。 (按照规则拼出完整的日志文件名。)
        # Format the log filename using the template and parameters.
        log_filepath = os.path.join(log_dir, log_filename)
        # 拼接日志目录和文件名得到完整路径。 (把文件夹名和文件名组合成完整路径。)
        # Join the directory and filename to get the full log file path.

        # --- 异步日志处理设置 ---
        # (Async logging setup)
        json_formatter = JsonFormatter()
        # 创建自定义的 JSON 格式化器实例。 (创建我们前面定义的 JSON 格式化工具。)
        # Create an instance of the custom JSON formatter.

        # 文件处理器 - 这是最终写入文件的处理器
        # (File handler - this is the handler that writes to the file)
        file_handler = logging.FileHandler(log_filepath, encoding='utf-8')
        # 创建一个文件处理器，指定文件路径和编码。 (创建一个写入文件的工具，告诉它写到哪个文件，用什么编码。)
        # Create a file handler, specifying the file path and encoding.
        file_handler.setFormatter(json_formatter)
        # 为文件处理器设置 JSON 格式化器。 (告诉这个写入工具，要用 JSON 格式写。)
        # Set the JSON formatter for the file handler.

        # 队列处理器 - 将日志发送到队列
        # (Queue handler - sends logs to the queue)
        queue_handler = logging.handlers.QueueHandler(log_queue)
        # 创建一个队列处理器，将日志记录放入全局队列 log_queue。 (创建一个队列处理器，它负责把日志先扔到队列里。)
        # Create a queue handler that puts log records into the global log_queue.

        # 将队列处理器添加到策略的 logger
        # (Add the queue handler to the strategy's logger)
        self.logger.addHandler(queue_handler)
        # 将队列处理器添加到策略的日志记录器中。 (把这个“扔队列”的工具装到策略的记事本上。)
        # Add the queue handler to the strategy's logger.

        # 设置并启动监听器（如果尚未启动）
        # (Setup and start the listener (if not already started))
        global log_listener
        # 声明 log_listener 是全局变量。 (告诉程序我们要用全局的那个监听器。)
        # Declare log_listener as a global variable.
        if log_listener is None or not log_listener.is_alive(): # 检查监听器是否已启动 (Check if listener is already running)
            # Check if the listener exists and is running.
            # print(f"Setting up log listener for handler: {file_handler}") # 用于调试 (打印调试信息)
            # Print debug message.
            setup_log_listener(file_handler) # 启动监听器，将文件处理器传给它 (Start the listener, passing the file handler to it)
            # Start the listener, passing the file handler to it.
            # print(f"Log listener started.") # 用于调试 (打印调试信息)
            # Print debug message.
        # else:
            # print(f"Log listener already running.") # 用于调试 (打印调试信息)
            # Print debug message.

        # 记录日志系统初始化完成
        # (Log that the logging system initialization is complete)
        self.log_event('LOGGER_INITIALIZED', details={'log_filepath': log_filepath})
        # 调用 log_event 记录一条初始化完成的日志。 (写一条日志，说日志系统已经准备好了。)
        # Log an event indicating that the logger is initialized, including the log file path.


    def log_event(self, event_type, data_feed=None, **kwargs):
        # 定义 log_event 方法，用于记录结构化的日志事件。 (定义一个专门用来记录各种事件的工具。)
        """Logs a structured event."""
        # """记录一个结构化事件。"""
        try:
            # 尝试执行日志记录逻辑。 (试试看能不能记日志。)
            # Try executing the logging logic.
            log_entry = {
                # 'timestamp': datetime.datetime.now(pytz.utc).isoformat() + 'Z', # 使用 UTC 时间 (Use UTC time)
                # Get the current UTC time in ISO format.
                 'timestamp': self.datas[0].datetime.datetime(0).isoformat() if self.datas and len(self.datas[0]) else datetime.datetime.now(pytz.utc).isoformat() + 'Z', # 优先使用回测时间 (Prefer backtest time)
                 # 优先使用第一个数据源的当前回测时间，如果不可用则使用当前UTC时间。 (Prefer the current backtest time from the first data feed; use current UTC time if unavailable.)
                'event_type': event_type, # 事件类型 (Event type)
                # Set the event type.
                'strategy_id': getattr(self, 'strategy_id', 'unknown'), # 策略实例 ID (Strategy instance ID)
                # Get the strategy ID, default to 'unknown' if not set.
                'data_id': data_feed._name if data_feed else getattr(self.data, '_name', 'default_data'), # 数据源名称 (Data feed name)
                # Get the data feed name, using the provided feed or the default one.
            }
            # 创建基础日志条目字典，包含标准字段。 (创建一个日志的基本信息盒子，放上时间、事件类型、策略ID、数据ID。)
            # Create the base log entry dictionary with standard fields.

            # 尝试添加交易周期ID (Try to add trade cycle ID)
            # Try to add the trade cycle ID.
            if hasattr(self, 'current_trade_id') and self.current_trade_id:
                # 如果当前策略实例有 'current_trade_id' 属性且不为空。 (如果现在有一个正在进行的交易追踪号。)
                # If the strategy instance has a non-empty 'current_trade_id' attribute.
                log_entry['trade_cycle_id'] = self.current_trade_id
                # 将其添加到日志条目中。 (把这个追踪号也放进盒子。)
                # Add it to the log entry.
            elif 'order_ref' in kwargs and hasattr(self, 'order_ref_to_trade_id_map'):
                 # 如果没有进行中的追踪号，但事件信息里有订单引用号 (order_ref)，并且策略有订单引用号到交易ID的映射表。 (如果没有进行中的追踪号，但是这次事件跟某个订单有关，并且我们有订单号到追踪号的对应表。)
                 # If no current trade ID, but kwargs contain 'order_ref' and the mapping exists.
                 trade_id = self.order_ref_to_trade_id_map.get(kwargs['order_ref'], None)
                 # 尝试从映射表中查找对应的交易周期ID。 (去对应表里查查这个订单号对应的追踪号。)
                 # Try to find the corresponding trade cycle ID from the map.
                 if trade_id:
                     # 如果找到了。 (如果查到了。)
                     # If found.
                     log_entry['trade_cycle_id'] = trade_id
                     # 将找到的交易周期ID添加到日志条目中。 (把找到的追踪号放进盒子。)
                     # Add the found trade cycle ID to the log entry.
                 # else:
                 #     log_entry['trade_cycle_id'] = 'ORPHANED_ORDER_EVENT' # 可选：标记孤儿订单事件 (Optional: Mark orphan order event)
                 #     # Optional: Mark as an orphan order event if not found.

            # 合并额外的关键字参数 (Merge additional keyword arguments)
            log_entry.update(kwargs)
            # 将调用时传入的其他信息（kwargs）也添加到日志条目中。 (把调用这个记录工具时附带的其他信息也放进盒子。)
            # Merge any additional keyword arguments passed to the function into the log entry.

            # 使用附加信息调用 logger，以便 formatter 可以访问它们
            # (Call logger with extra info so formatter can access them)
            # self.logger.info(log_entry, extra={'strategy_id': log_entry['strategy_id'], 'data_id': log_entry.get('data_id')})
            # Call the logger with extra information so the formatter can access it.
            # 直接传递完整的字典给 info，让 JsonFormatter 处理
            # (Pass the complete dictionary directly to info, let JsonFormatter handle it)
            self.logger.info(log_entry)
            # 调用日志记录器的 info 方法记录日志。 (用记事本的“记录”功能把这个盒子里的信息记下来。)
            # Log the complete log entry dictionary using the logger's info method.

        except Exception as e:
            # 如果在记录日志时发生任何错误。 (如果在记日志的时候出错了。)
            # If any error occurs during logging.
            # Ensure logging errors don't crash the strategy
            # 确保日志错误不会导致策略崩溃
            import sys
            # 导入 sys 模块以访问标准错误流。 (导入 sys 工具包，用来往控制台打错误信息。)
            # Import the sys module to access standard error.
            print(f"CRITICAL: Logging failed! Event: {event_type}, Error: {e}", file=sys.stderr)
            # 在标准错误流中打印错误信息。 (在控制台打印严重的错误信息，说明记日志失败了。)
            # Print a critical error message to standard error.
            # Optionally, log to a fallback logger or handle differently
            # 可选地，记录到备用日志记录器或以其他方式处理
            # Optionally, log to a fallback logger or handle the error differently.

    # ==================== 日志系统核心方法 END ======================

    def log(self, txt, dt=None, data=None):
        # 定义 log 方法，用于简单的文本日志记录（保留原有方法，但建议使用 log_event）。 (定义一个简单的文本记录方法，兼容旧代码，但推荐用新的 log_event。)
        ''' Logging function for this strategy'''
        # '''此策略的日志记录功能'''
        # 使用 log_event 记录简单消息
        # (Log simple messages using log_event)
        log_dt = dt or self.datas[0].datetime.date(0)
        # 获取日志时间戳，优先使用传入的 dt，否则使用第一个数据源的当前日期。 (拿到日志时间，有传入的就用，没有就用第一个数据的日期。)
        # Get the log timestamp, preferring the passed dt, otherwise use the date from the first data feed.
        # print('%s, %s' % (log_dt.isoformat(), txt)) # 旧的打印方式 (Old print method)
        # Old print method.
        self.log_event('LEGACY_LOG', message=txt, log_timestamp=log_dt.isoformat())
        # 调用 log_event 记录，事件类型为 'LEGACY_LOG'。 (用新的 log_event 来记录，类型标记为旧日志。)
        # Call log_event to record the message with type 'LEGACY_LOG'.


    def __init__(self, **kwargs):  # 接受 **kwargs 以兼容 addstrategy 传递的参数 (Accept **kwargs to be compatible with parameters passed by addstrategy)
        # 定义策略的初始化函数__init__，在策略对象创建时自动执行。 (定义策略初始化要做的事情。)
        # Define the strategy initialization function __init__, executed automatically when the strategy object is created.

        # --- 初始化日志系统 ---
        # (Initialize logging system)
        self._setup_logger() # 调用内部方法设置日志记录器 (Call internal method to set up the logger)
        # Call the internal method to set up the logger.
        self.log_event('STRATEGY_INIT_START') # 记录初始化开始 (Log initialization start)
        # Log the start of the strategy initialization.


        # --- 初始化交易周期 ID 管理 ---
        # (Initialize trade cycle ID management)
        self.order_ref_to_trade_id_map = {} # 订单引用到交易周期ID的映射 (Mapping from order reference to trade cycle ID)
        # Initialize an empty dictionary to map order references to trade cycle IDs.
        self.current_trade_id = None # 当前活跃的交易周期ID (Currently active trade cycle ID)
        # Initialize the currently active trade cycle ID to None.


        # 引用数据源。 (Reference the data feeds.)
        # Keep a reference to the "close" line in the data[0] dataseries
        # self.dataclose = self.datas[0].close # 原有代码 (Original code)
        # Original code referencing only the first data's close line.
        # 引用所有数据源的收盘价、开盘价、最高价、最低价 (Reference close, open, high, low prices for all data feeds)
        self.d_close = {d._name: d.close for d in self.datas}
        # 创建一个字典，存储每个数据源名称到其收盘价序列的映射。 (创建一个字典，记录每个数据源名字和它的收盘价数据。)
        # Create a dictionary mapping each data feed name to its close price series.
        self.d_open = {d._name: d.open for d in self.datas}
        # 创建一个字典，存储每个数据源名称到其开盘价序列的映射。 (创建一个字典，记录每个数据源名字和它的开盘价数据。)
        # Create a dictionary mapping each data feed name to its open price series.
        self.d_high = {d._name: d.high for d in self.datas}
        # 创建一个字典，存储每个数据源名称到其最高价序列的映射。 (创建一个字典，记录每个数据源名字和它的最高价数据。)
        # Create a dictionary mapping each data feed name to its high price series.
        self.d_low = {d._name: d.low for d in self.datas}
        # 创建一个字典，存储每个数据源名称到其最低价序列的映射。 (创建一个字典，记录每个数据源名字和它的最低价数据。)
        # Create a dictionary mapping each data feed name to its low price series.

        # 引用主要数据源（第一个）以便快速访问，如果存在的话
        # (Reference the primary data feed (the first one) for quick access if it exists)
        self.data = self.datas[0] if self.datas else None
        # 将第一个数据源赋值给 self.data，如果数据源列表不为空。 (如果至少有一个数据源，把第一个存到 self.data 方便使用。)
        # Assign the first data feed to self.data if the data feeds list is not empty.
        self.dataclose = self.data.close if self.data else None # 保持原有 self.dataclose 的兼容性 (Maintain compatibility with original self.dataclose)
        # 如果 self.data 存在，将其收盘价序列赋值给 self.dataclose，保持旧代码兼容性。 (如果 self.data 有东西，把它的收盘价存到 self.dataclose，兼容旧代码。)
        # Assign the close series of self.data to self.dataclose if self.data exists, for backward compatibility.


        # To keep track of pending orders and buy price/commission
        # 跟踪待处理订单和买入价格/佣金 (To keep track of pending orders and buy price/commission)
        self.order = None
        # 初始化 self.order 为 None，用于跟踪最近的待处理订单。 (初始化一个变量 self.order，用来记住最近还没完成的订单。)
        # Initialize self.order to None, used to track the most recent pending order.
        self.buyprice = None
        # 初始化 self.buyprice 为 None，用于记录买入价格。 (初始化一个变量 self.buyprice，用来记买入价。)
        # Initialize self.buyprice to None, used to record the buy price.
        self.buycomm = None
        # 初始化 self.buycomm 为 None，用于记录买入佣金。 (初始化一个变量 self.buycomm，用来记买入佣金。)
        # Initialize self.buycomm to None, used to record the buy commission.

        # 实例化指标 (Instantiate Indicators)
        # self.sma_short = bt.indicators.SimpleMovingAverage(self.datas[0], period=self.params.ema_short_period) # 原有代码 (Original code)
        # self.sma_medium = bt.indicators.SimpleMovingAverage(self.datas[0], period=self.params.ema_medium_period) # 原有代码 (Original code)
        # self.sma_long = bt.indicators.SimpleMovingAverage(self.datas[0], period=self.params.ema_long_period) # 原有代码 (Original code)
        # self.bbands = bt.indicators.BollingerBands(self.datas[0], period=self.params.bbands_period, devfactor=self.params.bbands_devfactor) # 原有代码 (Original code)

        # 为每个数据源创建指标实例 (Create indicator instances for each data feed)
        self.inds = {}
        # 初始化一个空字典 self.inds，用于存储每个数据源的指标。 (准备一个空盒子 self.inds，用来放每个数据源对应的指标工具。)
        # Initialize an empty dictionary self.inds to store indicators for each data feed.
        for d in self.datas:
            # 遍历所有数据源。 (检查每一个数据源。)
            # Iterate through all data feeds.
            self.inds[d._name] = {} # 为每个数据源创建一个内部字典 (Create an inner dictionary for each data feed)
            # 在 self.inds 中为当前数据源 d 创建一个专属的小盒子。 (给当前数据源 d 在 self.inds 里创建一个专属小盒子。)
            # Create an inner dictionary for the current data feed d within self.inds.

            # 使用 self.p 访问参数 (Access parameters using self.p)
            self.inds[d._name]['ema_short'] = bt.indicators.ExponentialMovingAverage(d, period=self.p.ema_short_period)
            # 创建短期 EMA 指标实例，并存入对应数据源的小盒子。 (创建短期 EMA 指标，放到对应数据源的小盒子里。)
            # Create a short-term EMA indicator instance and store it in the dictionary for the corresponding data feed.
            self.inds[d._name]['ema_medium'] = bt.indicators.ExponentialMovingAverage(d, period=self.p.ema_medium_period)
            # 创建中期 EMA 指标实例，并存入对应数据源的小盒子。 (创建中期 EMA 指标，放到对应数据源的小盒子里。)
            # Create a medium-term EMA indicator instance and store it.
            self.inds[d._name]['ema_long'] = bt.indicators.ExponentialMovingAverage(d, period=self.p.ema_long_period)
            # 创建长期 EMA 指标实例，并存入对应数据源的小盒子。 (创建长期 EMA 指标，放到对应数据源的小盒子里。)
            # Create a long-term EMA indicator instance and store it.
            self.inds[d._name]['bbands'] = bt.indicators.BollingerBands(d, period=self.p.bbands_period, devfactor=self.p.bbands_devfactor)
            # 创建布林带指标实例，并存入对应数据源的小盒子。 (创建布林带指标，放到对应数据源的小盒子里。)
            # Create a Bollinger Bands indicator instance and store it.
            self.inds[d._name]['atr'] = bt.indicators.AverageTrueRange(d, period=self.p.atr_period)
            # 创建 ATR 指标实例，并存入对应数据源的小盒子。 (创建 ATR 指标，放到对应数据源的小盒子里。)
            # Create an Average True Range (ATR) indicator instance and store it.

        # 风险管理相关变量 (Risk management related variables)
        self.halt_trading_until = None # 暂停交易直到指定时间戳 (Halt trading until specified timestamp)
        # 初始化 self.halt_trading_until 为 None，标记当前是否处于暂停交易状态。 (初始化一个标记，表示现在没暂停交易。)
        # Initialize self.halt_trading_until to None, marking if trading is currently halted.
        self.cumulative_risk_units = 0.0 # 累积风险单位 (Cumulative risk units)
        # 初始化 self.cumulative_risk_units 为 0.0，记录当前累积的总风险。 (初始化一个计数器，记录总共承担了多少风险。)
        # Initialize self.cumulative_risk_units to 0.0, tracking the total accumulated risk.
        self.open_trades = 0 # 当前持仓交易数量 (Number of currently open trades)
        # 初始化 self.open_trades 为 0，记录当前有多少笔交易还在进行中。 (初始化一个计数器，记录当前有几单在手。)
        # Initialize self.open_trades to 0, tracking the number of currently open trades.
        self.initial_portfolio_value = self.broker.getvalue() # 记录初始投资组合价值 (Record initial portfolio value)
        # 记录策略开始时的总资产。 (记一下开始时有多少钱。)
        # Record the initial portfolio value at the start of the strategy.
        self.high_water_mark = self.initial_portfolio_value # 记录最高水位线 (Record high water mark)
        # 初始化最高水位线为初始总资产。 (记一下历史最高赚到过多少钱，初始就是本金。)
        # Initialize the high water mark to the initial portfolio value.

        # 使用 kwargs 更新参数，如果它们在 params 中定义了
        # (Update parameters using kwargs if they are defined in params)
        for key, value in kwargs.items():
            # 遍历从 addstrategy 传入的参数。 (检查通过 addstrategy 传进来的每个参数。)
            # Iterate through the parameters passed via addstrategy.
            if hasattr(self.params, key):
                # 如果这个参数是策略本身定义的参数之一。 (如果这个参数是咱们策略认识的。)
                # If this parameter is one defined by the strategy itself.
                setattr(self.params, key, value)
                # 更新策略参数的值。 (那就更新一下这个参数的值。)
                # Update the value of the strategy parameter.
                self.log_event('PARAM_OVERRIDE', param_key=key, param_value=value)
                # 记录参数被覆盖的事件。 (记一笔日志，说这个参数被传进来的值覆盖了。)
                # Log an event indicating that the parameter was overridden.
            # else:
                # self.log_event('UNKNOWN_PARAM_PASSED', param_key=key, param_value=value) # 可选：记录未知参数 (Optional: log unknown parameters)
                # Optional: Log an event if an unknown parameter was passed.

        # 记录策略初始化完成和参数
        # (Log strategy initialization completion and parameters)
        param_dict = {p: getattr(self.params, p) for p in dir(self.params) if not p.startswith('_') and not callable(getattr(self.params, p))}
        # 获取所有策略参数及其值，过滤掉内部属性和方法。 (Get all strategy parameters and their values, filtering out internal attributes and methods.)
        # Get all strategy parameters and their values into a dictionary, filtering out internal attributes and methods.
        data_ids = [d._name for d in self.datas]
        # 获取所有数据源的名称列表。 (拿到所有数据源的名字。)
        # Get a list of names for all data feeds.
        self.log_event('STRATEGY_INIT_COMPLETE', params=param_dict, data_ids=data_ids)
        # 记录策略初始化完成事件，包含参数和数据源信息。 (记录一条日志，说策略初始化完成了，并附上所有参数和数据源名字。)
        # Log an event indicating strategy initialization is complete, including parameters and data feed names.

    def notify_order(self, order):
        # 定义订单状态通知函数notify_order，当订单状态发生变化时被调用，参数order是订单对象。 (定义订单通知函数，当订单状态变化的时候，程序会跑这个函数来通知你。)
        # Define the order notification function notify_order, called when order status changes, parameter order is the order object.

        # --- 日志记录：订单状态更新 ---
        # (Logging: Order Status Update)
        trade_id = self.order_ref_to_trade_id_map.get(order.ref, 'ORPHANED_ORDER') # 尝试获取交易周期ID (Try to get trade cycle ID)
        # 查找这个订单对应的交易追踪号，找不到就标记为“孤儿订单”。 (查一下这个订单是哪个交易的，查不到就标为“孤儿”。)
        # Try to get the trade cycle ID for this order; mark as 'ORPHANED_ORDER' if not found.
        exec_details = {}
        # 初始化一个空字典，用于存放订单执行详情。 (准备一个空盒子，放订单执行细节。)
        # Initialize an empty dictionary to store order execution details.
        if order.executed.price:
            # 如果订单有执行价格。 (如果订单成交了。)
            # If the order has an execution price.
            exec_details['price'] = order.executed.price
            # 记录执行价格。 (记下成交价。)
            # Record the execution price.
            exec_details['value'] = order.executed.value
            # 记录执行价值。 (记下成交金额。)
            # Record the execution value.
            exec_details['commission'] = order.executed.comm
            # 记录执行佣金。 (记下佣金。)
            # Record the execution commission.
            exec_details['size'] = order.executed.size # 已执行数量 (Executed size)
            # 记录已执行数量。 (记下成交了多少。)
            # Record the executed size.
        self.log_event('ORDER_STATUS_UPDATE',
                       data_feed=order.data, # 关联数据源 (Associate data feed)
                       # Associate the data feed.
                       order_ref=order.ref, # 订单引用 (Order reference)
                       # Include the order reference.
                       trade_cycle_id=trade_id, # 使用查找到的交易ID (Use the retrieved trade ID)
                       # Use the retrieved trade ID.
                       status=order.getstatusname(), # 订单状态名称 (Order status name)
                       # Include the order status name.
                       exec_details=exec_details if exec_details else None, # 执行详情（如果存在） (Execution details (if any))
                       # Include execution details if they exist.
                       remaining_size=order.executed.remsize, # 剩余未执行数量 (Remaining size)
                       # Include the remaining size.
                       order_type=order.ordtypename(), # 订单类型 (Order type)
                       # Include the order type name.
                       order_details={ # 订单创建时的细节 (Details from order creation)
                           # Include details from the order creation phase.
                           'created_price': order.created.price, # 创建时价格 (Creation price)
                           # Creation price.
                           'created_size': order.created.size, # 创建时大小 (Creation size)
                           # Creation size.
                           'isbuy': order.isbuy(), # 是否是买单 (Is it a buy order?)
                           # Is it a buy order?
                           'issell': order.issell() # 是否是卖单 (Is it a sell order?)
                           # Is it a sell order?
                       })
        # 记录订单状态更新事件，包含各种详细信息。 (记录订单状态变化的日志，包括追踪号、状态、成交细节等。)
        # Log the ORDER_STATUS_UPDATE event with various details.


        if order.status in [order.Submitted, order.Accepted]:
            # Buy/Sell order submitted/accepted to/by broker - Nothing to do
            # 如果订单是已提交或已接受状态，无需操作。 (如果订单只是刚提交或者被接受了，暂时不用做什么。)
            # If the order status is Submitted or Accepted, do nothing.
            # self.log(f'Order {order.ref} Submitted/Accepted', data=order.data) # 旧日志 (Old log)
            # Old log message.
            return
            # Exit the function.

        # Check if an order has been completed
        # 检查订单是否已完成 (Check if an order has been completed)
        # Attention: broker could reject order if not enough cash
        # 注意：如果现金不足，经纪商可能会拒绝订单 (Attention: broker could reject order if not enough cash)
        if order.status in [order.Completed]:
            # 如果订单状态是已完成。 (如果订单完成了。)
            # If the order status is Completed.
            if order.isbuy():
                # 如果是买单。 (如果是买单。)
                # If it's a buy order.
                # self.log(
                #     f'BUY EXECUTED, Price: {order.executed.price:.2f}, Cost: {order.executed.value:.2f}, Comm {order.executed.comm:.2f}',
                #     data=order.data
                # ) # 旧日志 (Old log)
                # Old log message for buy execution.
                self.buyprice = order.executed.price
                # 记录买入价格。 (记下买入价。)
                # Record the buy price.
                self.buycomm = order.executed.comm
                # 记录买入佣金。 (记下买入佣金。)
                # Record the buy commission.
                self.open_trades += 1 # 增加持仓交易计数 (Increment open trades count)
                # 当前持仓交易数量加 1。 (手上的单子数量加 1。)
                # Increment the count of open trades.
                # risk_per_trade = self.params.risk_per_trade_percent * self.broker.getvalue() / 100.0
                # self.cumulative_risk_units += risk_per_trade # 累加风险 (Accumulate risk) - 移动到下单处更准确 (Moved to order placement for accuracy)
                # self.log_event('RISK_UPDATE_ON_BUY', current_risk_units=self.cumulative_risk_units, added_risk=risk_per_trade, data_feed=order.data)

            elif order.issell():
                # 如果是卖单。 (如果是卖单。)
                # If it's a sell order.
                # self.log(f'SELL EXECUTED, Price: {order.executed.price:.2f}, Cost: {order.executed.value:.2f}, Comm {order.executed.comm:.2f}', data=order.data) # 旧日志 (Old log)
                # Old log message for sell execution.
                self.open_trades -= 1 # 减少持仓交易计数 (Decrement open trades count)
                # 当前持仓交易数量减 1。 (手上的单子数量减 1。)
                # Decrement the count of open trades.
                # --- 风险在 notify_trade 中根据 PNL 释放或调整更合理 ---
                # --- Risk adjustment based on PNL in notify_trade is more appropriate ---
                # closed_trade_risk = ??? # 难以直接在此处确定关闭交易的初始风险 (Difficult to determine initial risk here)
                # self.cumulative_risk_units -= closed_trade_risk # 释放风险 (Release risk)
                # self.log_event('RISK_UPDATE_ON_SELL', current_risk_units=self.cumulative_risk_units, released_risk=closed_trade_risk, data_feed=order.data)


            self.bar_executed = len(self) # 记录执行时的 K 线索引 (Record bar index when executed)
            # 记下这笔交易完成时是第几根 K 线。 (记下完成时是第几根 K 线。)
            # Record the bar index when the order was executed.

        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            # 如果订单被取消、因保证金不足或被拒绝。 (如果订单被取消、钱不够或者被拒了。)
            # If the order status is Canceled, Margin, or Rejected.
            # self.log(f'Order {order.ref} Canceled/Margin/Rejected', data=order.data) # 旧日志 (Old log)
            # Old log message for failed/canceled order.
            # --- 如果是开仓订单失败，需要考虑回滚风险累加 ---
            # --- If an opening order fails, need to consider rolling back risk accumulation ---
            trade_id_for_failed_order = self.order_ref_to_trade_id_map.get(order.ref)
            # 获取失败订单对应的交易 ID。 (拿到这个失败订单的交易追踪号。)
            # Get the trade ID associated with the failed order.
            if trade_id_for_failed_order and trade_id_for_failed_order == self.current_trade_id:
                # 如果找到了交易 ID 且它就是当前正在尝试的交易。 (如果找到了追踪号，而且就是我们当前正在操作的这个。)
                # If a trade ID was found and it matches the current trade ID (meaning this was the opening order).
                # 这是一个尝试开新仓但失败的订单 (This was an attempt to open a new position that failed)
                # 重置 current_trade_id，因为这个交易周期并未成功开启
                # (Reset current_trade_id as this trade cycle didn't successfully start)
                self.current_trade_id = None
                # 把当前交易追踪号清空，因为这个交易没开始成功。)
                # Reset the current trade ID because the trade cycle didn't start successfully.
                # 注意：风险计算的逻辑需要根据具体实现来调整 (Note: Risk calculation logic needs adjustment based on specific implementation)
                # Note: Risk calculation logic might need adjustments here.
                # self.log_event('TRADE_CYCLE_ABORTED', reason=order.getstatusname(), order_ref=order.ref, data_feed=order.data)
                # Log an event indicating the trade cycle was aborted.

            # 清理映射 (Clean up mapping)
            # Clean up the order reference mapping.
            if order.ref in self.order_ref_to_trade_id_map:
                # 如果订单引用在映射表中。 (如果订单号在我们的对应表里。)
                # If the order reference is in the mapping dictionary.
                del self.order_ref_to_trade_id_map[order.ref]
                # 从映射表中删除该订单引用。 (把它从对应表里删掉。)
                # Delete it from the mapping dictionary.
                # self.log_event('ORDER_REF_MAP_CLEANUP', reason='Order Failed/Cancelled', order_ref=order.ref, data_feed=order.data) # 可选日志 (Optional log)
                # Optional: Log the cleanup event.


        # Write down: no pending order
        # 标记：没有待处理订单 (Write down: no pending order)
        self.order = None
        # 将 self.order 设置为 None，表示当前没有待处理订单。 (把 self.order 清空，表示现在没有订单在等结果了。)
        # Set self.order to None, indicating no pending order.

    def notify_trade(self, trade):
        # 定义交易通知函数notify_trade，当交易（一买一卖）完成时被调用，参数trade是交易对象。 (定义交易完成通知函数，当一次完整的买卖结束了，程序会跑这个函数来通知你。)
        # Define the trade notification function notify_trade, called when a trade (buy and sell) is completed, parameter trade is the trade object.

        # --- 日志记录：交易关闭/更新 ---
        # (Logging: Trade Closed/Update)
        trade_id = 'UNKNOWN_TRADE' # 默认交易 ID (Default trade ID)
        # 设置一个默认的交易追踪号。 (先假设不知道是哪个交易。)
        # Set a default trade ID.
        order_refs_in_trade = [] # 存储交易涉及的订单引用 (Store order references involved in the trade)
        # 准备一个列表，放这个交易涉及到的所有订单号。 (准备一个空列表，放这次交易用到的所有订单号。)
        # Initialize an empty list to store order references involved in this trade.

        # 尝试从 trade 对象获取关联的订单引用 (Try getting associated order references from the trade object)
        associated_orders = getattr(trade, 'orders', []) # Backtrader >= 1.9.77.123
        # 获取与此交易关联的订单列表（适用于较新版本的 Backtrader）。 (Get the list of orders associated with this trade (for newer Backtrader versions).)
        if not associated_orders and hasattr(trade, '_orders'): # 兼容旧版 (Compatibility for older versions)
             associated_orders = trade._orders
             # 兼容旧版本，尝试从 _orders 属性获取。 (Compatibility for older versions, try getting from _orders attribute.)
        elif not associated_orders and hasattr(trade, 'order') and trade.order: # 更旧的版本可能只有一个订单 (Even older versions might have only one order)
             associated_orders = [trade.order]
             # 更旧的版本可能只有一个 order 属性。 (Even older versions might just have a single order attribute.)

        if associated_orders:
            # 如果找到了关联的订单。 (If associated orders were found.)
            order_refs_in_trade = [o.ref for o in associated_orders if o]
            # 获取所有有效订单的引用号。 (Get the reference numbers of all valid associated orders.)
            if order_refs_in_trade:
                # 如果引用号列表不为空。 (If the list of references is not empty.)
                # 尝试从第一个订单引用获取交易ID (Try to get trade ID from the first order reference)
                trade_id = self.order_ref_to_trade_id_map.get(order_refs_in_trade[0], f'ORPHANED_TRADE_{order_refs_in_trade[0]}')
                # 尝试用第一个订单号去查交易追踪号，找不到就标记为“孤儿交易”并附带订单号。 (Try using the first order reference to find the trade ID; mark as 'ORPHANED_TRADE' with the ref if not found.)
        elif hasattr(trade, 'ref'): # 如果没有订单列表，尝试使用 trade.ref (If no order list, try using trade.ref)
             # 如果 trade 对象没有 orders 属性，但有 ref 属性。 (If the trade object doesn't have an orders attribute, but has a ref attribute.)
             order_refs_in_trade = [trade.ref]
             # 将单个引用放入列表。 (Put the single reference into the list.)
             trade_id = self.order_ref_to_trade_id_map.get(trade.ref, f'ORPHANED_TRADE_{trade.ref}')
             # 尝试使用 trade.ref 查找交易追踪号。 (Try using trade.ref to find the trade ID.)


        if not trade.isclosed:
            # 如果交易尚未关闭（例如部分平仓更新）。 (如果这笔交易还没完全结束（比如只平了一部分仓）。)
            # If the trade is not yet closed (e.g., partially closed update).
            # 记录交易更新事件 (Log trade update event)
            self.log_event('TRADE_UPDATE',
                           data_feed=trade.data, # 关联数据源 (Associate data feed)
                           # Associate data feed.
                           trade_cycle_id=trade_id, # 交易周期ID (Trade cycle ID)
                           # Trade cycle ID.
                           trade_ref=trade.ref, # 交易引用 (Trade reference)
                           # Trade reference.
                           status=trade.status_names[trade.status], # 交易状态 (Trade status)
                           # Trade status name.
                           size=trade.size, # 当前大小 (Current size)
                           # Current size.
                           price=trade.price, # 当前价格 (Current price)
                           # Current price.
                           value=trade.value, # 当前价值 (Current value)
                           # Current value.
                           pnl=trade.pnl, # 当前 PNL (Current PNL)
                           # Current PNL.
                           pnlcomm=trade.pnlcomm, # 当前净 PNL (Current net PNL)
                           # Current net PNL.
                           commission=trade.commission # 累积佣金 (Accumulated commission)
                           # Accumulated commission.
                          )
            # 记录交易更新的日志。 (记录交易更新的日志。)
            # Log the TRADE_UPDATE event.
            return # 返回，因为交易还未结束 (Return as the trade is not yet finished)
            # 交易还没结束，先不往下走了。 (交易还没完，先停在这里。)
            # Return because the trade is not finished yet.

        # --- 交易已关闭 ---
        # (Trade is closed)
        # self.log(f'OPERATION PROFIT, GROSS {trade.pnl:.2f}, NET {trade.pnlcomm:.2f}', data=trade.data) # 旧日志 (Old log)
        # Old log message for profit.

        self.log_event('TRADE_CLOSED',
                       data_feed=trade.data, # 关联数据源 (Associate data feed)
                       # Associate data feed.
                       trade_cycle_id=trade_id, # 交易周期ID (Trade cycle ID)
                       # Trade cycle ID.
                       trade_ref=trade.ref, # 交易引用 (Trade reference)
                       # Trade reference.
                       pnl=trade.pnl, # 毛利润/亏损 (Gross profit/loss)
                       # Gross PNL.
                       pnlcomm=trade.pnlcomm, # 净利润/亏损 (Net profit/loss)
                       # Net PNL.
                       commission=trade.commission, # 总佣金 (Total commission)
                       # Total commission.
                       duration_bars=trade.barlen, # 持仓 K 线数 (Duration in bars)
                       # Duration in bars.
                       open_datetime=trade.open_datetime().isoformat() if trade.dtopen else None, # 开仓时间 (Open datetime)
                       # Open datetime (ISO format).
                       close_datetime=trade.close_datetime().isoformat() if trade.dtclose else None, # 平仓时间 (Close datetime)
                       # Close datetime (ISO format).
                       size=trade.size, # 最终大小（应为0） (Final size (should be 0))
                       # Final size (should be 0).
                       initial_size = trade.history[0].event.size if trade.history else None, # 初始开仓大小 (Initial open size)
                       # Initial opening size (from history if available).
                       position_type='Long' if getattr(trade, 'long', trade.size > 0) else 'Short' # 交易方向 (Position type) - 兼容性处理
                       # Position type (Long/Short), with compatibility handling.
                      )
        # 记录交易关闭事件，包含盈亏、时长等信息。 (记录交易关闭的日志，包括赚了多少钱、持了多久等。)
        # Log the TRADE_CLOSED event with PNL, duration, etc.


        # --- 清理 trade_cycle_id 映射 ---
        # (Clean up trade_cycle_id mapping)
        cleaned_refs = [] # 记录已清理的引用 (Record cleaned references)
        # 准备一个列表，记录删掉了哪些订单号。 (准备一个列表，记下删了哪些订单号。)
        # Initialize a list to record cleaned references.
        if not trade_id.startswith('ORPHANED_TRADE') and trade_id != 'UNKNOWN_TRADE':
             # 如果交易不是孤儿或未知。 (如果这个交易不是孤儿或者未知的。)
             # If the trade is not orphaned or unknown.
             # 找到所有与此交易周期ID关联的订单引用（需要迭代整个映射）
             # (Find all order references associated with this trade cycle ID (requires iterating the map))
             refs_to_remove = [ref for ref, t_id in self.order_ref_to_trade_id_map.items() if t_id == trade_id]
             # 找到所有与此交易周期ID关联的订单引用。 (找出对应表里所有属于这个交易追踪号的订单号。)
             # Find all order references associated with this trade ID.
             for ref in refs_to_remove:
                 # 遍历找到的订单引用。 (检查每一个找到的订单号。)
                 # Iterate through the found references.
                 # print(f"DEBUG: Removing {ref} for trade_id {trade_id} due to trade close.") # 调试
                 del self.order_ref_to_trade_id_map[ref]
                 # 从映射表中删除。 (从对应表里删掉。)
                 # Delete from the mapping dictionary.
                 cleaned_refs.append(ref)
                 # 添加到已清理列表。 (记一下这个订单号被删了。)
                 # Add to the list of cleaned references.

             # 如果这个关闭的交易是当前活跃的交易，则重置 current_trade_id
             # (If this closed trade was the currently active one, reset current_trade_id)
             if self.current_trade_id == trade_id:
                 # 如果关闭的这个正好是当前正在进行的交易。 (如果关掉的正好是当前进行的这个。)
                 # If the closed trade was the currently active one.
                 # print(f"DEBUG: Resetting current_trade_id from {self.current_trade_id} due to trade close.") # 调试
                 self.current_trade_id = None
                 # 将当前交易追踪号设为 None。 (把当前交易追踪号清空。)
                 # Reset the current trade ID.
                 # self.log_event('CURRENT_TRADE_CYCLE_CLOSED', closed_trade_id=trade_id, data_feed=trade.data) # 可选日志 (Optional log)
                 # Optional: Log the closing of the current trade cycle.
        # else: # 对于孤儿交易，也尝试清理其关联的订单引用（如果存在）
            # For orphaned trades, also try to clean up their associated order refs if they exist in the map
            # for ref in order_refs_in_trade:
            #      if ref in self.order_ref_to_trade_id_map:
            #           # print(f"DEBUG: Removing orphaned ref {ref} found in trade.orders during trade close.") # 调试
            #           del self.order_ref_to_trade_id_map[ref]
            #           cleaned_refs.append(ref)

        # if cleaned_refs: # 仅当实际清理了引用时记录 (Log only if references were actually cleaned)
        #      self.log_event('ORDER_REF_MAP_CLEANUP', reason='Trade Closed', cleaned_refs=cleaned_refs, trade_id=trade_id, data_feed=trade.data) # 可选日志 (Optional log)
        #      # Optional: Log the cleanup event only if references were cleaned.


        # --- 更新风险状态 ---
        # (Update risk status)
        # 交易关闭，风险单位清零或根据策略调整 (Trade closed, risk units reset or adjusted based on strategy)
        # 这里假设每个关闭的交易完全释放其初始风险，需要改进 (Assuming each closed trade fully releases its initial risk, needs improvement)
        # 更复杂的逻辑可能需要跟踪每个交易的初始风险 (More complex logic might need to track initial risk per trade)
        # self.cumulative_risk_units = max(0.0, self.cumulative_risk_units - ???) # 需要确定释放多少风险 (Need to determine how much risk to release)
        # self.log_event('RISK_UPDATE_ON_TRADE_CLOSE', current_risk_units=self.cumulative_risk_units, pnlcomm=trade.pnlcomm, data_feed=trade.data)

        # 更新最高水位线 (Update high water mark)
        current_value = self.broker.getvalue()
        # 获取当前投资组合价值。 (拿到现在的总资产。)
        # Get the current portfolio value.
        if current_value > self.high_water_mark:
            # 如果当前总资产超过了历史最高。 (如果现在的钱比以前最多的时候还多。)
            # If the current value exceeds the high water mark.
            # self.log_event('HIGH_WATER_MARK_UPDATE', old_hwm=self.high_water_mark, new_hwm=current_value, data_feed=trade.data) # 可选日志 (Optional log)
            # Optional: Log the high water mark update.
            self.high_water_mark = current_value
            # 更新最高水位线。 (更新历史最高纪录。)
            # Update the high water mark.

    def notify_cashvalue(self, cash, value):
        # 定义现金和总价值通知函数notify_cashvalue，在账户现金或总价值更新时被调用，参数cash是当前现金，value是当前总价值。 (定义现金和总资产值通知函数，当账户里的钱或者总资产变化的时候，程序会跑这个函数来通知你。)
        # Define the cash and value notification function notify_cashvalue, called when account cash or total value updates, cash is current cash, value is current total value.
        # self.log(f'Cash {cash:.2f}, Value {value:.2f}', dt=self.datas[0].datetime.datetime(0)) # 旧日志 (Old log)

        # --- 记录账户价值更新 ---
        # (Log Account Value Update)
        self.log_event('ACCOUNT_VALUE_UPDATE', cash=cash, value=value)
        # 记录账户价值更新事件。 (Record the account value update event.)

        # --- 在这里检查最大回撤更合适 ---
        # (Checking max drawdown here is more appropriate)
        current_drawdown = (self.high_water_mark - value) / self.high_water_mark if self.high_water_mark > 0 else 0.0
        # 计算当前回撤百分比。 (Calculate the current drawdown percentage.)
        self.log_event('DRAWDOWN_CHECK', current_value=value, high_water_mark=self.high_water_mark, current_drawdown_pct=current_drawdown * 100)
        # 记录回撤检查事件。 (Log the drawdown check event.)

        if current_drawdown > self.p.max_drawdown_percent / 100.0 and not self.halt_trading_until: # 仅在未暂停时触发 (Only trigger if not already halted)
            # 如果当前回撤超过阈值且当前未处于暂停状态。 (If current drawdown exceeds threshold and not currently halted.)
            # 触发风控暂停交易 (Trigger risk control trading halt)
            halt_duration = datetime.timedelta(days=self.p.halt_duration_days)
            # 计算暂停持续时间。 (Calculate the halt duration.)
            current_dt = self.datas[0].datetime.datetime(0)
            # 获取当前回测时间。 (Get the current backtest datetime.)
            self.halt_trading_until = current_dt + halt_duration
            # 设置暂停交易的截止时间。 (Set the time until which trading is halted.)
            self.log_event('RISK_EVENT_HALT_TRIGGERED',
                           event_subtype='MAX_DRAWDOWN',
                           # 事件子类型：最大回撤。 (Event subtype: MAX_DRAWDOWN.)
                           account_value=value,
                           # 当前账户价值。 (Current account value.)
                           cash=cash,
                           # 当前现金。 (Current cash.)
                           high_water_mark=self.high_water_mark,
                           # 最高水位线。 (High water mark.)
                           drawdown_pct=current_drawdown * 100,
                           # 当前回撤百分比。 (Current drawdown percentage.)
                           limit_pct=self.p.max_drawdown_percent,
                           # 回撤限制百分比。 (Drawdown limit percentage.)
                           halt_until=self.halt_trading_until.isoformat(),
                           # 暂停交易截止时间。 (Halt until timestamp.)
                           reason=f"Current drawdown {current_drawdown*100:.2f}% exceeded limit {self.p.max_drawdown_percent}%")
            # 记录风险事件：触发暂停交易。 (Log risk event: halt triggered.)

    def _calculate_trade_size(self, data_close_price, entry_price, stop_loss_price, risk_per_trade_percent, data=None):
        # 定义一个私有方法_calculate_trade_size，用于计算交易仓位大小，根据风险管理规则。 (定义一个计算交易仓位大小的小工具，根据风险控制规则来算。)
        # Define a private method _calculate_trade_size to calculate trade position size based on risk management rules.
        details = {} # 用于存储计算细节的字典 (Dictionary to store calculation details)
        # 初始化一个空字典用于存储计算细节。 (Initialize an empty dictionary to store calculation details.)
        adjustment_reasons = [] # 用于记录调整原因的列表 (List to record adjustment reasons)
        # 初始化一个空列表用于记录调整原因。 (Initialize an empty list to record adjustment reasons.)

        portfolio_value = self.broker.getvalue()
        # 获取当前投资组合的总价值。 (Get the current total portfolio value.)
        risk_amount = portfolio_value * (risk_per_trade_percent / 100.0)
        # 计算基于总价值和风险百分比得出的单笔交易风险金额。 (Calculate the risk amount for a single trade based on portfolio value and risk percentage.)
        price_diff = abs(entry_price - stop_loss_price)
        # 计算入场价格和止损价格之间的绝对差额。 (Calculate the absolute difference between entry price and stop loss price.)

        details['risk_inputs'] = { # 记录风险计算的输入值 (Record inputs for risk calculation)
            'portfolio_value': portfolio_value, # 投资组合价值 (Portfolio value)
            'risk_per_trade_percent': risk_per_trade_percent, # 单笔交易风险百分比 (Risk per trade percentage)
            'calculated_risk_amount': risk_amount, # 计算出的风险金额 (Calculated risk amount)
            'entry_price': entry_price, # 入场价 (Entry price)
            'stop_loss_price': stop_loss_price, # 止损价 (Stop loss price)
            'price_diff_per_share': price_diff # 每股价格差异 (Price difference per share)
        }
        # 将风险计算的输入值存入 details 字典。 (Store the inputs for risk calculation in the details dictionary.)

        if price_diff <= 1e-9: # 避免除以零或非常小的值 (Avoid division by zero or very small values)
             # 如果价格差异非常小（接近零）。 (If the price difference is very small (close to zero).)
             details['raw_size'] = 0
             # 原始计算大小设为0。 (Set raw calculated size to 0.)
             details['adjustment_reasons'] = ['Price difference for risk calculation is zero or too small']
             # 添加调整原因为价格差异过小。 (Add adjustment reason: price difference too small.)
             return {'size': 0, 'details': details} # 返回大小为0 (Return size 0)
             # 返回计算结果，大小为0。 (Return the calculation result with size 0.)

        size = int(risk_amount / price_diff)
        # 根据风险金额和价格差异计算初始仓位大小（向下取整）。 (Calculate the initial position size based on risk amount and price difference (integer division).)
        details['raw_size'] = size # 记录原始计算大小 (Record raw calculated size)
        # 记录计算出的原始大小。 (Record the raw calculated size.)

        # --- 考虑最小交易单位和资金限制 ---
        # --- Consider minimum trading unit and cash limits ---
        comminfo = self.broker.getcommissioninfo(data) if data else self.broker.getcommissioninfo(self.data)
        # 获取与数据关联的佣金信息对象。 (Get the commission information object associated with the data.)
        min_size = comminfo.get_minimum_size(price=entry_price) # 获取最小交易单位 (Get minimum trading unit)
        # 获取最小交易单位。 (Get the minimum trading unit.)

        if size < min_size:
             # 如果计算出的大小小于最小交易单位。 (If the calculated size is less than the minimum trading unit.)
             adjustment_reasons.append(f"Calculated size {size} < minimum size {min_size}")
             # 添加调整原因为小于最小单位。 (Add adjustment reason: less than minimum size.)
             size = 0 # 无法满足最小单位，设为0 (Cannot meet minimum unit, set to 0)
             # 将大小设为0，因为无法满足最小交易要求。 (Set size to 0 as the minimum requirement cannot be met.)
        else:
             # 如果大小满足最小单位要求。 (If the size meets the minimum unit requirement.)
             # 调整为最小单位的整数倍 (Adjust to an integer multiple of the minimum unit)
             size = (size // min_size) * min_size
             # 将大小调整为最小交易单位的整数倍（向下取整）。 (Adjust the size to be an integer multiple of the minimum unit (floor division).)
             if size != details['raw_size']: # 如果调整过 (If adjusted)
                  adjustment_reasons.append(f"Adjusted size to multiple of minimum size {min_size}")
                  # 如果大小被调整过，添加调整原因。 (If the size was adjusted, add the adjustment reason.)

        # 检查现金是否足够 (Check if cash is sufficient)
        cash_needed = comminfo.getvaluesize(size, entry_price) + comminfo.getcommission(size, entry_price)
        # 计算购买所需总现金（包括佣金）。 (Calculate the total cash needed for the purchase (including commission).)
        available_cash = self.broker.getcash()
        # 获取当前可用现金。 (Get the currently available cash.)

        if size > 0 and cash_needed > available_cash:
            # 如果计算出的有效大小所需现金超过可用现金。 (If the cash needed for the calculated valid size exceeds available cash.)
            adjustment_reasons.append(f"Insufficient cash. Needed: {cash_needed:.2f}, Available: {available_cash:.2f}")
            # 添加调整原因为现金不足。 (Add adjustment reason: insufficient cash.)
            # 尝试在现金允许范围内减小手数 (Try reducing lots within cash limits)
            affordable_size = comminfo.getsize(entry_price, available_cash * 0.99) # 留一点余地 (Leave some margin)
            # 计算在可用现金（留有余地）下能负担的最大大小。 (Calculate the maximum affordable size with available cash (leaving some margin).)
            affordable_size = (affordable_size // min_size) * min_size # 调整为最小单位倍数 (Adjust to minimum unit multiple)
            # 将可负担的大小调整为最小单位的整数倍。 (Adjust the affordable size to be a multiple of the minimum unit.)
            if affordable_size >= min_size:
                # 如果可负担的大小仍满足最小单位。 (If the affordable size still meets the minimum unit requirement.)
                adjustment_reasons.append(f"Reduced size from {size} to {affordable_size} due to cash limit")
                # 添加调整原因为现金限制而减小大小。 (Add adjustment reason: reduced size due to cash limit.)
                size = affordable_size
                # 更新最终大小为可负担的大小。 (Update the final size to the affordable size.)
            else:
                # 如果现金连最小单位都买不起。 (If cash is not enough even for the minimum unit.)
                size = 0 # 现金不足以购买最小单位 (Cash insufficient for minimum unit)
                # 将最终大小设为0。 (Set the final size to 0.)
                adjustment_reasons.append(f"Cash insufficient even for minimum size {min_size}")
                # 添加调整原因为现金不足以购买最小单位。 (Add adjustment reason: cash insufficient for minimum unit.)


        details['adjustment_reasons'] = adjustment_reasons # 存储调整原因 (Store adjustment reasons)
        # 将所有调整原因存入 details 字典。 (Store all adjustment reasons in the details dictionary.)
        details['final_size'] = size # 存储最终大小 (Store final size)
        # 将最终计算出的大小存入 details 字典。 (Store the final calculated size in the details dictionary.)
        details['cash_needed'] = cash_needed if size > 0 else 0 # 存储所需现金 (Store cash needed)
        # 存储最终大小所需的现金（如果大小为0则为0）。 (Store the cash needed for the final size (0 if size is 0).)
        details['available_cash'] = available_cash # 存储可用现金 (Store available cash)
        # 存储检查时的可用现金。 (Store the available cash at the time of checking.)

        return {'size': size, 'details': details}
        # 返回包含最终大小和计算细节的字典。 (Return a dictionary containing the final size and calculation details.)


    def next(self):
        # 定义next函数，在每个数据点（通常是每个交易日）都会被调用一次，用于执行策略的主要逻辑。 (定义next函数，这是策略的核心，每天开盘后都要运行一遍，决定今天该干啥。)
        # Define the next function, called once per data point (usually each trading day), for executing the main strategy logic.

        # --- 检查是否暂停交易 ---
        # (Check if trading is halted)
        current_dt = self.datas[0].datetime.datetime(0) # 获取当前时间 (Get current time)
        # 获取当前的回测时间。 (Get the current backtest datetime.)
        if self.halt_trading_until and current_dt < self.halt_trading_until:
            # 如果设置了暂停交易时间点，并且当前时间还没到那个点。 (如果之前设置了暂停交易，并且还没到恢复时间。)
            # If trading is halted and the current time is before the resume time.
            # self.log(f'Trading halted until {self.halt_trading_until}. Skipping bar.', dt=current_dt) # 旧日志 (Old log)
            # Old log message.
            self.log_event('TRADING_HALTED_SKIP', halt_until=self.halt_trading_until.isoformat(), current_time=current_dt.isoformat())
            # 记录交易暂停跳过事件。 (记一笔日志，说因为暂停交易，这根K线跳过了。)
            # Log an event indicating that trading is halted and the bar is skipped.
            return # 跳过当前 K 线 (Skip current bar)
            # 直接返回，不做任何操作。 (这根K线啥也不干。)
            # Return immediately, skipping any action for this bar.
        elif self.halt_trading_until and current_dt >= self.halt_trading_until:
            # 如果到了或超过了暂停交易的恢复时间点。 (如果到了或者超过了恢复时间。)
            # If the halt period is over.
            # self.log(f'Trading resumed at {current_dt}.', dt=current_dt) # 旧日志 (Old log)
            # Old log message.
            self.log_event('TRADING_RESUMED', resume_time=current_dt.isoformat(), previous_halt_until=self.halt_trading_until.isoformat())
            # 记录交易恢复事件。 (记一笔日志，说交易恢复了。)
            # Log an event indicating that trading has resumed.
            self.halt_trading_until = None # 清除暂停标记 (Clear halt flag)
            # 清除暂停交易的标记。 (把暂停标记去掉。)
            # Clear the halt flag.


        # --- 遍历所有数据源执行策略逻辑 ---
        # (Iterate through all data feeds to execute strategy logic)
        for d in self.datas:
            # 遍历每一个数据源。 (检查每一个我们关心的数据（比如不同的股票ETF）。)
            # Iterate through each data feed.
            data_name = d._name # 获取数据源名称 (Get data feed name)
            # 拿到当前数据源的名字。 (拿到当前这个数据的名字。)
            # Get the name of the current data feed.
            close = self.d_close[data_name][0] # 获取当前收盘价 (Get current close price)
            # 拿到当前这个数据的收盘价。 (拿到它的收盘价。)
            # Get the current close price for this data feed.
            # open_ = self.d_open[data_name][0] # 获取当前开盘价 (Get current open price)
            # high = self.d_high[data_name][0] # 获取当前最高价 (Get current high price)
            # low = self.d_low[data_name][0] # 获取当前最低价 (Get current low price)
            inds = self.inds[data_name] # 获取当前数据源的指标 (Get indicators for the current data feed)
            # 拿到当前这个数据对应的所有指标工具。 (拿到跟它相关的指标工具。)
            # Get the indicators associated with this data feed.

            # --- 记录市场状态评估 ---
            # (Log Market State Assessment)
            market_state_indicators = { # 收集用于市场判断的指标值 (Collect indicator values used for market judgment)
            # Collect key indicator values for market state assessment.
                'ema_short': inds['ema_short'][0] if len(inds['ema_short']) else None, # 短期 EMA (Short-term EMA)
                # Short-term EMA value (if available).
                'ema_medium': inds['ema_medium'][0] if len(inds['ema_medium']) else None, # 中期 EMA (Medium-term EMA)
                # Medium-term EMA value (if available).
                'ema_long': inds['ema_long'][0] if len(inds['ema_long']) else None, # 长期 EMA (Long-term EMA)
                # Long-term EMA value (if available).
                'bb_mid': inds['bbands'].lines.mid[0] if len(inds['bbands']) else None, # 布林带中轨 (Bollinger Bands Midline)
                # Bollinger Bands Midline value (if available).
                'bb_top': inds['bbands'].lines.top[0] if len(inds['bbands']) else None, # 布林带上轨 (Bollinger Bands Top)
                # Bollinger Bands Top value (if available).
                'bb_bot': inds['bbands'].lines.bot[0] if len(inds['bbands']) else None, # 布林带下轨 (Bollinger Bands Bottom)
                # Bollinger Bands Bottom value (if available).
                'atr': inds['atr'][0] if len(inds['atr']) else None # ATR
                # ATR value (if available).
            }
            # 把当前几个关键指标的值收集起来。 (把几个关键指标现在的值收在一起。)
            # Collect the current values of several key indicators.
            # 过滤掉值为 None 的指标 (Filter out indicators with None values)
            market_state_indicators = {k: v for k, v in market_state_indicators.items() if v is not None}
            # 移除值为 None 的指标，避免日志记录问题。 (Remove indicators with None values to prevent logging issues.)
            self.log_event('MARKET_STATE_ASSESSED', data_feed=d, indicators=market_state_indicators)
            # 记录市场状态评估事件。 (记一笔日志，说我们评估了市场状态，并附上指标值。)
            # Log the MARKET_STATE_ASSESSED event with the collected indicator values.

            # Check if an order is pending ... if yes, we cannot send a 2nd one
            # 检查是否有待处理订单...如果是，则不能发送第二个订单 (Check if an order is pending ... if yes, we cannot send a 2nd one)
            if self.order:
                # 如果 self.order 不是 None（即有待处理订单）。 (如果 self.order 里面有东西（说明有个订单还没完成）。)
                # If self.order is not None (i.e., there is a pending order).
                # self.log_event('PENDING_ORDER_SKIP', data_feed=d, order_ref=self.order.ref) # 可选日志 (Optional log)
                # Optional: Log that processing is skipped due to a pending order.
                continue # 跳过当前数据源的处理 (Skip processing for this data feed)
                # 跳过这个数据，处理下一个。 (这个数据先不处理了，去看下一个。)
                # Skip processing for this data feed and move to the next one.

            # Check if we are in the market
            # 检查我们是否在市场中（即是否持仓） (Check if we are in the market (i.e., holding a position))
            position_size = self.getposition(d).size
            # 获取当前数据源的持仓大小。 (看看当前这个数据我们手里有多少。)
            # Get the current position size for this data feed.

            # --- 定义入场和出场条件 ---
            # (Define entry and exit conditions)
            # 安全地访问指标值，处理潜在的未初始化情况 (Safely access indicator values, handling potential uninitialized cases)
            ema_short_val = inds['ema_short'][0] if len(inds['ema_short']) else np.nan
            # 获取短期EMA值，如果未初始化则为NaN。 (Get short-term EMA value, NaN if not initialized.)
            ema_medium_val = inds['ema_medium'][0] if len(inds['ema_medium']) else np.nan
            # 获取中期EMA值，如果未初始化则为NaN。 (Get medium-term EMA value, NaN if not initialized.)
            ema_long_val = inds['ema_long'][0] if len(inds['ema_long']) else np.nan
            # 获取长期EMA值，如果未初始化则为NaN。 (Get long-term EMA value, NaN if not initialized.)
            bb_mid_val = inds['bbands'].lines.mid[0] if len(inds['bbands']) else np.nan
            # 获取布林带中轨值，如果未初始化则为NaN。 (Get Bollinger Bands Midline value, NaN if not initialized.)

            # 检查指标值是否有效 (Check if indicator values are valid)
            indicators_ready = not (np.isnan(ema_short_val) or np.isnan(ema_medium_val) or np.isnan(ema_long_val) or np.isnan(bb_mid_val))
            # 判断所有关键指标是否都有有效值。 (Check if all key indicators have valid (non-NaN) values.)
            if not indicators_ready:
                 # self.log_event('INDICATOR_NOT_READY_SKIP', data_feed=d, indicators=market_state_indicators) # 可选日志 (Optional log)
                 continue # 指标未就绪，跳过此数据 (Indicators not ready, skip this data)
                 # 如果指标未就绪，跳过当前数据源的处理。 (If indicators are not ready, skip processing for this data feed.)

            # 计算条件 (Calculate conditions)
            is_bullish = ema_short_val > ema_medium_val and ema_medium_val > ema_long_val # 牛市条件 (Bullish condition)
            # 判断是不是牛市：短期线在中期线之上，中期线在长期线之上。 (判断是不是牛市：短期均线上穿中期，中期上穿长期。)
            # Bullish condition: Short EMA > Medium EMA > Long EMA.
            is_bearish = ema_short_val < ema_medium_val and ema_medium_val < ema_long_val # 熊市条件 (Bearish condition)
            # 判断是不是熊市：短期线在中期线之下，中期线在长期线之下。 (判断是不是熊市：短期均线下穿中期，中期下穿长期。)
            # Bearish condition: Short EMA < Medium EMA < Long EMA.
            cross_up_medium = bt.indicators.CrossOver(inds['ema_short'], inds['ema_medium'])[0] > 0 if len(inds['ema_short']) and len(inds['ema_medium']) else False # 短期上穿中期 (Short crosses over medium)
            # 判断短期线是否刚刚上穿中期线（需要确保指标已初始化）。 (判断短期 EMA 是不是刚上穿中期 EMA (ensure indicators are initialized).)
            # Check if short EMA just crossed over medium EMA (ensure indicators are initialized).
            cross_down_medium = bt.indicators.CrossDown(inds['ema_short'], inds['ema_medium'])[0] > 0 if len(inds['ema_short']) and len(inds['ema_medium']) else False # 短期下穿中期 (Short crosses down medium)
            # 判断短期线是否刚刚下穿中期线（需要确保指标已初始化）。 (判断短期 EMA 是不是刚下穿中期 EMA (ensure indicators are initialized).)
            # Check if short EMA just crossed down medium EMA (ensure indicators are initialized).
            close_over_bb_mid = close > bb_mid_val # 收盘价在布林中轨之上 (Close price is above Bollinger midline)
            # 判断收盘价是否在布林带中轨之上。 (判断收盘价是不是在中轨上面。)
            # Check if close price is above Bollinger midline.
            close_under_bb_mid = close < bb_mid_val # 收盘价在布林中轨之下 (Close price is below Bollinger midline)
            # 判断收盘价是否在布林带中轨之下。 (判断收盘价是不是在中轨下面。)
            # Check if close price is below Bollinger midline.

            # --- 计算止损位和潜在入场价 ---
            # (Calculate stop loss level and potential entry price)
            atr_val = inds['atr'][0] if len(inds['atr']) else np.nan # 获取 ATR 值 (Get ATR value)
            # 拿到当前的 ATR 值（如果已初始化）。 (拿到现在的 ATR (if initialized).)
            # Get the current ATR value (if initialized).
            if np.isnan(atr_val):
                 # self.log_event('ATR_NOT_READY_SKIP', data_feed=d) # 可选日志 (Optional log)
                 continue # ATR 未就绪，无法计算止损 (ATR not ready, cannot calculate stop loss)
                 # 如果 ATR 未就绪，跳过当前数据源。 (If ATR is not ready, skip this data feed.)

            stop_loss_long = close - self.p.atr_multiplier * atr_val # 多头止损位 (Long stop loss level)
            # 计算做多的止损价位。 (算一下做多的止损价。)
            # Calculate the stop loss level for a long position.
            stop_loss_short = close + self.p.atr_multiplier * atr_val # 空头止损位 (Short stop loss level)
            # 计算做空的止损价位。 (算一下做空的止损价。)
            # Calculate the stop loss level for a short position.
            entry_price = close # 假设以收盘价入场 (Assume entry at close price)
            # 假设用收盘价进场。 (假设按收盘价买入/卖出。)
            # Assume entry at the current close price.

            # --- 风险检查 ---
            # (Risk Check)
            can_trade = True # 默认可以交易 (Default can trade)
            # 先假设可以交易。 (先假设能交易。)
            # Assume trading is possible by default.
            risk_check_details = {} # 存储风险检查细节 (Store risk check details)
            # 准备一个盒子放风险检查的细节。 (准备一个空盒子放风险检查的细节。)
            # Initialize a dictionary to store risk check details.

            # 1. 检查最大总风险 (Check maximum total risk) - 仅在尝试开新仓时检查 (Only check when trying to open a new position)
            if not position_size: # 仅在没有持仓时检查开仓风险 (Only check opening risk when not in position)
                # 如果当前没有持仓。 (If not currently holding a position.)
                portfolio_value = self.broker.getvalue() # 获取当前投资组合价值 (Get current portfolio value)
                # 拿到当前的总资产。 (拿到现在的总资产。)
                # Get the current portfolio value.
                potential_risk_percent = self.p.risk_per_trade_percent # 本次交易风险百分比 (Risk percentage for this trade)
                # 这次交易打算承担多少风险（百分比）。 (这次交易计划承担的风险比例。)
                # Get the risk percentage for this potential trade.
                potential_risk_value = portfolio_value * potential_risk_percent / 100.0 # 本次交易风险金额 (Risk amount for this trade)
                # 这次交易打算承担多少风险（金额）。 (这次交易计划承担的风险金额。)
                # Calculate the risk amount for this potential trade.
                max_allowed_total_risk = portfolio_value * self.p.max_total_risk_percent / 100.0
                # 计算允许的最大总风险金额。 (Calculate the maximum allowed total risk amount.)

                if self.cumulative_risk_units + potential_risk_value > max_allowed_total_risk:
                    # 如果当前累积风险加上这次潜在风险，超过了设定的最大总风险比例。 (如果目前总风险加上这次的，超过了我们设定的总风险上限。)
                    # If the current cumulative risk plus the potential risk exceeds the maximum allowed total risk.
                    can_trade = False # 不可交易 (Cannot trade)
                    # 不能交易。 (那就不能交易。)
                    # Cannot trade.
                    risk_check_details['reason'] = 'MAX_TOTAL_RISK_EXCEEDED' # 原因：超过最大总风险 (Reason: Maximum total risk exceeded)
                    # 记下原因：总风险超标。 (记下原因：总风险超了。)
                    # Record the reason: maximum total risk exceeded.
                    risk_check_details['cumulative'] = self.cumulative_risk_units # 当前累积风险 (Current cumulative risk)
                    # 记下当前的累积风险。 (记下现在的总风险。)
                    # Record the current cumulative risk.
                    risk_check_details['potential'] = potential_risk_value # 本次潜在风险 (Potential risk for this trade)
                    # 记下这次交易的潜在风险。 (记下这次的潜在风险。)
                    # Record the potential risk for this trade.
                    risk_check_details['limit'] = max_allowed_total_risk # 总风险限额 (Total risk limit)
                    # 记下总风险的上限。 (记下总风险的上限。)
                    # Record the total risk limit.


            # 2. 检查最大持仓数量 (Check maximum number of open trades) - 仅在尝试开新仓时检查 (Only check when trying to open a new position)
            if can_trade and not position_size and self.open_trades >= self.p.max_open_trades:
                 # 如果前面检查通过，并且当前没有持仓，但是已开仓数量达到了最大限制。 (如果前面检查没问题，现在手里没这个数据，但总共开的单子数量已经到顶了。)
                 # If the previous check passed, not currently in position, and the number of open trades reached the maximum limit.
                 can_trade = False # 不可交易 (Cannot trade)
                 # 不能交易。 (不能再开新单了。)
                 # Cannot trade.
                 risk_check_details['reason'] = 'MAX_OPEN_TRADES_REACHED' # 原因：达到最大持仓数量 (Reason: Maximum open trades reached)
                 # 记下原因：开单数量到顶了。 (记下原因：开单数量满了。)
                 # Record the reason: maximum open trades reached.
                 risk_check_details['open_trades'] = self.open_trades # 当前持仓数量 (Current open trades)
                 # 记下当前开了多少单。 (记下现在开了几单。)
                 # Record the current number of open trades.
                 risk_check_details['limit'] = self.p.max_open_trades # 最大持仓限额 (Maximum open trades limit)
                 # 记下最大能开几单。 (记下最多能开几单。)
                 # Record the maximum open trades limit.


            # 3. 最大回撤检查已移至 notify_cashvalue (Max drawdown check moved to notify_cashvalue)
            # Max drawdown check is now handled in notify_cashvalue.


            # --- 主要交易逻辑 ---
            # (Main Trading Logic)
            if not position_size: # 没有持仓 (No position)
                # 如果当前没有持有这个数据。 (如果手里没这个货。)
                # If there is no current position in this data feed.

                # --- 潜在入场信号 ---
                # (Potential Entry Signals)
                entry_signal_type = None # 初始化入场信号类型 (Initialize entry signal type)
                # 先假设没有入场信号。 (先假设没信号。)
                # Initialize entry signal type to None.
                triggering_data = {} # 存储触发信号的数据 (Store data that triggered the signal)
                # 准备一个盒子放触发信号的具体数据。 (准备一个盒子放触发信号的数据。)
                # Initialize a dictionary to store data that triggered the signal.
                stop_loss_price = np.nan # 初始化止损价 (Initialize stop loss price)
                # Initialize stop loss price to NaN.
                is_buy = None # 初始化交易方向 (Initialize trade direction)
                # Initialize trade direction to None.

                if is_bullish and cross_up_medium and close_over_bb_mid: # 多头入场信号 (Long entry signal)
                     # 如果是牛市、短期线上穿中期线、且收盘价在中轨之上。 (如果是牛市，短期均线刚上穿中期，并且收盘价在中轨之上。)
                     # If bullish condition, short EMA crossed over medium, and close is above BB midline.
                     entry_signal_type = 'EMA_Cross_BB_Confirm_Long' # 信号类型 (Signal type)
                     # 信号类型：EMA金叉+BB确认做多。 (信号是：EMA金叉+BB确认做多。)
                     # Set signal type: EMA Golden Cross + BB Confirmation Long.
                     triggering_data = {'close': close, 'ema_short': ema_short_val, 'ema_medium': ema_medium_val, 'bb_mid': bb_mid_val}
                     # 记录触发时的价格和指标值。 (记下触发时的价格和指标值。)
                     # Record the triggering price and indicator values.
                     stop_loss_price = stop_loss_long # 使用多头止损 (Use long stop loss)
                     # 用做多的止损价。 (用多头止损。)
                     # Use the long stop loss price.
                     is_buy = True # 标记为买入 (Mark as buy)
                     # 标记是买入操作。 (标记这是买入。)
                     # Mark as a buy operation.

                # elif is_bearish and cross_down_medium and close_under_bb_mid: # 空头入场信号（如果允许做空） (Short entry signal (if shorting allowed))
                #     # 如果是熊市、短期线下穿中期线、且收盘价在中轨之下。 (如果是熊市，短期均线刚下穿中期，并且收盘价在中轨之下。)
                #     # If bearish condition, short EMA crossed down medium, and close is below BB midline.
                #     # 注意：示例策略可能不包含做空逻辑 (Note: Example strategy might not include shorting logic)
                #     # Note: The example strategy might not include shorting logic.
                #     # entry_signal_type = 'EMA_Cross_BB_Confirm_Short'
                #     # Set signal type: EMA Death Cross + BB Confirmation Short.
                #     # triggering_data = {'close': close, 'ema_short': ema_short_val, 'ema_medium': ema_medium_val, 'bb_mid': bb_mid_val}
                #     # Record triggering data.
                #     # stop_loss_price = stop_loss_short
                #     # Use short stop loss price.
                #     # is_buy = False
                #     # Mark as a sell (short) operation.
                #     pass # 暂不处理做空 (Do not handle shorting for now)
                #     # 暂时不做空。 (暂时不做空。)
                #     # Do not handle shorting for now.


                # --- 如果有入场信号并且风控检查通过 ---
                # (If there is an entry signal and risk checks passed)
                if entry_signal_type and can_trade:
                    # 如果探测到了入场信号，并且风险检查也通过了。 (如果有进场信号，而且风险检查也过了。)
                    # If an entry signal was detected and risk checks passed.

                    # == 生成新的交易周期 ID ==
                    # (Generate new trade cycle ID)
                    self.current_trade_id = self._generate_trade_cycle_id()
                    # 生成一个新的交易追踪号，并存起来。 (生成一个新的交易追踪号，记下来。)
                    # Generate and store a new trade cycle ID.
                    # print(f"DEBUG: Generated trade_id {self.current_trade_id} for signal {entry_signal_type} on {d._name}") # 调试

                    # 记录信号触发事件 (Log signal triggered event)
                    self.log_event('SIGNAL_TRIGGERED',
                                   data_feed=d, # 关联数据源 (Associate data feed)
                                   # Associate data feed.
                                   signal_type=entry_signal_type, # 信号类型 (Signal type)
                                   # Signal type.
                                   triggering_data=triggering_data, # 触发数据 (Triggering data)
                                   # Triggering data.
                                   trade_cycle_id=self.current_trade_id # 必须包含新生成的ID (Must include the newly generated ID)
                                   # Must include the newly generated ID.
                                  )
                    # 记录信号触发日志，带上新的追踪号。 (记录信号触发的日志，带上新的追踪号。)
                    # Log the SIGNAL_TRIGGERED event with the new trade ID.


                    # == 计算订单大小 ==
                    # (Calculate order size)
                    calculated_size_info = self._calculate_trade_size(
                        data_close_price=close,
                        # 当前收盘价。 (Current close price.)
                        entry_price=entry_price,
                        # 入场价。 (Entry price.)
                        stop_loss_price=stop_loss_price,
                        # 止损价。 (Stop loss price.)
                        risk_per_trade_percent=self.p.risk_per_trade_percent,
                        # 单笔交易风险百分比。 (Risk per trade percentage.)
                        data=d # 传递数据对象 (Pass the data object)
                        # Pass the data object.
                    )
                    # 调用内部工具计算订单大小。 (调用咱们自己写的工具算一下该买多少。)
                    # Call the internal helper method to calculate the order size.
                    size = calculated_size_info['size'] # 获取计算出的大小 (Get the calculated size)
                    # 拿到计算结果：买多少。 (拿到算出来的数量。)
                    # Get the calculated size.
                    size_calc_details = calculated_size_info['details'] # 获取计算详情 (Get calculation details)
                    # 拿到计算过程的细节。 (拿到计算过程的细节。)
                    # Get the calculation details.

                    # 记录订单计算事件 (Log order calculation event)
                    self.log_event('ORDER_CALCULATION',
                                   data_feed=d, # 关联数据源 (Associate data feed)
                                   # Associate data feed.
                                   signal_type=entry_signal_type, # 关联的信号类型 (Associated signal type)
                                   # Associated signal type.
                                   entry_price_approx=entry_price, # 大致入场价 (Approximate entry price)
                                   # Approximate entry price.
                                   stop_loss_calc=stop_loss_price, # 计算出的止损价 (Calculated stop loss price)
                                   # Calculated stop loss price.
                                   take_profit_calc=None, # 未计算止盈价 (Take profit price not calculated)
                                   # Take profit price (not calculated here).
                                   risk_inputs=size_calc_details['risk_inputs'], # 风险计算输入 (Risk calculation inputs)
                                   # Risk calculation inputs.
                                   size_raw=size_calc_details['raw_size'], # 原始计算大小 (Raw calculated size)
                                   # Raw calculated size.
                                   size_final=size, # 最终调整后大小 (Final adjusted size)
                                   # Final adjusted size.
                                   adjustment_reasons=size_calc_details['adjustment_reasons'], # 调整原因 (Adjustment reasons)
                                   # Adjustment reasons.
                                   trade_cycle_id=self.current_trade_id # 必须包含交易ID (Must include trade ID)
                                   # Must include trade ID.
                                  )
                    # 记录订单计算日志，包含计算细节和交易追踪号。 (记录算单日志，包括怎么算的、结果多少、带上交易追踪号。)
                    # Log the ORDER_CALCULATION event with calculation details and trade ID.


                    if size > 0:
                        # 如果计算出的下单量大于0。 (如果算出来确实要买。)
                        # If the calculated size is greater than 0.
                        # self.log(f'BUY CREATE, {close:.2f}, Size: {size}', dt=current_dt, data=d) # 旧日志 (Old log)
                        # Old log message for buy creation.
                        order_to_place = self.buy(data=d, size=size) if is_buy else self.sell(data=d, size=size) # 发出买入或卖出指令 (Issue buy or sell command)
                        # 发出买入（或卖出）指令。 (那就下单买入（或卖出）。)
                        # Issue the buy (or sell) command.
                        self.order = order_to_place # 跟踪订单 (Track the order)
                        # 把这个订单记到 self.order 里，表示有个订单发出去了。 (把这个订单记到 self.order，表示有个单子在外面跑。)
                        # Track the placed order using self.order.

                        # == 映射订单引用和交易 ID ==
                        # (Map order reference and trade ID)
                        self._map_order_ref_to_trade_id(self.order) # 调用辅助方法进行映射 (Call helper method for mapping)
                        # 把这个新订单的号和当前的交易追踪号关联起来。 (把这个订单号和当前的交易追踪号对上。)
                        # Map the new order's reference to the current trade ID.

                        # 记录订单提交事件 (Log order submitted event)
                        if self.order:
                            # 如果订单成功创建。 (如果订单创建成功了。)
                            # If the order was successfully created.
                            self.log_event('ORDER_SUBMITTED',
                                           data_feed=d, # 关联数据源 (Associate data feed)
                                           # Associate data feed.
                                           order_ref=self.order.ref, # 订单引用 (Order reference)
                                           # Order reference.
                                           trade_cycle_id=self.current_trade_id, # 交易周期ID (Trade cycle ID)
                                           # Trade cycle ID.
                                           order_details={ # 订单详情 (Order details)
                                           # Order details.
                                               'type': self.order.getordername(), # 类型 (Type)
                                               # Order type name.
                                               'size': self.order.created.size, # 大小 (Size)
                                               # Order size.
                                               'price': self.order.created.price, # 价格 (Price)
                                               # Order price.
                                               'pricelimit': self.order.created.pricelimit, # 限价 (Price limit)
                                               # Order price limit.
                                               'valid': self.order.valid, # 有效期 (Validity)
                                               # Order validity.
                                               'isbuy': self.order.isbuy(), # 是否买单 (Is buy?)
                                               # Is it a buy order?
                                               'issell': self.order.issell() # 是否卖单 (Is sell?)
                                               # Is it a sell order?
                                           })
                            # 记录订单提交日志，包含订单细节和交易追踪号。 (记录下单日志，包括订单细节和交易追踪号。)
                            # Log the ORDER_SUBMITTED event with order details and trade ID.
                        else: # 如果 self.buy/sell 返回 None (比如 size 为 0 或其他内部原因) (If self.buy/sell returns None (e.g., size is 0 or other internal reasons))
                            self.log_event('ORDER_SUBMISSION_FAILED', reason='Order object not returned by buy/sell', trade_cycle_id=self.current_trade_id, data_feed=d)
                            # 记录订单提交失败事件，因为 buy/sell 未返回订单对象。 (Log order submission failure because buy/sell didn't return an order object.)
                            # print(f"DEBUG: Resetting current_trade_id from {self.current_trade_id} due to submission failure.") # 调试
                            self.current_trade_id = None # 重置交易ID，因为订单未成功创建 (Reset trade ID as order wasn't successfully created)
                            # 重置交易追踪号，因为订单未能成功创建。 (Reset trade ID as the order failed to be created.)
                    else:
                        # 如果计算出的尺寸无效 (If calculated size is not valid (<= 0))
                        # If the calculated size is not valid (<= 0).
                        # self.log_event('TRADE_SKIPPED', reason='Calculated size is zero or negative', details=size_calc_details, trade_cycle_id=self.current_trade_id, data_feed=d)
                        self.log_event('TRADE_SKIPPED',
                                       data_feed=d,
                                       # 关联数据源。 (Associate data feed.)
                                       reason='Calculated size is zero or negative',
                                       # 原因：计算出的大小为零或负数。 (Reason: Calculated size is zero or negative.)
                                       details=size_calc_details,
                                       # 计算细节。 (Calculation details.)
                                       trade_cycle_id=self.current_trade_id, # 关联的（失败的）交易周期ID (Associated (failed) trade cycle ID)
                                       # Associated (failed) trade cycle ID.
                                       signal_type=entry_signal_type) # 触发的信号 (Triggering signal)
                                       # Triggering signal type.
                        # 记录交易跳过事件，因为计算出的数量无效。 (记一笔日志，说这次交易跳过了，因为算出来的数量不对。)
                        # Log the TRADE_SKIPPED event because the calculated size was invalid.
                        # print(f"DEBUG: Resetting current_trade_id from {self.current_trade_id} due to zero size.") # 调试
                        self.current_trade_id = None # 重置交易ID，因为交易未启动 (Reset trade ID as trade wasn't initiated)
                        # 把交易追踪号清掉。 (把交易追踪号清了。)
                        # Reset the trade ID as the trade was not initiated.


                elif entry_signal_type and not can_trade: # 有信号但风控阻止 (Signal exists but risk control prevents)
                     # 如果有入场信号，但是风险检查没通过。 (如果有信号，但风险检查不让交易。)
                     # If there was an entry signal, but risk control prevented trading.
                     self.log_event('TRADE_SKIPPED',
                                    data_feed=d, # 关联数据源 (Associate data feed)
                                    # Associate data feed.
                                    reason='Risk Control', # 原因：风险控制 (Reason: Risk Control)
                                    # Reason: Risk Control.
                                    details=risk_check_details, # 风险检查细节 (Risk check details)
                                    # Risk check details.
                                    signal_type=entry_signal_type, # 触发的信号 (Triggered signal)
                                    # Triggered signal type.
                                    triggering_data=triggering_data # 信号数据 (Signal data)
                                    # Signal triggering data.
                                    # trade_cycle_id 不适用，因为交易未启动 (trade_cycle_id not applicable as trade wasn't initiated)
                                    # trade_cycle_id is not applicable here as the trade was not initiated.
                                   )
                     # 记录交易跳过事件，因为风险控制。 (记一笔日志，说这次交易跳过了，因为风险控制不让。)
                     # Log the TRADE_SKIPPED event due to risk control.

            else: # 持有仓位 (Holding a position)
                # 如果当前持有这个数据。 (如果手里有这个货。)
                # If currently holding a position in this data feed.

                # --- 潜在出场信号 ---
                # (Potential Exit Signals)
                exit_signal_type = None # 初始化出场信号类型 (Initialize exit signal type)
                # 先假设没有出场信号。 (先假设没信号。)
                # Initialize exit signal type to None.
                triggering_data = {} # 存储触发信号的数据 (Store data that triggered the signal)
                # 准备一个盒子放触发信号的具体数据。 (准备一个盒子放触发信号的数据。)
                # Initialize a dictionary to store triggering data.

                if position_size > 0 and cross_down_medium: # 多头持仓，短期下穿中期 (Long position, short crosses down medium)
                    # 如果是多头持仓，并且短期线下穿了中期线。 (如果是多单，并且短期均线下穿了中期均线。)
                    # If holding a long position and short EMA crossed down medium EMA.
                    exit_signal_type = 'EMA_Cross_Exit_Long' # 信号类型：EMA 死叉平多 (Signal type: EMA Death Cross Exit Long)
                    # 信号是：EMA死叉平多仓。 (信号是：EMA 死叉平多。)
                    # Set signal type: EMA Death Cross Exit Long.
                    triggering_data = {'close': close, 'ema_short': ema_short_val, 'ema_medium': ema_medium_val}
                    # 记录触发时的价格和指标值。 (记下触发时的价格和指标值。)
                    # Record triggering price and indicator values.
                    # is_close = True # 标记为平仓 (Mark as close) - 不需要，self.close() 隐含 (Not needed, implied by self.close())
                    # Mark as a close operation (implied by self.close()).

                # elif position_size < 0 and cross_up_medium: # 空头持仓，短期上穿中期 (Short position, short crosses up medium)
                #     # 如果是空头持仓，并且短期线上穿了中期线。 (如果是空单，并且短期均线上穿了中期均线。)
                #     # If holding a short position and short EMA crossed up medium EMA.
                #     exit_signal_type = 'EMA_Cross_Exit_Short'
                #     # Set signal type: EMA Golden Cross Exit Short.
                #     triggering_data = {'close': close, 'ema_short': ema_short_val, 'ema_medium': ema_medium_val}
                #     # Record triggering data.
                #     # is_close = True
                #     # Mark as a close operation.

                # --- 如果有出场信号 ---
                # (If there is an exit signal)
                if exit_signal_type:
                    # 如果探测到了出场信号。 (如果有平仓信号。)
                    # If an exit signal was detected.

                    # 尝试获取与当前持仓关联的 trade_cycle_id
                    # (Attempt to get the trade_cycle_id associated with the current position)
                    # 注意：简单的策略可能只有一个活跃的 trade_cycle_id
                    # (Note: Simple strategies might only have one active trade_cycle_id)
                    # 如果有多个并发交易，需要更复杂的逻辑来确定哪个交易被关闭
                    # (More complex logic is needed to determine which trade is being closed if multiple concurrent trades exist)
                    # 查找与当前持仓对应的 trade_id，需要反向查找或存储持仓对应的 trade_id
                    # (Need to find trade_id for the current position, requires reverse lookup or storing trade_id with position)
                    # 简化：假设是 self.current_trade_id，但这在多仓位时可能不准确
                    # (Simplification: Assume self.current_trade_id, but this might be inaccurate with multiple positions)
                    exit_trade_id = self.current_trade_id # 简化假设 (Simplified assumption)
                    # 先假设要平的是当前正在进行的这个交易。 (先假设要平的是当前这个。)
                    # Simplified assumption: assume the exit corresponds to the current trade ID.
                    # TODO: Implement a more robust way to link closing orders to the correct trade cycle if multiple concurrent trades are possible.
                    # TODO: 如果可能存在多个并发交易，需要实现更健壮的方式将平仓订单链接到正确的交易周期。 (Need a more robust way to link closing orders to the correct trade cycle if multiple concurrent trades are possible.)


                    # 记录信号触发事件 (Log signal triggered event)
                    self.log_event('SIGNAL_TRIGGERED',
                                   data_feed=d, # 关联数据源 (Associate data feed)
                                   # Associate data feed.
                                   signal_type=exit_signal_type, # 信号类型 (Signal type)
                                   # Signal type.
                                   triggering_data=triggering_data, # 触发数据 (Triggering data)
                                   # Triggering data.
                                   trade_cycle_id=exit_trade_id if exit_trade_id else 'UNKNOWN_EXIT' # 关联的交易ID或未知 (Associated trade ID or unknown)
                                   # Associated trade ID (or unknown).
                                  )
                    # 记录信号触发日志，带上关联的交易追踪号（如果知道的话）。 (记录信号触发日志，带上关联的交易追踪号（如果知道）。)
                    # Log the SIGNAL_TRIGGERED event with the associated trade ID (if known).


                    # self.log(f'CLOSE CREATE, {close:.2f}, Size: {position_size}', dt=current_dt, data=d) # 旧日志 (Old log)
                    # Old log message for close creation.
                    order_to_place = self.close(data=d) # 发出平仓指令 (Issue close command)
                    # 发出平仓指令。 (下单平仓。)
                    # Issue the close command.
                    self.order = order_to_place # 跟踪订单 (Track the order)
                    # 把这个订单记到 self.order 里。 (把这个订单记到 self.order。)
                    # Track the placed order.

                    # == 映射订单引用和交易 ID ==
                    # (Map order reference and trade ID)
                    # 即使 exit_trade_id 不确定，也尝试映射，以便后续在 notify_trade 中查找
                    # (Even if exit_trade_id is uncertain, try mapping for later lookup in notify_trade)
                    self._map_order_ref_to_trade_id(self.order) # 使用平仓订单关联 (Associate using the closing order)
                    # 把这个平仓订单的号和对应的交易追踪号关联起来。 (把这个平仓单号和对应的追踪号对上。)
                    # Map the closing order's reference to the (assumed) trade ID.

                    # 记录订单提交事件 (Log order submitted event)
                    if self.order:
                         # 如果订单成功创建。 (如果订单创建成功了。)
                         # If the order was successfully created.
                         self.log_event('ORDER_SUBMITTED',
                                        data_feed=d, # 关联数据源 (Associate data feed)
                                        # Associate data feed.
                                        order_ref=self.order.ref, # 订单引用 (Order reference)
                                        # Order reference.
                                        trade_cycle_id=exit_trade_id if exit_trade_id else 'UNKNOWN_EXIT', # 交易周期ID (Trade cycle ID)
                                        # Trade cycle ID (assumed).
                                        order_details={ # 订单详情 (Order details)
                                        # Order details.
                                            'type': self.order.getordername(), # 类型 (Type)
                                            # Order type name.
                                            'size': self.order.created.size, # 大小 (Size)
                                            # Order size.
                                            'price': self.order.created.price, # 价格 (Price)
                                            # Order price.
                                            'isclose': True # 标记为平仓单 (Mark as closing order)
                                            # Mark as a closing order.
                                        })
                         # 记录订单提交日志。 (记录下单日志。)
                         # Log the ORDER_SUBMITTED event for the closing order.
                    # else:
                         # self.log_event('ORDER_SUBMISSION_FAILED', reason='Close order failed', trade_cycle_id=exit_trade_id, data_feed=d)
                         # 记录平仓失败日志。 (记录平仓失败日志。)
                         # Log order submission failure for the closing order.

    def stop(self):
        # 定义 stop 方法，在回测结束时调用。 (定义策略结束时要做的事情。)
        """Strategy stop method."""
        # """策略停止方法。"""
        self.log_event('STRATEGY_STOP', final_value=self.broker.getvalue(), final_cash=self.broker.getcash())
        # 记录策略停止事件，包含最终资产和现金。 (记录策略停止的日志，附上最后的总资产和现金。)
        # Log the STRATEGY_STOP event with final portfolio value and cash.
        # --- 停止日志监听器 ---
        # (Stop the log listener)
        # stop_log_listener() # 在 Cerebro 运行结束后停止更合适 (More appropriate to stop after Cerebro run finishes)
        # It's generally better to stop the listener after the Cerebro run finishes.
        # print("Strategy stop method called.") # 用于调试 (For debugging)
        # Debug message.

    # ==================== 交易周期ID管理辅助方法 START ====================
    def _generate_trade_cycle_id(self):
        # 定义一个私有方法，用于生成新的交易周期ID。 (定义一个内部工具，用来生成新的交易追踪号。)
        """Generates a new unique trade cycle ID."""
        # """生成一个新的唯一交易周期ID。"""
        return uuid.uuid4().hex
        # 返回一个基于 UUID4 的十六进制字符串作为唯一ID。 (生成并返回一个独一无二的字符串ID。)
        # Return a hexadecimal string based on UUID4 as the unique ID.

    def _map_order_ref_to_trade_id(self, order):
        # 定义一个私有方法，将订单引用映射到当前的交易周期ID。 (定义一个内部工具，把订单号和当前的交易追踪号关联起来。)
        """Maps the order reference to the current trade cycle ID."""
        # """将订单引用映射到当前交易周期ID。"""
        if order and order.ref is not None:
            # 如果订单对象有效且订单引用不为空。 (If the order object is valid and its reference is not None.)
            current_id_to_map = self.current_trade_id
            # 获取当前要映射的交易ID。 (Get the current trade ID to map.)
            if not current_id_to_map:
                # 如果当前没有活跃的交易ID（可能是平仓单）。 (If there is no active trade ID (might be a closing order).)
                # 尝试从持仓查找（复杂，此处简化）或标记为未知 (Try finding from position (complex, simplified here) or mark as unknown)
                # 简化：如果平仓单来了但 current_trade_id 为空，我们无法准确知道它属于哪个周期
                # (Simplification: If a closing order arrives but current_trade_id is None, we can't accurately know which cycle it belongs to)
                current_id_to_map = f'UNKNOWN_CLOSING_{order.ref}' # 标记为未知的平仓关联 (Mark as unknown closing association)
                # 将其标记为与未知平仓关联。 (Mark it as associated with an unknown closing.)
                self.log_event('WARNING_UNKNOWN_TRADE_ID_FOR_ORDER', order_ref=order.ref, order_type='Closing?' if order.created.size != 0 and ((order.isbuy() and self.getposition(order.data).size < 0) or (order.issell() and self.getposition(order.data).size > 0)) else 'Unknown', data_feed=order.data)
                # 记录警告：无法确定订单的交易ID。 (Log a warning: Cannot determine trade ID for the order.)

            self.order_ref_to_trade_id_map[order.ref] = current_id_to_map
            # 在映射字典中创建或更新条目。 (在对应表里记下：这个订单号 -> 这个交易追踪号。)
            # Create or update the entry in the mapping dictionary.
            # print(f"DEBUG: Mapped order_ref {order.ref} to trade_id {current_id_to_map}") # 调试
            # self.log_event('ORDER_REF_MAPPED', order_ref=order.ref, trade_cycle_id=current_id_to_map, data_feed=order.data) # 可选日志 (Optional log)
            # Optional: Log the mapping event.

    # ==================== 交易周期ID管理辅助方法 END ======================


# ... (原有的 load_data_to_cerebro 等函数)
# ... (Original functions like load_data_to_cerebro etc.)

# ... (原有的 print_optimization_summary 等函数)
# ... (Original functions like print_optimization_summary etc.)

# ... (原有的 print_backtest_summary 等函数)
# ... (Original functions like print_backtest_summary etc.)

# ... (原有的 get_backtest_config 等函数)
# ... (Original functions like get_backtest_config etc.)

# ... (原有的 setup_cerebro_and_broker 等函数)
# ... (Original functions like setup_cerebro_and_broker etc.)

# ... (原有的 add_strategy_components 等函数)
# ... (Original functions like add_strategy_components etc.)

# ... (原有的 process_and_report_results 等函数)
# ... (Original functions like process_and_report_results etc.)


def run_backtest():
    # 定义run_backtest函数，封装整个回测或优化的执行流程。 (Define the run_backtest function to encapsulate the entire backtest or optimization execution flow.)
    """
    主函数：设置并运行回测或优化。
    Main function: Sets up and runs the backtest or optimization.
    """
    start_time = time.time() # 记录开始时间 (Record start time)
    # 记录函数开始执行的时间。 (Record the time when the function starts executing.)
    config = get_backtest_config() # 获取配置 (Get configuration)
    # 调用 get_backtest_config 获取回测/优化配置。 (Call get_backtest_config to get the backtest/optimization configuration.)

    try: # 使用 try...finally 确保日志监听器被停止 (Use try...finally to ensure the log listener is stopped)
        # 使用 try...finally 块确保即使发生错误，清理代码也能执行。 (Use a try...finally block to ensure cleanup code executes even if errors occur.)
        cerebro = setup_cerebro_and_broker(config) # 设置 Cerebro 和 Broker (Setup Cerebro and Broker)
        # 调用 setup_cerebro_and_broker 设置 Cerebro 核心引擎和模拟经纪商。 (Call setup_cerebro_and_broker to set up the Cerebro core engine and the simulated broker.)

        # 加载数据 (Load Data)
        load_data_to_cerebro(cerebro, config['data_files'], config['column_mapping'], config['openinterest_col'], config['fromdate'], config['todate'])
        # 调用 load_data_to_cerebro 将数据加载到 Cerebro 中。 (Call load_data_to_cerebro to load data into Cerebro.)

        # 添加策略和其他组件 (Add Strategy and other components)
        add_strategy_components(cerebro, config) # 添加策略、分析器等 (Add strategy, analyzers, etc.)
        # 调用 add_strategy_components 添加策略、分析器、观察器等。 (Call add_strategy_components to add strategy, analyzers, observers, etc.)

        # 运行回测或优化 (Run Backtest or Optimization)
        print("Running Cerebro...") # 打印运行信息 (Print running message)
        # 打印提示信息，表示 Cerebro 即将开始运行。 (Print a message indicating that Cerebro is about to run.)
        results = cerebro.run(exactbars=config.get('exactbars', False)) # 运行 (Run) - 使用配置中的 exactbars 或默认 False (Use exactbars from config or default False)
        # 调用 cerebro.run() 执行回测或优化，并根据配置设置 exactbars。 (Call cerebro.run() to execute the backtest or optimization, setting exactbars according to the configuration.)
        print("Cerebro run finished.") # 打印完成信息 (Print completion message)
        # 打印提示信息，表示 Cerebro 运行结束。 (Print a message indicating that Cerebro run has finished.)

        # 处理和报告结果 (Process and Report Results)
        process_and_report_results(results, cerebro, config, start_time) # 处理并打印结果 (Process and print results)
        # 调用 process_and_report_results 处理并报告回测或优化结果。 (Call process_and_report_results to process and report the backtest or optimization results.)

    finally: # 无论是否发生异常，都会执行 (Executes regardless of exceptions)
        # --- 停止日志监听器 ---
        # (Stop the log listener)
        stop_log_listener() # 确保在程序退出前停止监听器 (Ensure listener is stopped before program exit)
        # 确保在函数退出（无论是正常结束还是异常中断）前停止日志监听器。 (Ensure the log listener is stopped before the function exits (whether normally or due to an exception).)
        # print("Log listener stopped.") # 用于调试 (For debugging)
        # Debug message.

# ... (原有的 if __name__ == '__main__': 块)
# ... (Original if __name__ == '__main__': block)

if __name__ == '__main__':
    # 如果脚本作为主程序运行。 (If the script is run as the main program.)
    run_backtest() # 调用主函数 (Call the main function)
    # 调用 run_backtest 函数开始执行。 (Call the run_backtest function to start execution.)

'''})
)
```

**后续工作和注意事项:**

1.  **错误处理:** `log_event` 中增加了基本的 `try...except`，但实际应用中可能需要更细致的错误处理和 fallback 机制。
2.  **性能测试:** 在实际运行中，需要关注日志系统对策略性能的影响，尤其是在高频场景下。如果性能下降明显，可能需要优化 JSON 序列化或日志记录频率。
3.  **配置化:** 当前日志路径和文件名是硬编码在 `params` 中的，实际项目中应移到外部配置文件 (如 YAML) 中，通过 Cerebro 参数传递进来。
4.  **日志轮转:** `RotatingFileHandler` 或 `TimedRotatingFileHandler` 可以实现日志轮转，防止日志文件过大，但这会增加设置的复杂度，本次未实现。
5.  **`trade_cycle_id` 鲁棒性:** 当前实现假设一个时间点最多只有一个活跃的开仓/平仓周期。如果策略逻辑允许并发交易（例如，在同一个 `next` 中对不同资产开仓，或者允许加仓形成新的周期），`trade_cycle_id` 的管理需要更复杂的设计，可能需要一个数据结构来跟踪每个活跃头寸对应的 `trade_cycle_id`。当前的简化处理在平仓时可能无法准确关联 `trade_cycle_id`。
6.  **Pandas 分析:** JSON Lines 格式非常适合用 `pandas.read_json(log_filepath, lines=True)` 来读取和分析。`trade_cycle_id` 将是连接不同事件的关键。

这些修改应该能在最小化改动原有代码的基础上，实现需求文档中定义的日志系统核心功能。请检查代码并进行测试。

---



---

