  

Cerebro-Cerebro  

🔗 原文链接： https://www.poloxue.com/backtrader/...  

⏰ 剪存时间：2025-03- 15 19:42:32 (UTC+8)  

✂️ 本文档由 飞书剪存 一键生成  

Cerebro 是 Backtrader 的核心类，负责整个系统的运行。  

它的功能包括：  

•   收集输入（数据源）、执行者（策略）、观察者、评论者（分析器）和记录者（编 

写器），确保系统的正常运行。  

•   执行回测或实时数据供给和交易。  

•   返回回测结果。  

•   提供策略绘图功能。  

创建 Cerebro 实例 #  

创建 Cerebro 实例时，可以通过传递一些控制参数：  

Python  
cerebro = bt.Cerebro(**kwargs)  

这些参数会影响系统的执行，具体的参数说明可以参考文档（也可以应用于后续的  

run 方法）。  

添加数据源 #  

最常见的方式是使用 cerebro.adddata(data) 添加数据源， data 是已实例化的数 

据源。例如：  

Python  
data = bt.BacktraderCSVData(dataname='mypath.days',  
timeframe=bt.TimeFrame.Days)  
cerebro.adddata(data)  

数据的重采样与重放 #  

Cerebro 也支持对数据进行重采样或重放：  

重采样  ：  

  
﻿  

Python  
data = bt.BacktraderCSVData(dataname='mypath.min',  
timeframe=bt.TimeFrame.Minutes)  
cerebro.resampledata(data, timeframe=bt.TimeFrame.Days)  

重放数据  ：  

Python  
data = bt.BacktraderCSVData(dataname='mypath.min',  
timeframe=bt.TimeFrame.Minutes)  
cerebro.replaydata(data, timeframe=bt.TimeFrame.Days)  

你可以同时使用多种类型的数据源，包括常规数据、重采样数据和重放数据。但需要 

确保它们的时间对齐。详见文档中的 多时间框架 和 数据重采样 部分。  

添加策略 #  

Cerebro  接受策略类并传递相关参数，即使没有优化，也可以使用以下方式添加策略：  

Python  
cerebro.addstrategy(MyStrategy, myparam1=value1, myparam2=value2)  

策略优化 #  

在优化时，参数需要作为可迭代对象传递。例如：  

Python  
cerebro.optstrategy(MyStrategy, myparam1=range(10, 20))  

这会运行 MyStrategy  10 次， myparam1  的值从  10 到  19。  

添加其他组件 #  

你可以通过以下方法为回测添加额外的功能：  

•   addwriter  ：记录回测数据。  

•   addanalyzer  ：分析回测结果。  

•   addobserver 或 addobservermulti  ：添加观察者，实时跟踪策略执行。  

自定义经纪人 #  

Cerebro 默认使用 Backtrader 内建的经纪人，但你也可以自定义经纪人：  

  
﻿  

Python  
broker = MyBroker()  

cerebro.broker = broker  # 通过 getbroker/setbroker 方法设置  

接收通知 #  

数据源或经纪人可能会发出通知。 Cerebro 通过 notify_store 方法接收这些通知。 

处理通知有三种方式：  

使用回调函数 #  

你可以通过 addnotifycallback(callback)  向 Cerebro 添加回调函数，函数签名 

如下：  

Python  
callback(msg, *args, **kwargs)  

在策略中覆盖 notify_store 方法 #  

你也可以在策略类中直接覆盖 notify_store 方法来处理通知，签名如下：  

Python  
def notify_store(self, msg, *args, **kwargs):  
    # 处理通知  

子类化 Cerebro #  

通过子类化 Cerebro 并覆盖 notify_store  ，这是最不推荐的方法。  

执行回测 #  

回测执行通过以下方法进行：  

Python  
result = cerebro.run(**kwargs)  

run 方法支持多种参数，可以在实例化时指定，详细说明可以参考文档。  

标准观察者 #  

Cerebro 默认会实例化三个标准观察者：  

  
﻿  

•  经纪人观察者：追踪现金和投资组合的价值。  

•  交易观察者：记录每笔交易的效果。  

•  买卖观察者：记录操作的执行时间。  

如果不需要这些标准观察者，可以通过 stdstats=False 禁用它们。  

返回回测结果 #  

回测执行后， Cerebro 会返回策略实例，供你分析回测结果。你可以访问策略中的所 

有元素进行详细检查：  

Python  
result = cerebro.run(**kwargs)  

优化时的返回结果 #  

•  如果没有使用优化，  result 将是一个策略实例列表。  

•  如果进行了优化，  result 将是一个列表的列表，每个内部列表对应一次优化运 

行后的策略实例。  

注意  ：优化的默认行为已经更改，优化时只会返回分析器结果，优化的策略结果需要 

通过设置 optreturn=False 来获取。  

提供绘图功能 #  

如果你安装了 matplotlib  ，可以通过以下方式绘制回测图形：  

回测流程概述 #  

回测的执行逻辑大致如下：  

1.  传递任何存储的通知。  

2.  数据源提供下一组 tick/条。  

   ￮  数据同步：多个数据源的数据会按时间对齐，确保不同时间框架的数据能够 

    同时进行计算。  

   ￮  版本更新  ：1.9.0.99 版本引入了新的同步行为。  

3.  通知策略有关订单、交易和现金的更新。  

4.  经纪人接受排队订单，并根据新数据执行订单。  

5.  调用策略的 next 方法，评估新数据并执行策略逻辑。  

  
﻿  

6.  更新观察者、指标、分析器等，触发其他活动。  

7.  将数据写入目标（通过编写器）。  

重要注意事项 #  

在数据源传递新的一组数据时，这些数据是“已关闭”的。这意味着策略发出的订单将基 

于 下一条数据 执行，而不是当前数据。  

  

Cerebro- 参数说明  

参数                     默认值                    说明  

preload                True                   是否预加载传递给策略的 

                                              不同数据源。  

runonce                True                   以矢量化模式计算指标， 

                                              从而提高整个系统的性 

                                              能。  

                                              注： 策略和观察者将始终 

                                              基于事件运行。  

live                   False                  如果没有数据报告为实时 

                                               （通过数据的 islive 方 

                                              法，但用户仍希望以实时 

                                              模式运行，可将此参数设 

                                              为 true 。  

maxcpus                None                   同时使用多少核心进行优 

                                              化，默认 None，即启用 
                         
                                              所有可用的 CPU 核。  

stdstats               True）                  如果为 True ，将添加默认 

                                              观察者：经纪人（现金和 

                                              价值）、交易和买卖。  

oldbuysell             False                  如 stdstats 为 True 且 

                                              自动添加观察者，此开关 

  
﻿  

                                           控制买卖观察者的主要行 

                                           为。  

oldtrades             False                如果 stdstats 为 True  

                                           且自动添加观察者，此开 

                                           关控制交易观察者的主要 

                                           行为。  

exactbars             False                •  -  False  ：默认值， 

                                           将存储在  Line  中的值都 

                                           保存到内存。  

                                           •  - True 或 1  ：所有  

                                           Line 对象的内存使用减 

                                           少至计算最小周期。  

                                               ￮  如果简单移动平 

                                               均线的周期为 30 ，则 

                                               底层数据将始终有一 

                                               个 30 条的运行缓冲 

                                               区，以允许计算简单 

                                               移动平均线。  

                                               ￮  此设置将停用  

                                               preload 和  

                                               runonce  。  

                                               ￮  使用此设置还将 

                                               停用绘图。  

                                           •   -1  ：策略级别的数据 

                                           源和指标/操作将保留所有 

                                           数据在内存中。  

                                               ￮  如 RSI 通过指标  

                                               UpDay 计算，不会将 

                                               它的所有数据保留内 

                                               存。  

                                               ￮  这允许保持绘图 

                                               和预加载活动。  

                                               ￮  runonce 将被停 

  
﻿  

                                                    用。  

                                                •   -2  ：作为策略属性的 

                                                数据源和指标将保留所有 

                                                点在内存中。  

                                                    ￮  例如： RSI  内部 

                                                    使用指标 UpDay 进行 

                                                    计算。此子指标将不 

                                                    保留所有数据在内存 

                                                    中。  

                                                    ￮  如果在  

                                                    __init__  中定义了  

                                                    a =  
                                                    self.data.close -  
                                                    self.data.high  ， 

                                                    那么 a 将不保留所有 

                                                    数据在内存中。  

                                                    ￮  - 这允许保持绘图 

                                                    和预加载活动。  

                                                    ￮  runonce 将被停 

                                                    用。  

objcache                False                   实验选项，用于实现  

                                                Line 对象的缓存并减少 

                                                它们的数量。示例来自  

                                                UltimateOscillator  ：  

                                                 Python  
                                                 bp =  
                                                 self.data.close -  
                                                 TrueLow(self.data)   

                                                 # -> 创建另一个  
                                                 TrueLow(self.data)  
                                                 tr =  
                                                 TrueRange(self.dat 
                                                 a)   

                                                如果为 True ，  

                                                TrueRange  内部的第二个  

  
﻿  

                                        TrueLow(self.data) 将 

                                        匹配 bp 计算中的签名， 

                                        并将被重用。可能发生的 

                                        极端情况是这会使线对象 

                                        超出其最小周期并导致问 

                                        题，因此被禁用。  

writer              False               如果设置为 True ，将创建 

                                        一个默认的  

                                        WriterFile  ，它将打印 

                                        到标准输出。它将被添加 

                                        到策略中（除了用户代码 

                                        添加的任何其他编写 

                                        器）。  

tradehistory        False               如果设置为 True ，它将激 

                                        活所有策略中每个交易的 

                                        更新事件日志记录。也可 

                                        以通过策略方法  

                                        set_tradehistory 在每 

                                        个策略基础上完成。  

optdatas            True                如果为 True 且在优化 

                                         （并且系统可以预加载和 

                                        使用 runonce），则数据预 

                                        加载将仅在主进程中完 

                                        成，以节省时间和资源。 

                                        测试显示，执行时间从 83 

                                        秒减少到 66 秒，约 20% 

                                        的速度提升。  

optreturn           True                如果为 True ，优化结果将 

                                        不会是完整的策略对象 

                                         （和所有数据、指标、观 

                                        察者 …），而是具有以下 

                                        属性的对象（与策略相 

                                        同）：  

  
﻿  

params  （或 p ）       无                    执行策略时的参数。  

analyzers            无                    策略已执行的分析器。大 

                                          多数情况下，仅需要分析 

                                          器和参数来评估策略的性 

                                          能。如果需要详细分析生 

                                          成的值（例如指标），请 

                                          将其关闭。测试显示，执 

                                          行时间提高了 13% -  

                                          15%。结合 optdatas  ， 

                                          总收益增加到 32%。  

oldsync              False                从版本 1.9.0.99 开始，多 

                                          个数据（相同或不同时间 

                                          框架）的同步已更改，以 

                                          允许不同长度的数据。如 

                                          果希望使用数据 0 作为系 

                                          统主控的数据的旧行为， 

                                          请将此参数设置为 True 。  

tz                   None                 为策略添加全局时区。参 

                                          数 tz 可以是：  

                                          •  None  ：在这种情况 

                                          下，策略显示的日期时间 

                                          将是 UTC，这一直是标准 

                                          行为。  

                                          •  pytz 实例。将用作将 

                                          UTC 时间转换为所选时 

                                          区。  

                                          •  字符串  。将尝试实例 

                                          化 pytz 实例。  

                                          •  整数  。对于策略，使 

                                          用 self.datas 可迭代对 

                                          象中相应数据的相同时区 

                                           （0 将使用 data0  的时 

                                          区）。  

  
﻿  

cheat_on_open          False                   将调用策略的 next_open  

                                               方法。  

                                                 
                                               这发生在 next 之前，并 

                                               且在经纪人有机会评估订 

                                               单之前。指标尚未重新计 

                                               算。这允许发布考虑前一 

                                               天指标的订单，但使用开 

                                               盘价进行股份计算。  

                                                 
                                               对于 cheat_on_open 订 

                                               单执行，还要调用  

                                               cerebro.broker.set_c 
                                               oo(True) 或实例化一个  

                                               BackBroker(coo=True)  
                                                （coo 表示 cheat-on- 

                                               open ）或将 broker_coo  

                                               参数设置为 True 。除非在 

                                               下文中禁用，否则 

                                               Cerebro 会自动执行此操 

                                               作。  

broker_coo             True                    这将自动调用经纪人的  

                                               set_coo 方法，并将其设 

                                               置为 True 以激活  

                                               cheat_on_open 执行。只 

                                               有在 cheat_on_open 也 

                                               为 True 时才会执行。  

quicknotify            False                   在传递下一个价格之前立 

                                               即传递经纪人通知。对于 

                                               回测没有影响，但对于实 

                                               时经纪人，通知可能在条 

                                               传递之前很久就发生。当 

                                               设置为 True 时，将尽快 

                                               传递通知（请参阅实时数 

                                               据源中的 qcheck ）。为了 

                                               兼容性，设置为 False。 

  
﻿  

                                             可能会更改为 True 。  

Cerebro-节省内存  

🔗 原文链接： https://www.poloxue.com/backtrader/...  

⏰ 剪存时间：2025-03- 15 19:42:38 (UTC+8)  

✂️ 本文档由 飞书剪存 一键生成  

Cerebro-内存优化   

Backtrader 的开发是在拥有大量 RAM 的机器上进行的，加上绘图的可视化反馈非常 

有用，几乎是必需品，这使得设计决策变得容易：将所有内容保存在内存中。但这一 

决定有一些缺点：  

•  使用  array.array  进行数据存储时，当某些边界被超出时，需要分配和移动数据。  

•   内存较少的机器可能会受到影响。  

•  连接到一个可能在线数周/数月、提供数千秒/分钟分辨率 tick 的实时数据源。  

后者比前者更重要，因为 backtrader 做出了另一个设计决策：  

•  保持纯 Python 以便在需要时能够在嵌入式系统中运行。  

未来的一个场景可能是 backtrader 连接到第二台提供实时数据的机器，而 backtrader 

本身运行在 Raspberry Pi 甚至更有限的设备上，如 ADSL 路由器（带有 Freetz 映像的 

AVM Frit!Box 7490 ）。  

因此，需要 backtrader 支持动态内存方案。现在可以使用以下语义实例化或运行 

Cerebro ：  

exactbars 默认值为  False  ，每个存储在线中的值都保存在内存中。可能的值：  

•  True 或 1  ：所有“线”对象将内存使用减少到自动计算的最小周期。  

    ￮  如果 SMA 的周期为 30 ，则底层将始终有一个 30 条的运行缓冲区，以允许计 

    算 SMA。  

    ￮  此设置将停用预加载和 runonce。  

    ￮  使用此设置还将停用绘图。  

•   -1  ：在策略级别的数据源和指标/操作将保留所有数据在内存中。  

    ￮  如  RSI  内部使用指标 UpDay 进行计算。此子指标将不保留所有数据在内存中。  

  
﻿  

    ￮  这允许保持绘图和预加载活动。  

    ￮  runonce 将被停用。  

•   -2  ：作为策略属性的数据源和指标将保留所有点在内存中。  

    ￮  如  RSI  内部使用指标 UpDay 进行计算。此子指标将不保留所有数据在内存中。  

    ￮  如果在 __init__  中定义了 a = self.data.close - self.data.high  ， 

    那么 a 将不保留所有数据在内存中。  

    ￮  这允许保持绘图和预加载活动。  

    ￮  runonce 将被停用。  

正如往常，示例胜过千言万语。一个示例脚本展示了差异。它针对 1996 年至 2015 年 

的雅虎每日数据运行，共计 4965 天。  

注意  ：这是一个小样本。交易 14 小时的 EuroStoxx50 期货在一个月内将生成约 

18000 个 1 分钟条。  

首先执行脚本，查看在不请求内存节省时使用了多少内存位置：  

Bash  
$ ./memory-savings.py --save 0Total memory cells used: 506430  

对于级别 1    （完全节省）：  

Bash  
$ ./memory-savings.py --save 1Total memory cells used: 2041  

从 50 万降到 2041 。确实如此。  

系统中的每个“线”对象使用 collections.deque 作为缓冲区（而不是 array.array  ）， 

并且长度限制为所需操作的绝对最小值。  

假设，使用周期为 30 的简单移动平均线的策略。在这种情况下，将进行以下调整：  

•  数据源将有一个 30 位置的缓冲区，这是 SMA 生成下一个值所需的数量。  

•  SMA 将有一个位置的缓冲区，因为除非其他指标需要（依赖于 SMA），否则没必 

要保留更大缓冲区。  

注意  ：此模式最吸引人且可能最重要的特点是，整个脚本生命周期内使用的内存量保 

持不变。  

无论数据源的大小如何。如如果长时间连接实时数据源，这将非常有用。  

但请注意：  

  
﻿  

•   绘图不可用。  

•   还有其他内存消耗源，如策略生成的订单，随着时间的推移会积累。  

•   此模式只能与  runonce=False 一起在 cerebro 中使用。这对于实时数据源也是强 

制性的，但在简单回测的情况下，这比  runonce=True 慢。毫无疑问，从某个折衷点 

来看，内存管理比逐步执行回测更昂贵，但这只能由平台的终端用户根据具体情况判 

断。  

现在是负级别。这些旨在在保持绘图可用的同时仍节省大量内存。第一个级别-1：  

Bash  
$ ./memory-savings.py --save -1  
Total memory cells used: 184623  

在这种情况下，1 级指标（策略中声明的那些）保留其完整长度缓冲区。但如果这些 

指标依赖于其他指标（这是情况），则子对象将长度受限。在这种情况下，我们从：  

•   506430 内存位置降至 -> 184623  

超过 50%的节省。  

注意  ：当然， array.array 对象已被 collections.deque 替换，后者在内存方面 

更昂贵，虽然在操作方面更快。但 collections.deque 对象相当小，节省的内存位 

置接近大致计算的内存位置使用。  

现在是级别-2 ，这也是为了节省在策略级别声明且标记为不绘图的指标：  

Bash  
$ ./memory-savings.py --save -2  
Total memory cells used: 174695  

现在并没有节省多少。这是因为只有一个指标被标记为不绘图：  

TestInd().plotinfo.plot = False  。  

让我们看看最后一个示例的绘图：  

Bash  
$ ./memory-savings.py --save -2 --plot  
Total memory cells used: 174695  

  

  
﻿  

                                                                                             

  

对于感兴趣的读者，示例脚本可以详细分析遍历指标层次结构的每个“线”对象。启用绘 

图运行（在-1 保存）：  

Bash  
$ ./memory-savings.py --save -1 --lendetails  
-- Evaluating Datas  
---- Data 0 Total Cells 34755 - Cells per Line 4965-- Evaluating  
Indicators  
---- Indicator 1.0 Average Total Cells 30 - Cells per line 30----  
SubIndicators Total Cells 1---- Indicator 1.1 _LineDelay Total  
Cells 1 - Cells per line 1---- SubIndicators Total Cells 1...  
---- Indicator 0.5 TestInd Total Cells 9930 - Cells per line 4965- 
--- SubIndicators Total Cells 0-- Evaluating Observers  
---- Observer 0 Total Cells 9930 - Cells per Line 4965----  
Observer 1 Total Cells 9930 - Cells per Line 4965---- Observer 2  
Total Cells 9930 - Cells per Line 4965Total memory cells used:  
184623  

相同的，但启用最大节省（ 1）：  

Bash  
$ ./memory-savings.py --save 1 --lendetails  
-- Evaluating Datas  
---- Data 0 Total Cells 266 - Cells per Line 38-- Evaluating  
Indicators  
---- Indicator 1.0 Average Total Cells 30 - Cells per line 30----  
SubIndicators Total Cells 1...  
---- Indicator 0.5 TestInd Total Cells 2 - Cells per line 1----  

  
﻿  

SubIndicators Total Cells 0-- Evaluating Observers  
---- Observer 0 Total Cells 2 - Cells per Line 1---- Observer 1  
Total Cells 2 - Cells per Line 1---- Observer 2 Total Cells 2 -  
Cells per Line 1  

第二个输出立即显示数据源中的线已被限制为 38 个内存位置，而不是 4965 个（完整 

数据源长度）。  

并且在可能的情况下，指标和观察者已被限制为 1 个，如输出的最后几行所示。  

脚本代码和使用 #  

在 backtrader 的源代码中提供了示例。使用方法：  

Bash  
$ ./memory-savings.py --help  
usage: memory-savings.py [-h] [--data DATA] [--save SAVE] [-- 
datalines]                         [--lendetails] [--plot]  
Check Memory Savings  
optional arguments:  
  -h, --help    show this help message and exit  
  --data DATA   Data to be read in (default: ../../datas/yhoo- 
1996-2015.txt)  --save SAVE   Memory saving level [1, 0, -1, -2]  
(default: 0)  --datalines   Print data lines (default: False)  -- 
lendetails  Print individual items memory usage (default: False)   
--plot        Plot the result (default: False)  

代码：  

Python  
from __future__ import (absolute_import  
, division, print_function,  
                        unicode_literals)  
import argparse  
import sys  
import backtrader as bt  
import backtrader.feeds as btfeeds  
import backtrader.indicators as btind  
import backtrader.utils.flushfile  
class TestInd(bt.Indicator):  
    lines = ('a', 'b')  
    def __init__(self):  
        self.lines.a = b = self.data.close - self.data.high  
        self.lines.b = btind.SMA(b, period=20)  

  
﻿  

class St(bt.Strategy):  
    params = (  
        ('datalines', False),  
        ('lendetails', False),  
    )  
    def __init__(self):  
        btind.SMA()  
        btind.Stochastic()  
        btind.RSI()  
        btind.MACD()  
        btind.CCI()  
        TestInd().plotinfo.plot = False  
    def next(self):  
        if self.p.datalines:  
            txt =  ','.join(  
                ['%04d' % len(self),  
                  '%04d' % len(self.data0),  
                 self.data.datetime.date(0).isoformat()]  
            )  
            print(txt)  
    def loglendetails(self, msg):  
        if self.p.lendetails:  
            print(msg)  
    def stop(self):  
        super(St, self).stop()  
        tlen = 0        self.loglendetails('-- Evaluating Datas')  
        for i, data in enumerate(self.datas):  
            tdata = 0            for line in data.lines:  
                tdata += len(line.array)  
                tline = len(line.array)  
            tlen += tdata  
            logtxt =  '---- Data {} Total Cells {} - Cells per Line  
{}'            self.loglendetails(logtxt.format(i, tdata, tline))  
        self.loglendetails('-- Evaluating Indicators')  
        for i, ind in enumerate(self.getindicators()):  
            tlen += self.rindicator(ind, i, 0)  
        self.loglendetails('-- Evaluating Observers')  
        for i, obs in enumerate(self.getobservers()):  
            tobs = 0            for line in obs.lines:  
                tobs += len(line.array)  
                tline = len(line.array)  
            tlen += tdata  
            logtxt =  '---- Observer {} Total Cells {} - Cells per  
Line {}'            self.loglendetails(logtxt.format(i, tobs,  

  
﻿  

tline))  
        print('Total memory cells used: {}'.format(tlen))  
    def rindicator(self, ind, i, deep):  
        tind = 0        for line in ind.lines:  
            tind += len(line.array)  
            tline = len(line.array)  
        thisind = tind  
        tsub = 0        for j, sind in  
enumerate(ind.getindicators()):  
            tsub += self.rindicator(sind, j, deep + 1)  
        iname = ind.__class__ .__name__ .split('.')[-1]  
        logtxt =  '---- Indicator {}.{} {} Total Cells {} - Cells  
per line {}'        self.loglendetails(logtxt.format(deep, i,  
iname, tind, tline))  
        logtxt =  '---- SubIndicators Total Cells {}'         
self.loglendetails(logtxt.format(deep, i, iname, tsub))  
        return tind + tsub  
def runstrat():  
    args = parse_args()  
    cerebro = bt.Cerebro()  
    data = btfeeds.YahooFinanceCSVData(dataname=args.data)  
    cerebro.adddata(data)  
    cerebro.addstrategy(  
        St, datalines=args.datalines, lendetails=args.lendetails)  
    cerebro.run(runonce=False, exactbars=args.save)  
    if args.plot:  
        cerebro.plot(style='bar')  
def parse_args():  
    parser = argparse.ArgumentParser(  
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  
        description='Check Memory Savings')  
    parser.add_argument('--data', required=False,  
                        default='../../datas/yhoo-1996-2015.txt',  
                        help='Data to be read in')  
    parser.add_argument('--save', required=False, type=int,  
default=0,  
                        help=('Memory saving level [1, 0, -1, - 
2]'))  
    parser.add_argument('--datalines', required=False,  
action='store_true',  
                        help=('Print data lines'))  
    parser.add_argument('--lendetails', required=False,  
action='store_true',  
                        help=('Print individual items memory  

  
﻿  

usage'))  
    parser.add_argument('--plot', required=False,  
action='store_true',  
                        help=('Plot the result'))  
    return parser.parse_args()  
if __name__ ==  '__main__':  
    runstrat()  

Cerebro-优化改进  

🔗 原文链接： https://www.poloxue.com/backtrader/...  

⏰ 剪存时间：2025-03- 15 19:45:41 (UTC+8)  

✂️ 本文档由 飞书剪存 一键生成  

Backtrader 通过引入两个新的 Cerebro 参数，优化了在多进程环境下管理数据源和结 

果的方式。  

参数说明：  

参数名                    默认值                    描述  

optdatas               True                   如果为 True 并进行优化 

                                               （系统可以预加载并使用 

                                              runonce），则数据预加载 

                                              将仅在主进程中进行一 

                                              次，以节省时间和资源。  

optreturn              True                   如果为 True ，优化结果将 

                                              不是完整的策略对象（包 

                                              括所有数据、指标、观察 

                                              者等），而是带有以下属 

                                              性的对象（与策略中相 

                                              同）：  

                                              •  - params （或p）：策 

                                              略执行时的参数  

                                              •  - analyzers ：策略执 

                                              行的分析器  

通常，我们只需要查看策略使用的参数的最终表现（如收益率）。如想查看运行过程中 

  
﻿  

的详细数据（如每个时间点的指标值），请关闭此选项。  

数据源管理 #  

在优化场景中，Cerebro 参数可能的组合是：  

•  preload=True  （默认），数据源将在运行任何回测代码前完成预加载：  

•   runonce=True  （默认），指标将在紧密的for  循环中批量计算，而不是逐步计算。  

如果两个条件都为 True 且 optdatas=True  ，则数据源将在生成新子进程之前在主进 

程中预加载（这些子进程负责执行回测）  

结果管理 #  

在优化场景中，当评估每个策略运行的不同参数时，最重要的两个因素是：  

strategy.params  （或 strategy.p ）  

回测使用的实际参数集  

strategy.analyzers  

提供策略实际表现评估的对象。例如： SharpeRatio_A              （年化夏普比率）  

当 optreturn=True  时，不会返回完整的策略实例，而是创建占位符对象，这些对象 

携带上述两个属性以进行评估。  

这避免了传回大量生成的数据，例如回测期间指标生成的值。  

如果希望返回完整的策略对象，只需在 Cerebro 实例化或进行 cerebro.run  时设置  

optreturn=False  。  

一些测试运行 #  

backtrader 源代码中的优化示例已扩展，添加了对 optdatas 和 optreturn  的控制 

 （实际上是禁用它们）。  

单核心运行 #  

作为参考，当将 CPU 数量限制为 1 且不使用多进程模块时会发生什么：  

Bash  
$ ./optimization.py --maxcpus 1  
==================================================**************** 
**********************************  
--------------------------------------------------  
OrderedDict([(u'smaperiod', 10), (u'macdperiod1', 12),  

  
﻿  

(u'macdperiod2', 26), (u'macdperiod3',  
9)])**************************************************  
--------------------------------------------------  
OrderedDict([(u'smaperiod', 10), (u'macdperiod1', 13),  
(u'macdperiod2', 26), (u'macdperiod3', 9)])...  
...  
OrderedDict([(u'smaperiod', 29), (u'macdperiod1', 19),  
(u'macdperiod2', 29), (u'macdperiod3',  
14)])==================================================Time used:  
184.922727833  

多核心运行 #  

在不限制 CPU 数量的情况下，Python 多进程模块将尝试使用所有 CPU。禁用  

optdatas 和 optreturn  

optdatas 和 optreturn 都启用  

默认行为：  

Bash  
$ ./optimization.py  
...  
...  
...  
==================================================Time used:  
56.5889185394  

通过多核和数据源及结果改进，总时间从 184.92 秒减少到 56.58 秒。  

请注意，示例使用了 252 条数据，并且指标仅生成长度为 252 点的值。这只是一个例 

子。  

真正的问题是这种改进有多少是由于新行为。  

optreturn 禁用  ：将完整的策略对象传回调用者：  

Bash  
$ ./optimization.py --no-optreturn  
...  
...  
...  
==================================================Time used:  
67.056914007  

执行时间增加了 18.50%          （或15.62%的速度提升）。  

  
﻿  

optdatas 禁用  ：每个子进程被迫加载其自己的数据源值：  

Bash  
$ ./optimization.py --no-optdatas  
...  
...  
...  
==================================================Time used:  
72.7238112637  

执行时间增加了 28.52%          （或22.19%的速度提升）。  

两者都禁用  ：仍然使用多核，但使用旧的未改进行为：  

Bash  
$ ./optimization.py --no-optdatas --no-optreturn  
...  
...  
...  
==================================================Time used:  
83.6246643786  

执行时间增加了 47.79%          （或32.34%的速度提升）。  

这表明使用多个核心是时间改进的主要贡献因素。  

注意  ：这些执行是在配备 i7-4710HQ             （4 核/8 逻辑）和 16 GB RAM 的笔记本电脑上 

进行的，操作系统为 Windows 10 64 位。在其他条件下可能会有所不同。  

总结 #  

在优化过程中时间减少的最大因素是使用多个核心。  

使用 optdatas 和 optreturn  的示例运行显示了大约 22.19%和 15.62%的速度提升 

 （在测试中两者一起提高了32.34%）。  

示例使用 #  

Bash  
$ ./optimization.py --help  
usage: optimization.py [-h] [--data DATA] [--fromdate FROMDATE]                        
[--todate TODATE] [--maxcpus MAXCPUS] [--no-runonce]                        
[--exactbars EXACTBARS] [--no-optdatas]                       [-- 
no-optreturn]  [--ma_low MA_LOW] [--ma_high MA_HIGH]                        
[--m1_low M1_LOW] [--m1_high M1_HIGH] [--m2_low M2_LOW]                        

  
﻿  

[--m2_high M2_HIGH] [--m3_low M3_LOW]                        [-- 
m3_high M3_HIGH]  
Optimization  
optional arguments:  
  -h, --help            show this help message and exit  
  --data DATA, -d DATA  data to add to the system  
  --fromdate FROMDATE, -f FROMDATE  
                        Starting date in YYYY-MM-DD format  
  --todate TODATE, -t TODATE  
                        Starting date in YYYY-MM-DD format  
  --maxcpus MAXCPUS, -m MAXCPUS  
                        Number of CPUs to use in the optimization  
                          - 0 (default): use all available CPUs  
                          - 1 -> n: use as many as specified  
  --no-runonce          Run in next mode  
  --exactbars EXACTBARS  
                        Use the specified exactbars still  
compatible with preload  
                          0 No memory savings  
                          -1 Moderate memory savings  
                          -2 Less moderate memory savings  
  --no-optdatas         Do not optimize data preloading in  
optimization  
  --no-optreturn        Do not optimize the returned values to  
save time  
  --ma_low MA_LOW       SMA range low to optimize  
  --ma_high MA_HIGH     SMA range high to optimize  
  --m1_low M1_LOW       MACD Fast MA range low to optimize  
  --m1_high M1_HIGH     MACD Fast MA range high to optimize  
  --m2_low M2_LOW       MACD Slow MA range low to optimize  
  --m2_high M2_HIGH     MACD Slow MA range high to optimize  
  --m3_low M3_LOW       MACD Signal range low to optimize  
  --m3_high M3_HIGH     MACD Signal range high to optimize  
(C) 2015-2024 Daniel Rodriguez  

Cerebro-异常 Exceptions  

🔗 原文链接： https://www.poloxue.com/backtrader/...  

⏰ 剪存时间：2025-03- 15 19:46:17 (UTC+8)  

✂️ 本文档由 飞书剪存 一键生成  

设计目标之一是尽早退出并让用户完全透明地了解错误发生的情况。目的是强制自己 

  
﻿  

编写在异常情况下会中断的代码，并强制重新审视受影响的部分。  

但现在是时候了，某些异常可能会慢慢添加到平台中。  

继承层次结构 #  

所有异常的基类是 BacktraderError           （直接继承自  Exception ）。  

位置 #  

在 errors 模块内，可以通过以下方式访问：  

Python  
import backtrader as bt  
class Strategy(bt.Strategy):  
    def __init__(self):  
        if something_goes_wrong():  
            raise bt.errors.StrategySkipError  

或者直接从 backtrader 访问：  

Python  
import backtrader as bt  
class Strategy(bt.Strategy):  
    def __init__(self):  
        if something_goes_wrong():  
            raise bt.StrategySkipError  

异常 #  

StrategySkipError  ，请求平台跳过该策略的回测。应在实例的初始化（ __init__  ） 

阶段引发。  

Cerebro- 日志 Logging - Writter  

🔗 原文链接： https://www.poloxue.com/backtrader/...  

⏰ 剪存时间：2025-03- 15 19:46:21 (UTC+8)  

✂️ 本文档由 飞书剪存 一键生成  

Cerebro-Writer   

Writer 类负责将以下内容写入流：  

  
﻿  

数据源、策略、指标和观察者的 CSV 流。可以通过每个对象的 csv 属性控制哪些对象 

实际进入 CSV 流（数据源和观察者默认为 True ，指标默认为 False）。  

属性摘要：  

•  数据源  

•  策略（线条和参数）  

•  指标/观察者（线条和参数）  

•  分析器（参数和分析结果）  

系统中定义了一个名为 WriterFile  的 Writer ，可以通过以下方式添加：  

1.  设置 Cerebro 的 writer 参数为 True ，将实例化一个标准的 WriterFile  

2.  调用 Cerebro.addwriter(writerclass, **kwargs)  ，在回测执行期间，使用 

给定的 kwargs 实例化 writerclass  

由于标准的 WriterFile 默认不输出 CSV，以下调用可以处理这一点：  

Python  
cerebro.addwriter(bt.WriterFile, csv=True)  

参考 #  

class backtrader.WriterFile() #  

系统范围内的 Writer 类。  

可以通过以下参数进行参数化：  

参数名                   默认                     说明  

out                   sys.stdout             写入的输出流，如果传递 

                                             的是字符串，将使用参数 

                                             内容作为文件名。  

close_out             False                  如果 out 是一个流，是否 

                                             需要由 Writer 显式关闭。  

csv                   False                  在执行过程中，是否将数 

                                             据源、策略、观察者和指 

                                             标的 CSV 流写入输出 

                                             流。可以通过每个对象的  

  
