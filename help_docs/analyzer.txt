  

BT 官方教程  

🔗 原文链接： https://www.poloxue.com/backtrader/...  

⏰ 剪存时间：2025-03- 15 15:58:13 (UTC+8)  

✂️ 本文档由 飞书剪存 一键生成  

analyzer-分析器 #  

无论是回测还是交易，能够分析交易系统的表现对于理解是否不仅仅获得了利润，而 

且是否在实现利润的过程中承担了过多的风险，或者与参考资产（或无风险资产）相 

比是否真的值得付出努力，都是关键。  

这就是分析器对象的作用：提供对已发生情况或当前情况的分析。  

分析器的性质 接口的设计参照了线条对象，例如具有 next 方法，但有一个主要的区别： 

分析器不包含线条。  

这意味着它们在内存方面不是很消耗资源，因为即使在分析了成千上万个价格条之后， 

它们可能仍然只在内存中保存单个结果。  

在生态系统中的位置 #  

分析器对象（如同策略、观察者和数据）通过 cerebro 实例添加到系统中：  

Python  
addanalyzer(ancls, *args, **kwargs)  

但在 cerebro.run 操作期间，对于系统中存在的每个策略，将会发生以下情况：  

•  ancls 在 cerebro.run 期间会用 *args 和 **kwargs 实例化  

•  ancls 实例将会附加到策略上  

这意味着：  

如果回测运行包含例如 3 个策略，那么将创建 3 个 ancls 实例，并且每个实例将附加 

到不同的策略上。  

结论：分析器分析单个策略的表现，而不是整个系统的表现。  

附加位置 #  

  
﻿  

某些分析器对象可能实际上使用其他分析器来完成其工作。例如：SharpeRatio 使用  

TimeReturn 的输出进行计算。  

这些子分析器或从属分析器也将插入到创建它们的同一策略中。但它们对用户是完全 

不可见的。  

属性 #  

为了完成预期的工作，分析器对象提供了一些默认属性，这些属性会自动传递并在实 

例中设置，以便于使用：  

•  self.strategy  ：对分析器对象正在运行的策略子类的引用。策略可以访问的任 

何内容，分析器也可以访问。  

•  self.datas[x]  ：策略中存在的数据源数组。虽然可以通过策略引用访问，但快 

捷方式使工作更舒适。  

•  self.data  ：对 self.datas[0]  的快捷方式，以增加舒适度。  

•  self.dataX  ：对不同的 self.datas[x]  的快捷方式。  

还有一些其他别名可用，尽管它们可能有些多余：  

•  self.dataX_Y  ，其中 X 是对 self.datas[X]  的引用，Y 指的是线条，最终指向  

self.datas[X].lines[Y]  。 如果线条有名称，还可以使用以下命名：  

•  self.dataX_Name  ，解析为 self.datas[X].Name  ，按名称而不是按索引返回 

线条。 对于第一个数据，最后两个快捷方式在没有初始 X 数字引用的情况下可用。例 

如：  

•  self.data_2 指 self.datas[0].lines[2]  。  

•  self.data_close 指 self.datas[0].close  。  

返回分析结果 #  

Analyzer 基类创建了一个 self.rets   （类型为 collections.OrderedDict）成员属性来 

返回分析结果。这是在 create_analysis 方法中完成的，子类可以覆盖该方法以创 

建自定义分析器。  

操作模式 #  

虽然分析器对象不是线条对象，因此不迭代线条，但它们被设计为遵循相同的操作模 

式。  

•  在系统启动之前实例化（因此调用 __init__ ）。  

•  使用 start 信号表示操作开始。  

  
﻿  

•  prenext / nextstart / next 方法将根据策略的计算最小周期被调用。  

•  prenext 和 nextstart  的默认行为是调用 next  ，因为分析器可能会从系统开始 

运行的第一刻起进行分析。  

•  在线条对象中通常调用 len(self)  以检查实际条数。这在分析器中也适用，通过 

返回 self.strategy  的值。  

•  订单和交易将像通知策略一样通过 notify_order 和 notify_trade 进行通知。  

•  现金和价值也将通过 notify_cashvalue 方法像对策略那样进行通知。  

•  现金、价值、基金价值和基金份额也将通过 notify_fund 方法像对策略那样进行 

通知。  

•  使用 stop 信号表示操作结束。  

•  一旦常规操作周期完成，分析器将提供用于提取/输出信息的附加方法：  

    ￮  get_analysis  ：理想情况下（不是强制的）返回一个包含分析结果的字典样 

    对象。  

    ￮  print 使用标准的 backtrader.WriterFile （除非被覆盖）写出 get_analysis  

    的分析结果。  

    ￮  pprint  （漂亮打印）使用 Python 的 pprint 模块打印 get_analysis 结果。  

最后：  

get_analysis 创建一个类型为 collections.OrderedDict 的成员属性 self.ret  ，分析 

器将分析结果写入其中。  

分析器的子类可以覆盖此方法以改变此行为。  

分析器模式 #  

在 backtrader 平台中开发分析器对象揭示了生成分析的两种不同使用模式：  

•  在执行过程中通过 notify_xxx 和 next 方法收集信息，并在 next  中生成当前的 

分析信息。  

    ￮  例如，TradeAnalyzer 仅使用 notify_trade 方法生成统计数据。  

•  如上所述收集信息（或不收集），但在 stop 方法期间进行单次生成分析。  

    ￮  SQN （系统质量编号）在 notify_trade 期间收集交易信息，但在 stop 方 

    法期间生成统计数据。  

快速示例 #  

  
﻿  

尽可能简单：  

Python  
from __future__ import (absolute_import, division, print_function,  
unicode_literals)  
import datetime  
import backtrader as bt  
import backtrader.analyzers as btanalyzers  
import backtrader.feeds as btfeeds  
import backtrader.strategies as btstrats  
cerebro = bt.Cerebro()  
# 数据 dataname =  '../datas/sample/2005-2006-day-001.txt'data =  
btfeeds.BacktraderCSVData(dataname=dataname)  
cerebro.adddata(data)  
# 策略 cerebro.addstrategy(btstrats.SMA_CrossOver)  

# 分析器 cerebro.addanalyzer(btanalyzers.SharpeRatio,  
_name='mysharpe')  
thestrats = cerebro.run()  
thestrat = thestrats[0]  
print('Sharpe Ratio:', thestrat.analyzers.mysharpe.get_analysis())  

执行它（已将其存储在 analyzer-test.py  中）：  

Bash  
$ ./analyzer-test.py  
Sharpe Ratio: {'sharperatio': 11.647332609673256}  

没有绘图，因为 SharpeRatio 是在计算结束时的单一值。  

分析器的取证分析 让我们重复一下，分析器不是线条对象，但为了无缝集成到  

backtrader 生态系统中，遵循了几个线条对象的内部 API 约定（实际上是它们的混合）。  

注意  

SharpeRatio 的代码已经演变，例如考虑了年化，此版本仅应作为参考。  

请查看分析器参考。  

此外还有一个 SharpeRatio_A 提供了直接以年化形式给出的值，而不管所需的时间范 

围。  

SharpeRatio 的代码作为基础（简化版本）：  

Python  
from __future__ import (absolute_import, division, print_function,  
unicode_literals)  
import operator  

  
﻿  

from backtrader.utils.py3 import map  
from backtrader import Analyzer, TimeFrame  
from backtrader.mathsupport import average, standarddev  
from backtrader.analyzers import AnnualReturn  
class SharpeRatio(Analyzer):  
    params = (('timeframe', TimeFrame.Years), ( 'riskfreerate',  
0.01),)  
    def __init__(self):  
        super(SharpeRatio, self).__init__()  
        self.anret = AnnualReturn()  
    def start(self):  
        # Not needed ... but could be used        pass  
    def next(self):  
        # Not needed ... but could be used        pass  
    def stop(self):  
        retfree = [self.p.riskfreerate] * len(self.anret.rets)  
        retavg = average(list(map(operator.sub, self.anret.rets,  
retfree)))  
        retdev = standarddev(self.anret.rets)  
        self.ratio = retavg / retdev  
    def get_analysis(self):  
        return dict(sharperatio=self.ratio)  

代码可以分解为：  

•   params 声明  

     ￮  尽管声明的参数没有使用（作为示例），分析器像大多数其他对象一样支持参 

    数。  

•   __init__ 方法  

     ￮  就像策略在 __init__  中声明指标一样，分析器也声明支持对象。  

     ￮  在这种情况下：SharpeRatio 使用年度回报计算。计算将是自动的，并且将可 

     用于 SharpeRatio 进行自己的计算。  

•   next 方法  

     ￮  SharpeRatio 不需要它，但此方法将在父策略 next  的每次调用后被调用。  

•   start 方法  

     ￮  在回测开始前调用。可以用于额外的初始化任务。  

SharpeRatio 不需要它。  

•   stop 方法  

  
﻿  

    ￮  在回测结束后调用。就像 SharpeRatio 所做的那样，它可以用于完成/进行计 

    算。  

•   get_analysis 方法（返回字典）  

    ￮  为外部调用者提供生成的分析。  

返回：包含分析结果的字典。  

参考 #  

Python  
class backtrader.Analyzer()  

Analyzer 基类。所有分析器都是此类的子类。  

分析器实例在策略的框架内运行，并为该策略提供分析。  

自动设置的成员属性：  

•   self.strategy  （提供对策略及其可访问内容的访问）  

•   self.datas[x] 提供对系统中存在的数据源数组的访问，这些数据源也可以通过 

策略引用访问  

•   self.data 提供对 self.datas[0]  的访问  

•   self.dataX -> self.datas[X]  

•   self.dataX_Y -> self.datas[X].lines[Y]  

•   self.dataX_name -> self.datas[X].name  

•   self.data_name -> self.datas[0].name  

•   self.data_Y -> self.datas[0].lines[Y]  

这不是线条对象，但方法和操作遵循相同的设计：  

•   在实例化和初始设置期间 __init__  

•   使用 start /  stop 表示操作的开始和结束  

•   prenext / nextstart / next 方法家族，遵循策略中相同方法的调用  

•   notify_trade / notify_order / notify_cashvalue / notify_fund 接收与策略 

等效方法相同的通知  

操作模式是开放的，没有首选模式。因此，分析可以通过 next 调用生成，在 stop 期 

间生成，也可以通过单个方法如 notify_trade 生成。  

重要的是覆盖 get_analysis  以返回包含分析结果的字典样对象（实际格式取决于实 

现）。  

  
﻿  

•   start()  

    ￮   调用以指示操作开始，给分析器时间设置所需内容。  

•   stop()  

    ￮   调用以指示操作结束，给分析器时间关闭所需内容。  

•   prenext()  

    ￮   在策略的每次 prenext 调用期间调用，直到达到策略的最小周期。  

    ￮   分析器的默认行为是调用 next  。  

•   nextstart()  

    ￮   在策略的 nextstart 调用时调用一次，当首次达到最小周期时。  

•   next()  

    ￮   在策略的每次 next 调用期间调用，一旦达到策略的最小周期。  

•   notify_cashvalue(cash, value)  

    ￮   在每个 next 周期之前接收现金/价值通知。  

•   notify_fund(cash, value, fundvalue, shares)  

    ￮   接收当前现金、价值、基金价值和基金份额。  

•   notify_order(order)  

    ￮   在每个 next 周期之前接收订单通知。  

•   notify_trade(trade)  

    ￮   在每个 next 周期之前接收交易通知。  

•   get_analysis()  

    ￮   返回包含分析结果的字典样对象。  

    ￮   字典中分析结果的键和值的格式取决于实现。  

    ￮   甚至不强制结果是字典样对象，只是一种约定。  

    ￮   默认实现返回由默认 create_analysis 方法创建的默认 OrderedDict  

    rets  。  

•   create_analysis()  

    ￮   供子类覆盖。提供创建保存分析结果的结构的机会。  

    ￮   默认行为是创建名为  rets  的 OrderedDict  。  

  
﻿  

•   print(*args, **kwargs)  

     ￮  使用标准 Writerfile 对象打印 get_analysis 返回的结果，默认写入标准 

    输出。  

•   pprint(*args, **kwargs)  

     ￮  使用 Python 的 pprint 模块打印 get_analysis 返回的结果。  

•   len()  

     ￮  支持在分析器上调用 len  ，实际上返回分析器运行的策略的当前长度。  

🔗 原文链接： https://www.poloxue.com/backtrader/...  

⏰ 剪存时间：2025-03- 15 16:00:29 (UTC+8)  

✂️ 本文档由 飞书剪存 一键生成  

analyzer-参考 #  

AnnualReturn #  

Python  
class backtrader.analyzers.AnnualReturn()  

该分析器通过查看年的起点和终点来计算年度回报率。  

参数：  

•   无  

成员属性：  

•   rets  ：计算出的年度回报率列表  

•   ret  ：年度回报率字典（键：年份）  

get_analysis ： 返回包含年度回报率的字典（键：年份）  

  

Calmar #  

Python  
class backtrader.analyzers.Calmar()  

该分析器计算 Calmar 比率，时间框架可以与基础数据使用的不同。  

  
﻿  

参数：  

•   timeframe   （默认：无）：如果为 None，将使用系统中第一个数据的时间框架。  

•   compression   （默认：无）：仅用于子日时间框架，例如通过指定  

“TimeFrame.Minutes” 和 60 作为压缩在每小时时间框架上工作。  

•   fund  （默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode -  

True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的  

set_fundmode  。  

get_analysis ： 返回一个包含时间段键和对应滚动 Calmar 比率的 OrderedDict。  

  

DrawDown #  

Python  
class backtrader.analyzers.DrawDown()  

该分析器计算交易系统的回撤统计数据，如百分比和美元的回撤值、最大回撤值、回 

撤长度和最大回撤长度。  

参数：  

•   fund  （默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode -  

True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的  

set_fundmode  。  

get_analysis ： 返回一个包含回撤统计数据的字典（支持 . 符号表示法和子字典），可 

用的键/属性包括：  

•   drawdown  ：回撤值（百分比）  

•   moneydown  ：回撤值（货币单位）  

•   len  ：回撤长度  

•   max.drawdown  ：最大回撤值（百分比）  

•   max.moneydown  ：最大回撤值（货币单位）  

•   max.len  ：最大回撤长度  

  

TimeDrawDown #  

Python  

  
﻿  

class backtrader.analyzers.TimeDrawDown()  

该分析器计算在选定时间框架上的交易系统回撤，可以与基础数据使用的时间框架不 

同。  

参数：  

•   timeframe   （默认：无）：如果为 None，将使用系统中第一个数据的时间框架。  

•   compression   （默认：无）：仅用于子日时间框架，例如通过指定  

“TimeFrame.Minutes” 和 60 作为压缩在每小时时间框架上工作。  

•   fund  （默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode -  

True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的  

set_fundmode  。  

get_analysis ： 返回一个包含回撤统计数据的字典（支持 . 符号表示法和子字典），可 

用的键/属性包括：  

•   drawdown  ：回撤值（百分比）  

•   maxdrawdown  ：最大回撤值（货币单位）  

•   maxdrawdownperiod  ：回撤长度  

  

GrossLeverage #  

Python  
class backtrader.analyzers.GrossLeverage()  

该分析器计算当前策略的总杠杆。  

参数：  

•   fund  （默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode -  

True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的  

set_fundmode  。  

get_analysis ： 返回一个字典，其中返回值为值，每个返回值的日期时间点为键。  

  

PositionsValue #  

Python  
class backtrader.analyzers.PositionsValue()  

  
﻿  

该分析器报告当前数据集的仓位价值。  

参数：  

•   timeframe  （默认：无）：如果为 None，将使用系统中第一个数据的时间框架。  

•   compression  （默认：无）：仅用于子日时间框架，例如通过指定  

“TimeFrame.Minutes” 和 60 作为压缩在每小时时间框架上工作。  

•   headers  （默认：False）：在保存结果的字典中添加一个初始键，名称为数据的 

名称（‘Datetime’ 为键）。  

•   cash  （默认：False）：包括实际现金作为额外仓位（对于标头，将使用名称  

‘cash’）。  

get_analysis ： 返回一个字典，其中返回值为值，每个返回值的日期时间点为键。  

  

PyFolio #  

Python  
class backtrader.analyzers.PyFolio()  

该分析器使用 4 个子分析器收集数据，并将其转换为与 pyfolio 兼容的数据集。  

子分析器：  

•   TimeReturn  ：用于计算全球投资组合价值的回报。  

•   PositionsValue  ：用于计算每个数据的仓位价值。设置 headers 和 cash 参数 

为 True 。  

•   Transactions  ：用于记录每个数据上的每笔交易（数量、价格、价值）。设置  

headers 参数为 True 。  

•   GrossLeverage  ：跟踪总杠杆（策略投资的程度）。  

参数： 这些参数透明地传递给子分析器。  

•   timeframe  （默认： bt.TimeFrame.Days ）：如果为 None，将使用系统中第一 

个数据的时间框架。  

•   compression  （默认：1）：如果为 None，将使用系统中第一个数据的压缩。  

get_analysis ： 返回一个字典，其中返回值为值，每个返回值的日期时间点为键。  

get_pf_items ： 返回一个包含 4 个元素的元组，可用于进一步处理 pyfolio  。  

•   returns  ， positions  ， transactions  ， gross_leverage  

由于这些对象旨在作为 pyfolio 的直接输入，因此此方法会本地导入 pandas，将内部  

  
﻿  

backtrader 结果转换为 pandas DataFrames，这是例如 pyfolio.create_full_tear_sheet  

预期的输入。如果未安装 pandas，该方法将失败。  

  

LogReturnsRolling #  

Python  
class backtrader.analyzers.LogReturnsRolling()  

该分析器计算给定时间框架和压缩的滚动回报。  

参数：  

•   timeframe   （默认：无）：如果为 None，将使用系统中第一个数据的时间框架。  

•   compression    （默认：无）：仅用于子日时间框架，例如通过指定  

“TimeFrame.Minutes” 和 60 作为压缩在每小时时间框架上工作。  

•   data   （默认：无）：跟踪的参考资产，而不是投资组合价值。  

get_analysis ： 返回一个字典，其中返回值为值，每个返回值的日期时间点为键。  

  

PeriodStats #  

Python  
class backtrader.analyzers.PeriodStats()  

计算给定时间框架的基本统计数据。  

参数：  

•   timeframe   （默认：Years ）：如果为 None，将使用系统中第一个数据的时间框 

架。  

•   compression    （默认：1）：仅用于子日时间框架，例如通过指定  

“TimeFrame.Minutes” 和 60 作为压缩在每小时时间框架上工作。  

•   fund   （默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode -  

True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的  

set_fundmode  。  

get_analysis ： 返回一个包含以下键的字典：  

•   average  

•   stddev  

  
﻿  

•   positive  

•   negative  

•   nochange  

•   best  

•   worst  

如果参数 zeroispos 设置为 True ，则没有变化的周期将计为正数。  

  

Returns #  

Python  
class backtrader.analyzers.Returns()  

使用对数方法计算总回报、平均回报、复合回报和年化回报。  

参数：  

•   timeframe    （默认：无）：如果为 None，将使用系统中第一个数据的时间框架。  

•   compression    （默认：无）：仅用于子日时间框架，例如通过指定  

“TimeFrame.Minutes” 和 60 作为压缩在每小时时间框架上工作。  

•   tann   （默认：无）：用于年化（归一化）回报的周期数：  

     ￮  天：252  

     ￮  周：52  

     ￮  月：12  

     ￮  年：1  

•   fund   （默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode -  

True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的  

set_fundmode  。  

get_analysis ： 返回一个字典，其中返回值为值，每个返回值的日期  

时间点为键。返回的字典包含以下键：  

•   rtot  ：总复合回报  

•   ravg  ：整个期间的平均回报（特定时间框架）  

•   rnorm  ：年化/归一化回报  

•   rnorm100  ：以  100% 表示的年化/归一化回报  

  
﻿  

  

SharpeRatio #  

Python  
class backtrader.analyzers.SharpeRatio()  

该分析器使用风险资产（即利率）计算策略的夏普比率。  

参数：  

•   timeframe  （默认：TimeFrame.Years）  

•   compression   （默认：1）：仅用于子日时间框架，例如通过指定  

“TimeFrame.Minutes” 和 60 作为压缩在每小时时间框架上工作。  

•   riskfreerate   （默认：0.01 -> 1%）：以年利率表示（见下文 convertrate ）。  

•   convertrate   （默认：True）：将年利率转换为月、周或日利率。不支持子日转 

换。  

•   factor  （默认：无）：如果为 None，将从预定义表中选择年到所选时间框架的转 

换因子。天：252 ，周：52 ，月：12，年：1。否则将使用指定的值。  

•   annualize  （默认：False）：如果 convertrate 为 True ，夏普比率将在所选时 

间框架内提供。在大多数情况下，夏普比率以年化形式提供。  

•   stddev_sample   （默认：False）：如果设置为 True ，将在均值中减少分母  1 来计 

算标准差。这在计算标准差时使用，如果认为并非所有样本都用于计算。这被称为贝 

塞尔修正。  

•   daysfactor   （默认：无）：旧命名为因子。如果设置为除 None 之外的任何值， 

并且时间框架为 TimeFrame.Days ，将假设这是旧代码并使用该值。  

•   legacyannual   （默认：False）：使用 AnnualReturn 分析器，顾名思义仅适用于 

年份。  

•   fund  （默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode -  

True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的  

set_fundmode  。  

get_analysis ： 返回一个包含键 “sharperatio” 的字典，其中包含比率。  

  

SharpeRatio_A #  

Python  

  
﻿  

class backtrader.analyzers.SharpeRatio_A()  

夏普比率的扩展，直接以年化形式返回夏普比率。  

更改的参数：  

•   annualize    （默认：True）  

  

SQN #  

Python  
class backtrader.analyzers.SQN()  

SQN 或系统质量数。由 Van K. Tharp 定义，用于分类交易系统。  

1.6 -  1.9 低于平均水平 2.0 - 2.4 平均水平 2.5 - 2.9  良好 3.0 - 5.0 优秀 5.1 - 6.9 杰出  

7.0 - 圣杯？  

公式：  

Plaintext  
SquareRoot(NumberTrades) * Average(TradesProfit) /  
StdDev(TradesProfit)  

当交易数量 >= 30 时，sqn 值应被认为是可靠的。  

get_analysis ： 返回一个包含键 “sqn” 和 “trades” 的字典（已考虑的交易数量）。  

  

TimeReturn #  

Python  
class backtrader.analyzers.TimeReturn()  

该分析器通过查看时间框架的起点和终点来计算回报。  

参数：  

•   timeframe    （默认：无）：如果为 None，将使用系统中第一个数据的时间框架。  

•   compression    （默认：无）：仅用于子日时间框架，例如通过指定  

“TimeFrame.Minutes” 和 60 作为压缩在每小时时间框架上工作。  

•   data   （默认：无）：跟踪的参考资产，而不是投资组合价值。  

get_analysis ： 返回一个字典，其中返回值为值，每个返回值的日期时间点为键。  

  
﻿  

  

TradeAnalyzer #  

Python  
class backtrader.analyzers.TradeAnalyzer()  

提供已平仓交易的统计数据（还保持未平仓交易的计数）。  

•   总开仓/平仓交易  

•   连胜/连败  当前/最长  

•   总损益/平均损益  

•   胜/负 计数/总损益/平均损益/最大损益  

•   多/空 计数/总损益/平均损益/最大损益  

•   胜/负 计数/总损益/平均损益/最大损益  

注意： 分析器使用“ 自动”字典字段，这意味着如果没有执行交易，则不会生成统计数 

据。在这种情况下， get_analysis 返回的字典中将有一个单独的字段/子字段：  

Plaintext  

dictname[‘total’][‘total’] 将具有值 0 （该字段也可以使用点符号  

dictname.total.total 访问）。  

  

Transactions #  

Python  
class backtrader.analyzers.Transactions()  

该分析器报告系统中每个数据的交易情况。  

参数：  

•   headers    （默认：True）：在保存结果的字典中添加一个初始键，名称为数据的名 

称。  

该分析器旨在便于与 pyfolio 集成，并从用于它的样本中获取标题名称：  

•   ‘date’, ‘amount’, ‘price’, ‘sid’, ‘symbol’, ‘value’  

get_analysis ： 返回一个字典，其中返回值为值，每个返回值的日期时间点为键。  

  

  
﻿  

VWR #  

Python  
class backtrader.analyzers.VWR()  

可变性加权回报：使用对数回报的更好的夏普比率。  

别名：  

•   VariabilityWeightedReturn  

参数：  

•   timeframe  （默认：无）：如果为 None，则整个回测期间的回报将被报告。  

•   compression  （默认：无）：仅用于子日时间框架，例如通过指定  

“TimeFrame.Minutes” 和 60 作为压缩在每小时时间框架上工作。  

•   tann  （默认：无）：用于年化（归一化）平均回报的周期数。如果为 None，则使 

用标准 t 值，即：  

    ￮  天：252  

    ￮   周：52  

    ￮   月：12  

    ￮  年：1  

•   tau  （默认：2.0）：计算因子（见文献）  

•   sdev_max  （默认：0.20）：最大标准差（见文献）  

•   fund  （默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode -  

True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的  

set_fundmode  。  

get_analysis ： 返回一个字典，其中返回值为值，每个返回值的日期时间点为键。返 

回的字典包含以下键：  

•   vwr  ：可变性加权回报  

🔗 原文链接： https://www.poloxue.com/backtrader/...  

⏰ 剪存时间：2025-03- 15 15:57:15 (UTC+8)  

✂️ 本文档由 飞书剪存 一键生成  

observers -统计  

  
