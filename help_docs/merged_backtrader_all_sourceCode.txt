合并的文件来自: D:\BT2025\bt_py_to_txt  

==================================================  

  

  

##############################  

# 文件: analyzer.txt  

##############################  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  
﻿<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import calendar  

from collections import OrderedDict  

import datetime  

import pprint as pp  

  

import backtrader as bt  

from backtrader import TimeFrame  

from backtrader.utils.py3 import MAXINT, with_metaclass  

  

  

class MetaAnalyzer(bt.MetaParams):  

    def donew(cls, *args, **kwargs):  

        '''  

        Intercept the strategy parameter  

        '''  

        # Create the object and set the params in place  

        _obj, args, kwargs = super(MetaAnalyzer, cls).donew(*args,  

**kwargs)  

  

        _obj._children = list()  
﻿  

        _obj.strategy = strategy = bt.metabase.findowner(_obj,  

bt.Strategy)  

        _obj._parent = bt.metabase.findowner(_obj, Analyzer)  

  

        # Register with a master observer if created inside one  

        masterobs = bt.metabase.findowner(_obj, bt.Observer)  

        if masterobs is not None:  

            masterobs._register_analyzer(_obj)  

  

        _obj.datas = strategy.datas  

  

        # For each data add aliases: for first data: data and data0  

        if _obj.datas:  

            _obj.data = data = _obj.datas[0]  

  

            for l, line in enumerate(data.lines):  

                linealias = data._getlinealias(l)  

                if linealias:  

                    setattr(_obj, 'data_%s' % linealias, line)  

                setattr(_obj, 'data_%d' % l, line)  

  

            for d, data in enumerate(_obj.datas):  

                setattr(_obj, 'data%d' % d, data)  

  

                for l, line in enumerate(data.lines):  

                    linealias = data._getlinealias(l)  
﻿                    if linealias:  

                        setattr(_obj, 'data%d_%s' % (d, linealias),  

line)  

                    setattr(_obj, 'data%d_%d' % (d, l), line)  

  

        _obj.create_analysis()  

  

        # Return to the normal chain  

        return _obj, args, kwargs  

  

    def dopostinit(cls, _obj, *args, **kwargs):  

        _obj, args, kwargs = \  

            super(MetaAnalyzer, cls).dopostinit(_obj, *args, **kwargs)  

  

        if _obj._parent is not None:  

            _obj._parent._register(_obj)  

  

        # Return to the normal chain  

        return _obj, args, kwargs  

  

  

class Analyzer(with_metaclass(MetaAnalyzer, object)):  

    '''Analyzer base class. All analyzers are subclass of this one  

  

    An Analyzer instance operates in the frame of a strategy and  

provides an  

    analysis for that strategy.  
﻿  

    Automagically set member attributes:  

  

      - ``self.strategy`` (giving access to the *strategy* and  

anything  

        accessible from it)  

  

      - ``self.datas[x]`` giving access to the array of data feeds  

present in  

        the the system, which could also be accessed via the strategy  

reference  

  

      - ``self.data``, giving access to ``self.datas[0]``  

  

      - ``self.dataX`` -> ``self.datas[X]``  

  

      - ``self.dataX_Y`` -> ``self.datas[X].lines[Y]``  

  

      - ``self.dataX_name`` -> ``self.datas[X].name``  

  

      - ``self.data_name`` -> ``self.datas[0].name``  

  

      - ``self.data_Y`` -> ``self.datas[0].lines[Y]``  

  

    This is not a *Lines* object, but the methods and operation follow  

the same  

    design  

  
﻿      - ``__init__`` during instantiation and initial setup  

  

      - ``start`` / ``stop`` to signal the begin and end of operations  

  

      - ``prenext`` / ``nextstart`` / ``next`` family of methods that  

follow  

        the calls made to the same methods in the strategy  

  

      - ``notify_trade`` / ``notify_order`` / ``notify_cashvalue`` /  

        ``notify_fund`` which receive the same notifications as the  

equivalent  

        methods of the strategy  

  

    The mode of operation is open and no pattern is preferred. As such  

the  

    analysis can be generated with the ``next`` calls, at the end of  

operations  

    during ``stop`` and even with a single method like  

``notify_trade``  

  

    The important thing is to override ``get_analysis`` to return a  

*dict-like*  

    object containing the results of the analysis (the actual format  

is  

    implementation dependent)  

  

    '''  

    csv = True  

  
﻿    def __len__(self):  

        '''Support for invoking ``len`` on analyzers by actually  

returning the  

        current length of the strategy the analyzer operates on'''  

        return len(self.strategy)  

  

    def _register(self, child):  

        self._children.append(child)  

  

    def _prenext(self):  

        for child in self._children:  

            child._prenext()  

  

        self.prenext()  

  

    def _notify_cashvalue(self, cash, value):  

        for child in self._children:  

            child._notify_cashvalue(cash, value)  

  

        self.notify_cashvalue(cash, value)  

  

    def _notify_fund(self, cash, value, fundvalue, shares):  

        for child in self._children:  

            child._notify_fund(cash, value, fundvalue, shares)  

  

        self.notify_fund(cash, value, fundvalue, shares)  

  
﻿    def _notify_trade(self, trade):  

        for child in self._children:  

            child._notify_trade(trade)  

  

        self.notify_trade(trade)  

  

    def _notify_order(self, order):  

        for child in self._children:  

            child._notify_order(order)  

  

        self.notify_order(order)  

  

    def _nextstart(self):  

        for child in self._children:  

            child._nextstart()  

  

        self.nextstart()  

  

    def _next(self):  

        for child in self._children:  

            child._next()  

  

        self.next()  

  

    def _start(self):  

        for child in self._children:  

            child._start()  
﻿  

        self.start()  

  

    def _stop(self):  

        for child in self._children:  

            child._stop()  

  

        self.stop()  

  

    def notify_cashvalue(self, cash, value):  

        '''Receives the cash/value notification before each next  

cycle'''  

        pass  

  

    def notify_fund(self, cash, value, fundvalue, shares):  

        '''Receives the current cash, value, fundvalue and fund  

shares'''  

        pass  

  

    def notify_order(self, order):  

        '''Receives order notifications before each next cycle'''  

        pass  

  

    def notify_trade(self, trade):  

        '''Receives trade notifications before each next cycle'''  

        pass  

  
﻿    def next(self):  

        '''Invoked for each next invocation of the strategy, once the  

minum  

        preiod of the strategy has been reached'''  

        pass  

  

    def prenext(self):  

        '''Invoked for each prenext invocation of the strategy, until  

the minimum  

        period of the strategy has been reached  

  

        The default behavior for an analyzer is to invoke ``next``  

        '''  

        self.next()  

  

    def nextstart(self):  

        '''Invoked exactly once for the nextstart invocation of the  

strategy,  

        when the minimum period has been first reached  

        '''  

        self.next()  

  

    def start(self):  

        '''Invoked to indicate the start of operations, giving the  

analyzer  

        time to setup up needed things'''  

        pass  

  
﻿    def stop(self):  

        '''Invoked to indicate the end of operations, giving the  

analyzer  

        time to shut down needed things'''  

        pass  

  

    def create_analysis(self):  

        '''Meant to be overriden by subclasses. Gives a chance to  

create the  

        structures that hold the analysis.  

  

        The default behaviour is to create a ``OrderedDict`` named  

``rets``  

        '''  

        self.rets = OrderedDict()  

  

    def get_analysis(self):  

        '''Returns a *dict-like* object with the results of the  

analysis  

  

        The keys and format of analysis results in the dictionary is  

        implementation dependent.  

  

        It is not even enforced that the result is a *dict-like  

object*, just  

        the convention  

  

        The default implementation returns the default OrderedDict  
﻿``rets``  

        created by the default ``create_analysis`` method  

  

        '''  

        return self.rets  

  

    def print(self, *args, **kwargs):  

        '''Prints the results returned by ``get_analysis`` via a  

standard  

        ``Writerfile`` object, which defaults to writing things to  

standard  

        output  

        '''  

        writer = bt.WriterFile(*args, **kwargs)  

        writer.start()  

        pdct = dict()  

        pdct[self.__class__.__name__] = self.get_analysis()  

        writer.writedict(pdct)  

        writer.stop()  

  

    def pprint(self, *args, **kwargs):  

        '''Prints the results returned by ``get_analysis`` using the  

pretty  

        print Python module (*pprint*)  

        '''  

        pp.pprint(self.get_analysis(), *args, **kwargs)  

  

  
﻿class MetaTimeFrameAnalyzerBase(Analyzer.__class__):  

    def __new__(meta, name, bases, dct):  

        # Hack to support original method name  

        if '_on_dt_over' in dct:  

            dct['on_dt_over'] = dct.pop('_on_dt_over')  # rename  

method  

  

        return super(MetaTimeFrameAnalyzerBase, meta).__new__(meta,  

name,  

                                                              bases,  

dct)  

  

  

class TimeFrameAnalyzerBase(with_metaclass(MetaTimeFrameAnalyzerBase,  

                                           Analyzer)):  

    params = (  

         ('timeframe', None),  

         ('compression', None),  

         ('_doprenext', True),  

    )  

  

    def _start(self):  

        # Override to add specific attributes  

        self.timeframe = self.p.timeframe or self.data._timeframe  

        self.compression = self.p.compression or  

self.data._compression  

  

        self.dtcmp, self.dtkey =  
﻿self._get_dt_cmpkey(datetime.datetime.min)  

        super(TimeFrameAnalyzerBase, self)._start()  

  

    def _prenext(self):  

        for child in self._children:  

            child._prenext()  

  

        if self._dt_over():  

            self.on_dt_over()  

  

        if self.p._doprenext:  

            self.prenext()  

  

    def _nextstart(self):  

        for child in self._children:  

            child._nextstart()  

  

        if self._dt_over() or not self.p._doprenext:  # exec if no  

prenext  

            self.on_dt_over()  

  

        self.nextstart()  

  

    def _next(self):  

        for child in self._children:  

            child._next()  

  
﻿        if self._dt_over():  

            self.on_dt_over()  

  

        self.next()  

  

    def on_dt_over(self):  

        pass  

  

    def _dt_over(self):  

        if self.timeframe == TimeFrame.NoTimeFrame:  

            dtcmp, dtkey = MAXINT, datetime.datetime.max  

        else:  

            # With >= 1.9.x the system datetime is in the strategy  

            dt = self.strategy.datetime.datetime()  

            dtcmp, dtkey = self._get_dt_cmpkey(dt)  

  

        if self.dtcmp is None or dtcmp > self.dtcmp:  

            self.dtkey, self.dtkey1 = dtkey, self.dtkey  

            self.dtcmp, self.dtcmp1 = dtcmp, self.dtcmp  

            return True  

  

        return False  

  

    def _get_dt_cmpkey(self, dt):  

        if self.timeframe == TimeFrame.NoTimeFrame:  

            return None, None  

  
﻿        if self.timeframe == TimeFrame.Years:  

            dtcmp = dt.year  

            dtkey = datetime.date(dt.year, 12, 31)  

  

        elif self.timeframe == TimeFrame.Months:  

            dtcmp = dt.year * 100 + dt.month  

            _, lastday = calendar.monthrange(dt.year, dt.month)  

            dtkey = datetime.datetime(dt.year, dt.month, lastday)  

  

        elif self.timeframe == TimeFrame.Weeks:  

            isoyear, isoweek, isoweekday = dt.isocalendar()  

            dtcmp = isoyear * 100 + isoweek  

            sunday = dt + datetime.timedelta(days=7 - isoweekday)  

            dtkey = datetime.datetime(sunday.year, sunday.month,  

sunday.day)  

  

        elif self.timeframe == TimeFrame.Days:  

            dtcmp = dt.year * 10000 + dt.month * 100 + dt.day  

            dtkey = datetime.datetime(dt.year, dt.month, dt.day)  

  

        else:  

            dtcmp, dtkey = self._get_subday_cmpkey(dt)  

  

        return dtcmp, dtkey  

  

    def _get_subday_cmpkey(self, dt):  

        # Calculate intraday position  
﻿        point = dt.hour * 60 + dt.minute  

  

        if self.timeframe < TimeFrame.Minutes:  

            point = point * 60 + dt.second  

  

        if self.timeframe < TimeFrame.Seconds:  

            point = point * 1e6 + dt.microsecond  

  

        # Apply compression to update point position (comp 5 -> 200 //  

5)  

        point = point // self.compression  

  

        # Move to next boundary  

        point += 1  

  

        # Restore point to the timeframe units by de-applying  

compression  

        point *= self.compression  

  

        # Get hours, minutes, seconds and microseconds  

        if self.timeframe == TimeFrame.Minutes:  

            ph, pm = divmod(point, 60)  

            ps = 0  

            pus = 0  

        elif self.timeframe == TimeFrame.Seconds:  

            ph, pm = divmod(point, 60 * 60)  

            pm, ps = divmod(pm, 60)  
﻿            pus = 0  

        elif self.timeframe == TimeFrame.MicroSeconds:  

            ph, pm = divmod(point, 60 * 60 * 1e6)  

            pm, psec = divmod(pm, 60 * 1e6)  

            ps, pus = divmod(psec, 1e6)  

  

        extradays = 0  

        if ph > 23:  # went over midnight:  

            extradays = ph // 24  

            ph %= 24  

  

        # moving 1 minor unit to the left to be in the boundary  

        # pm -= self.timeframe == TimeFrame.Minutes  

        # ps -= self.timeframe == TimeFrame.Seconds  

        # pus -= self.timeframe == TimeFrame.MicroSeconds  

  

        tadjust = datetime.timedelta(  

            minutes=self.timeframe == TimeFrame.Minutes,  

            seconds=self.timeframe == TimeFrame.Seconds,  

            microseconds=self.timeframe == TimeFrame.MicroSeconds)  

  

        # Add extra day if present  

        if extradays:  

            dt += datetime.timedelta(days=extradays)  

  

        # Replace intraday parts with the calculated ones and update  

it  
﻿        dtcmp = dt.replace(hour=ph, minute=pm, second=ps,  

microsecond=pus)  

        dtcmp -= tadjust  

        dtkey = dtcmp  

  

        return dtcmp, dtkey  

  

  

  

##############################  

# 文件: broker.txt  

##############################  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  
﻿# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

from backtrader.comminfo import CommInfoBase  

from backtrader.metabase import MetaParams  

from backtrader.utils.py3 import with_metaclass  

  

from . import fillers as fillers  

from . import fillers as filler  

  

  

class MetaBroker(MetaParams):  

    def __init__(cls, name, bases, dct):  

        '''  

        Class has already been created ... fill missing methods if  

needed be  

        '''  

        # Initialize the class  

        super(MetaBroker, cls).__init__(name, bases, dct)  
﻿        translations = {  

            'get_cash': 'getcash',  

            'get_value': 'getvalue',  

        }  

  

        for attr, trans in translations.items():  

            if not hasattr(cls, attr):  

                setattr(cls, name, getattr(cls, trans))  

  

  

class BrokerBase(with_metaclass(MetaBroker, object)):  

    params = (  

         ('commission', CommInfoBase(percabs=True)),  

    )  

  

    def __init__(self):  

        self.comminfo = dict()  

        self.init()  

  

    def init(self):  

        # called from init and from start  

        if None not in self.comminfo:  

            self.comminfo = dict({None: self.p.commission})  

  

    def start(self):  

        self.init()  

  
﻿    def stop(self):  

        pass  

  

    def add_order_history(self, orders, notify=False):  

        '''Add order history. See cerebro for details'''  

        raise NotImplementedError  

  

    def set_fund_history(self, fund):  

        '''Add fund history. See cerebro for details'''  

        raise NotImplementedError  

  

    def getcommissioninfo(self, data):  

        '''Retrieves the ``CommissionInfo`` scheme associated with the  

given  

        ``data``'''  

        if data._name in self.comminfo:  

            return self.comminfo[data._name]  

  

        return self.comminfo[None]  

  

    def setcommission(self,  

                      commission=0.0, margin=None, mult=1.0,  

                      commtype=None, percabs=True, stocklike=False,  

                      interest=0.0, interest_long=False, leverage=1.0,  

                      automargin=False,  

                      name=None):  

  
﻿        '''This method sets a `` CommissionInfo`` object for assets  

managed in  

        the broker with the parameters. Consult the reference for  

        ``CommInfoBase``  

  

        If name is ``None``, this will be the default for assets for  

which no  

        other ``CommissionInfo`` scheme can be found  

        '''  

  

        comm = CommInfoBase(commission=commission, margin=margin,  

mult=mult,  

                            commtype=commtype, stocklike=stocklike,  

                            percabs=percabs,  

                            interest=interest,  

interest_long=interest_long,  

                            leverage=leverage, automargin=automargin)  

        self.comminfo[name] = comm  

  

    def addcommissioninfo(self, comminfo, name=None):  

        '''Adds a ``CommissionInfo`` object that will be the default  

for all assets if  

        ``name`` is ``None``'''  

        self.comminfo[name] = comminfo  

  

    def getcash(self):  

        raise NotImplementedError  

  
﻿    def getvalue(self, datas=None):  

        raise NotImplementedError  

  

    def get_fundshares(self):  

        '''Returns the current number of shares in the fund-like  

mode'''  

        return 1.0  # the abstract mode has only 1 share  

  

    fundshares = property(get_fundshares)  

  

    def get_fundvalue(self):  

        return self.getvalue()  

  

    fundvalue = property(get_fundvalue)  

  

    def set_fundmode(self, fundmode, fundstartval=None):  

        '''Set the actual fundmode (True or False)  

  

        If the argument fundstartval is not ``None``, it will used  

        '''  

        pass  # do nothing, not all brokers can support this  

  

    def get_fundmode(self):  

        '''Returns the actual fundmode (True or False)'''  

        return False  

  

    fundmode = property(get_fundmode, set_fundmode)  
﻿  

    def getposition(self, data):  

        raise NotImplementedError  

  

    def submit(self, order):  

        raise NotImplementedError  

  

    def cancel(self, order):  

        raise NotImplementedError  

  

    def buy(self, owner, data, size, price=None, plimit=None,  

            exectype=None, valid=None, tradeid=0, oco=None,  

            trailamount=None, trailpercent=None,  

            **kwargs):  

  

        raise NotImplementedError  

  

    def sell(self, owner, data, size, price=None, plimit=None,  

             exectype=None, valid=None, tradeid=0, oco=None,  

             trailamount=None, trailpercent=None,  

             **kwargs):  

  

        raise NotImplementedError  

  

    def next(self):  

        pass  

  
﻿# __all__ = ['BrokerBase', 'fillers', 'filler']  

  

  

  

##############################  

# 文件: cerebro.txt  

##############################  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  
﻿<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import datetime  

import collections  

import itertools  

import multiprocessing  

  

try:  # For new Python versions  

    collectionsAbc = collections.abc  # collections.Iterable ->  

collections.abc.Iterable  

except AttributeError:  # For old Python versions  

    collectionsAbc = collections  # Используем  

collections.Iterable  

  

import backtrader as bt  

from .utils.py3 import (map, range, zip, with_metaclass, string_types,  

                        integer_types)  

  

from . import linebuffer  

from . import indicator  

from .brokers import BackBroker  

from .metabase import MetaParams  

from . import observers  
﻿from .writer import WriterFile  

from .utils import OrderedDict, tzparse, num2date, date2num  

from .strategy import Strategy, SignalStrategy  

from .tradingcal import (TradingCalendarBase, TradingCalendar,  

                         PandasMarketCalendar)  

from .timer import Timer  

  

# Defined here to make it pickable. Ideally it could be defined inside  

Cerebro  

  

  

class OptReturn(object):  

    def __init__(self, params, **kwargs):  

        self.p = self.params = params  

        for k, v in kwargs.items():  

            setattr(self, k, v)  

  

  

class Cerebro(with_metaclass(MetaParams, object)):  

    '''Params:  

  

      - ``preload`` (default: ``True``)  

  

        Whether to preload the different ``data feeds`` passed to  

cerebro for  

        the Strategies  

  
﻿      - ``runonce`` (default: ``True``)  

  

        Run ``Indicators`` in vectorized mode to speed up the entire  

system.  

        Strategies and Observers will always be run on an event based  

basis  

  

      - ``live`` (default: ``False``)  

  

        If no data has reported itself as *live* (via the data's  

``islive``  

        method but the end user still want to run in ``live`` mode,  

this  

        parameter can be set to true  

  

        This will simultaneously deactivate ``preload`` and  

``runonce``. It  

        will have no effect on memory saving schemes.  

  

        Run ``Indicators`` in vectorized mode to speed up the entire  

system.  

        Strategies and Observers will always be run on an event based  

basis  

  

      - ``maxcpus`` (default: None -> all available cores)  

  

         How many cores to use simultaneously for optimization  

  

      - ``stdstats`` (default: ``True``)  
﻿  

        If True default Observers will be added: Broker (Cash and  

Value),  

        Trades and BuySell  

  

      - ``oldbuysell`` (default: ``False``)  

  

        If ``stdstats`` is ``True`` and observers are getting  

automatically  

        added, this switch controls the main behavior of the  

``BuySell``  

        observer  

  

        - ``False``: use the modern behavior in which the buy / sell  

signals  

          are plotted below / above the low / high prices respectively  

to avoid  

          cluttering the plot  

  

        - ``True``: use the deprecated behavior in which the buy /  

sell signals  

          are plotted where the average price of the order executions  

for the  

          given moment in time is. This will of course be on top of an  

OHLC bar  

          or on a Line on Cloe bar, difficulting the recognition of  

the plot.  

  

      - ``oldtrades`` (default: ``False``)  
﻿  

        If ``stdstats`` is ``True`` and observers are getting  

automatically  

        added, this switch controls the main behavior of the  

``Trades``  

        observer  

  

        - ``False``: use the modern behavior in which trades for all  

datas are  

          plotted with different markers  

  

        - ``True``: use the old Trades observer which plots the trades  

with the  

          same markers, differentiating only if they are positive or  

negative  

  

      - ``exactbars`` (default: ``False``)  

  

        With the default value each and every value stored in a line  

is kept in  

        memory  

  

        Possible values:  

          - ``True`` or ``1``: all "lines" objects reduce memory usage  

to the  

            automatically calculated minimum period.  

  

            If a Simple Moving Average has a period of 30, the  

underlying data  
﻿            will have always a running buffer of 30 bars to allow the  

            calculation of the Simple Moving Average  

  

            - This setting will deactivate ``preload`` and ``runonce``  

            - Using this setting also deactivates **plotting**  

  

          - ``-1``: datafreeds and indicators/operations at strategy  

level will  

            keep all data in memory.  

  

            For example: a ``RSI`` internally uses the indicator  

``UpDay`` to  

            make calculations. This subindicator will not keep all  

data in  

            memory  

  

            - This allows to keep ``plotting`` and ``preloading``  

active.  

  

            - ``runonce`` will be deactivated  

  

          - ``-2``: data feeds and indicators kept as attributes of  

the  

            strategy will keep all points in memory.  

  

            For example: a ``RSI`` internally uses the indicator  

``UpDay`` to  

            make calculations. This subindicator will not keep all  

data in  
﻿            memory  

  

            If in the ``__init__`` something like  

            ``a = self.data.close - self.data.high`` is defined, then  

``a``  

            will not keep all data in memory  

  

            - This allows to keep ``plotting`` and ``preloading``  

active.  

  

            - ``runonce`` will be deactivated  

  

      - ``objcache`` (default: ``False``)  

  

        Experimental option to implement a cache of lines objects and  

reduce  

        the amount of them. Example from UltimateOscillator::  

  

          bp = self.data.close - TrueLow(self.data)  

          tr = TrueRange(self.data)  # -> creates another  

TrueLow(self.data)  

  

        If this is ``True`` the 2nd ``TrueLow(self.data)`` inside  

``TrueRange``  

        matches the signature of the one in the ``bp`` calculation. It  

will be  

        reused.  

  
﻿        Corner cases may happen in which this drives a line object off  

its  

        minimum period and breaks things and it is therefore disabled.  

  

      - ``writer`` (default: ``False``)  

  

        If set to ``True`` a default WriterFile will be created which  

will  

        print to stdout. It will be added to the strategy (in addition  

to any  

        other writers added by the user code)  

  

      - ``tradehistory`` (default: ``False``)  

  

        If set to ``True``, it will activate update event logging in  

each trade  

        for all strategies. This can also be accomplished on a per  

strategy  

        basis with the strategy method ``set_tradehistory``  

  

      - ``optdatas`` (default: ``True``)  

  

        If ``True`` and optimizing (and the system can ``preload`` and  

use  

        ``runonce``, data preloading will be done only once in the  

main process  

        to save time and resources.  

  

        The tests show an approximate ``20%`` speed-up moving from a  
﻿sample  

        execution in ``83`` seconds to ``66``  

  

      - ``optreturn`` (default: ``True``)  

  

        If ``True`` the optimization results will not be full  

``Strategy``  

        objects (and all *datas*, *indicators*, *observers* ...) but  

and object  

        with the following attributes (same as in ``Strategy``):  

  

          - ``params`` (or ``p``) the strategy had for the execution  

          - ``analyzers`` the strategy has executed  

  

        In most occassions, only the *analyzers* and with which  

*params* are  

        the things needed to evaluate a the performance of a strategy.  

If  

        detailed analysis of the generated values for (for example)  

        *indicators* is needed, turn this off  

  

        The tests show a ``13% - 15%`` improvement in execution time.  

Combined  

        with ``optdatas`` the total gain increases to a total speed-up  

of  

        ``32%`` in an optimization run.  

  

      - ``oldsync`` (default: ``False``)  
﻿  

        Starting with release 1.9.0.99 the synchronization of multiple  

datas  

         (same or different timeframes) has been changed to allow datas  

of  

        different lengths.  

  

        If the old behavior with data0 as the master of the system is  

wished,  

        set this parameter to true  

  

      - ``tz`` (default: ``None``)  

  

        Adds a global timezone for strategies. The argument ``tz`` can  

be  

  

          - ``None``: in this case the datetime displayed by  

strategies will be  

            in UTC, which has been always the standard behavior  

  

          - ``pytz`` instance. It will be used as such to convert UTC  

times to  

            the chosen timezone  

  

          - ``string``. Instantiating a ``pytz`` instance will be  

attempted.  

  

          - ``integer``. Use, for the strategy, the same timezone as  

the  
﻿            corresponding ``data`` in the ``self.datas`` iterable  

(``0`` would  

            use the timezone from ``data0``)  

  

      - ``cheat_on_open`` (default: ``False``)  

  

        The ``next_open`` method of strategies will be called. This  

happens  

        before ``next`` and before the broker has had a chance to  

evaluate  

        orders. The indicators have not yet been recalculated. This  

allows  

        issuing an orde which takes into account the indicators of the  

previous  

        day but uses the ``open`` price for stake calculations  

  

        For cheat_on_open order execution, it is also necessary to  

make the  

        call ``cerebro.broker.set_coo(True)`` or instantite a broker  

with  

        ``BackBroker(coo=True)`` (where *coo* stands for cheat-on- 

open) or set  

        the ``broker_coo`` parameter to ``True``. Cerebro will do it  

        automatically unless disabled below.  

  

      - ``broker_coo`` (default: ``True``)  

  

        This will automatically invoke the ``set_coo`` method of the  

broker  
﻿        with ``True`` to activate ``cheat_on_open`` execution. Will  

only do it  

        if ``cheat_on_open`` is also ``True``  

  

      - ``quicknotify`` (default: ``False``)  

  

        Broker notifications are delivered right before the delivery  

of the  

        *next* prices. For backtesting this has no implications, but  

with live  

        brokers a notification can take place long before the bar is  

        delivered. When set to ``True`` notifications will be  

delivered as soon  

        as possible (see ``qcheck`` in live feeds)  

  

        Set to ``False`` for compatibility. May be changed to ``True``  

  

    '''  

  

    params = (  

         ('preload', True),  

         ('runonce', True),  

         ('maxcpus', None),  

         ('stdstats', True),  

         ('oldbuysell', False),  

         ('oldtrades', False),  

         ('lookahead', 0),  

         ('exactbars', False),  
﻿         ('optdatas', True),  

         ('optreturn', True),  

         ('objcache', False),  

         ('live', False),  

         ('writer', False),  

         ('tradehistory', False),  

         ('oldsync', False),  

         ('tz', None),  

         ('cheat_on_open', False),  

         ('broker_coo', True),  

         ('quicknotify', False),  

    )  

  

    def __init__(self):  

        self._dolive = False  

        self._doreplay = False  

        self._dooptimize = False  

        self.stores = list()  

        self.feeds = list()  

        self.datas = list()  

        self.datasbyname = collections.OrderedDict()  

        self.strats = list()  

        self.optcbs = list()  # holds a list of callbacks for opt  

strategies  

        self.observers = list()  

        self.analyzers = list()  

        self.indicators = list()  
﻿        self.sizers = dict()  

        self.writers = list()  

        self.storecbs = list()  

        self.datacbs = list()  

        self.signals = list()  

        self._signal_strat = (None, None, None)  

        self._signal_concurrent = False  

        self._signal_accumulate = False  

  

        self._dataid = itertools.count(1)  

  

        self._broker = BackBroker()  

        self._broker.cerebro = self  

  

        self._tradingcal = None  # TradingCalendar()  

  

        self._pretimers = list()  

        self._ohistory = list()  

        self._fhistory = None  

  

    @staticmethod  

    def iterize(iterable):  

        '''Handy function which turns things into things that can be  

iterated upon  

        including iterables  

        '''  

        niterable = list()  
﻿        for elem in iterable:  

            if isinstance(elem, string_types):  

                elem = (elem,)  

            elif not isinstance(elem, collectionsAbc.Iterable):  #  

Different functions will be called for different Python versions  

                elem = (elem,)  

  

            niterable.append(elem)  

  

        return niterable  

  

    def set_fund_history(self, fund):  

        '''  

        Add a history of orders to be directly executed in the broker  

for  

        performance evaluation  

  

          - ``fund``: is an iterable (ex: list, tuple, iterator,  

generator)  

            in which each element will be also an iterable (with  

length) with  

            the following sub-elements (2 formats are possible)  

  

            ``[datetime, share_value, net asset value]``  

  

            **Note**: it must be sorted (or produce sorted elements)  

by  

              datetime ascending  
﻿  

            where:  

  

              - ``datetime`` is a python ``date/datetime`` instance or  

a string  

                with format YYYY-MM-DD[THH:MM:SS[.us]] where the  

elements in  

                brackets are optional  

              - ``share_value`` is an float/integer  

              - ``net_asset_value`` is a float/integer  

        '''  

        self._fhistory = fund  

  

    def add_order_history(self, orders, notify=True):  

        '''  

        Add a history of orders to be directly executed in the broker  

for  

        performance evaluation  

  

          - ``orders``: is an iterable (ex: list, tuple, iterator,  

generator)  

            in which each element will be also an iterable (with  

length) with  

            the following sub-elements (2 formats are possible)  

  

            ``[datetime, size, price]`` or ``[datetime, size, price,  

data]``  

  
﻿            **Note**: it must be sorted (or produce sorted elements)  

by  

              datetime ascending  

  

            where:  

  

              - ``datetime`` is a python ``date/datetime`` instance or  

a string  

                with format YYYY-MM-DD[THH:MM:SS[.us]] where the  

elements in  

                brackets are optional  

              - ``size`` is an integer (positive to *buy*, negative to  

*sell*)  

              - ``price`` is a float/integer  

              - ``data`` if present can take any of the following  

values  

  

                - *None* - The 1st data feed will be used as target  

                - *integer* - The data with that index (insertion  

order in  

                  **Cerebro**) will be used  

                - *string* - a data with that name, assigned for  

example with  

                  ``cerebro.addata(data, name=value)``, will be the  

target  

  

          - ``notify`` (default: *True*)  

  

            If ``True`` the 1st strategy inserted in the system will  
﻿be  

            notified of the artificial orders created following the  

information  

            from each order in ``orders``  

  

        **Note**: Implicit in the description is the need to add a  

data feed  

          which is the target of the orders. This is for example  

needed by  

          analyzers which track for example the returns  

        '''  

        self._ohistory.append((orders, notify))  

  

    def notify_timer(self, timer, when, *args, **kwargs):  

        '''Receives a timer notification where ``timer`` is the timer  

which was  

        returned by ``add_timer``, and ``when`` is the calling time.  

``args``  

        and ``kwargs`` are any additional arguments passed to  

``add_timer``  

  

        The actual ``when`` time can be later, but the system may have  

not be  

        able to call the timer before. This value is the timer value  

and no the  

        system time.  

        '''  

        pass  

  
﻿    def _add_timer(self, owner, when,  

                   offset=datetime.timedelta(),  

repeat=datetime.timedelta(),  

                   weekdays=[], weekcarry=False,  

                   monthdays=[], monthcarry=True,  

                   allow=None,  

                   tzdata=None, strats=False, cheat=False,  

                   *args, **kwargs):  

        '''Internal method to really create the timer (not started  

yet) which  

        can be called by cerebro instances or other objects which can  

access  

        cerebro'''  

  

        timer = Timer(  

            tid=len(self._pretimers),  

            owner=owner, strats=strats,  

            when=when, offset=offset, repeat=repeat,  

            weekdays=weekdays, weekcarry=weekcarry,  

            monthdays=monthdays, monthcarry=monthcarry,  

            allow=allow,  

            tzdata=tzdata, cheat=cheat,  

            *args, **kwargs  

        )  

  

        self._pretimers.append(timer)  

        return timer  

  
﻿    def add_timer(self, when,  

                  offset=datetime.timedelta(),  

repeat=datetime.timedelta(),  

                  weekdays=[], weekcarry=False,  

                  monthdays=[], monthcarry=True,  

                  allow=None,  

                  tzdata=None, strats=False, cheat=False,  

                  *args, **kwargs):  

        '''  

        Schedules a timer to invoke ``notify_timer``  

  

        Arguments:  

  

          - ``when``: can be  

  

            - ``datetime.time`` instance (see below ``tzdata``)  

            - ``bt.timer.SESSION_START`` to reference a session start  

            - ``bt.timer.SESSION_END`` to reference a session end  

  

         - ``offset`` which must be a ``datetime.timedelta`` instance  

  

           Used to offset the value ``when``. It has a meaningful use  

in  

           combination with ``SESSION_START`` and ``SESSION_END``, to  

indicated  

           things like a timer being called ``15 minutes`` after the  

session  

           start.  
﻿  

          - ``repeat`` which must be a ``datetime.timedelta`` instance  

  

            Indicates if after a 1st call, further calls will be  

scheduled  

            within the same session at the scheduled ``repeat`` delta  

  

            Once the timer goes over the end of the session it is  

reset to the  

            original value for ``when``  

  

          - ``weekdays``: a **sorted** iterable with integers  

indicating on  

            which days (iso codes, Monday is 1, Sunday is 7) the  

timers can  

            be actually invoked  

  

            If not specified, the timer will be active on all days  

  

          - ``weekcarry`` (default: ``False``). If ``True`` and the  

weekday was  

            not seen (ex: trading holiday), the timer will be executed  

on the  

            next day (even if in a new week)  

  

          - ``monthdays``: a **sorted** iterable with integers  

indicating on  

            which days of the month a timer has to be executed. For  

example  
﻿            always on day *15* of the month  

  

            If not specified, the timer will be active on all days  

  

          - ``monthcarry`` (default: ``True``). If the day was not  

seen  

             (weekend, trading holiday), the timer will be executed on  

the next  

            available day.  

  

          - ``allow`` (default: ``None``). A callback which receives a  

            `datetime.date`` instance and returns ``True`` if the date  

is  

            allowed for timers or else returns ``False``  

  

          - ``tzdata`` which can be either ``None`` (default), a  

``pytz``  

            instance or a ``data feed`` instance.  

  

            ``None``: ``when`` is interpreted at face value (which  

translates  

            to handling it as if it where UTC even if it's not)  

  

            ``pytz`` instance: ``when`` will be interpreted as being  

specified  

            in the local time specified by the timezone instance.  

  

            ``data feed`` instance: ``when`` will be interpreted as  

being  
﻿            specified in the local time specified by the ``tz``  

parameter of  

            the data feed instance.  

  

            **Note**: If ``when`` is either ``SESSION_START`` or  

              ``SESSION_END`` and ``tzdata`` is ``None``, the 1st  

*data feed*  

              in the system (aka ``self.data0``) will be used as the  

reference  

              to find out the session times.  

  

          - ``strats`` (default: ``False``) call also the  

``notify_timer`` of  

            strategies  

  

          - ``cheat`` (default ``False``) if ``True`` the timer will  

be called  

            before the broker has a chance to evaluate the orders.  

This opens  

            the chance to issue orders based on opening price for  

example right  

            before the session starts  

          - ``*args``: any extra args will be passed to  

``notify_timer``  

  

          - ``**kwargs``: any extra kwargs will be passed to  

``notify_timer``  

  

        Return Value:  
﻿  

          - The created timer  

  

        '''  

        return self._add_timer(  

            owner=self, when=when, offset=offset, repeat=repeat,  

            weekdays=weekdays, weekcarry=weekcarry,  

            monthdays=monthdays, monthcarry=monthcarry,  

            allow=allow,  

            tzdata=tzdata, strats=strats, cheat=cheat,  

            *args, **kwargs)  

  

    def addtz(self, tz):  

        '''  

        This can also be done with the parameter ``tz``  

  

        Adds a global timezone for strategies. The argument ``tz`` can  

be  

  

          - ``None``: in this case the datetime displayed by  

strategies will be  

            in UTC, which has been always the standard behavior  

  

          - ``pytz`` instance. It will be used as such to convert UTC  

times to  

            the chosen timezone  

  

          - ``string``. Instantiating a ``pytz`` instance will be  
﻿attempted.  

  

          - ``integer``. Use, for the strategy, the same timezone as  

the  

            corresponding ``data`` in the ``self.datas`` iterable  

(``0`` would  

            use the timezone from ``data0``)  

  

        '''  

        self.p.tz = tz  

  

    def addcalendar(self, cal):  

        '''Adds a global trading calendar to the system. Individual  

data feeds  

        may have separate calendars which override the global one  

  

        ``cal`` can be an instance of ``TradingCalendar`` a string or  

an  

        instance of ``pandas_market_calendars``. A string will be will  

be  

        instantiated as a ``PandasMarketCalendar`` (which needs the  

module  

        ``pandas_market_calendar`` installed in the system.  

  

        If a subclass of `TradingCalendarBase` is passed (not an  

instance) it  

        will be instantiated  

        '''  

        if isinstance(cal, string_types):  
﻿            cal = PandasMarketCalendar(calendar=cal)  

        elif hasattr(cal, 'valid_days'):  

            cal = PandasMarketCalendar(calendar=cal)  

  

        else:  

            try:  

                if issubclass(cal, TradingCalendarBase):  

                    cal = cal()  

            except TypeError:  # already an instance  

                pass  

  

        self._tradingcal = cal  

  

    def add_signal(self, sigtype, sigcls, *sigargs, **sigkwargs):  

        '''Adds a signal to the system which will be later added to a  

        ``SignalStrategy``'''  

        self.signals.append((sigtype, sigcls, sigargs, sigkwargs))  

  

    def signal_strategy(self, stratcls, *args, **kwargs):  

        '''Adds a SignalStrategy subclass which can accept signals'''  

        self._signal_strat = (stratcls, args, kwargs)  

  

    def signal_concurrent(self, onoff):  

        '''If signals are added to the system and the ``concurrent``  

value is  

        set to True, concurrent orders will be allowed'''  

        self._signal_concurrent = onoff  
﻿  

    def signal_accumulate(self, onoff):  

        '''If signals are added to the system and the ``accumulate``  

value is  

        set to True, entering the market when already in the market,  

will be  

        allowed to increase a position'''  

        self._signal_accumulate = onoff  

  

    def addstore(self, store):  

        '''Adds an ``Store`` instance to the if not already present'''  

        if store not in self.stores:  

            self.stores.append(store)  

  

    def addwriter(self, wrtcls, *args, **kwargs):  

        '''Adds an ``Writer`` class to the mix. Instantiation will be  

done at  

        ``run`` time in cerebro  

        '''  

        self.writers.append((wrtcls, args, kwargs))  

  

    def addsizer(self, sizercls, *args, **kwargs):  

        '''Adds a ``Sizer`` class (and args) which is the default  

sizer for any  

        strategy added to cerebro  

        '''  

        self.sizers[None] = (sizercls, args, kwargs)  

  
﻿    def addsizer_byidx(self, idx, sizercls, *args, **kwargs):  

        '''Adds a ``Sizer`` class by idx. This idx is a reference  

compatible to  

        the one returned by ``addstrategy``. Only the strategy  

referenced by  

        ``idx`` will receive this size  

        '''  

        self.sizers[idx] = (sizercls, args, kwargs)  

  

    def addindicator(self, indcls, *args, **kwargs):  

        '''  

        Adds an ``Indicator`` class to the mix. Instantiation will be  

done at  

        ``run`` time in the passed strategies  

        '''  

        self.indicators.append((indcls, args, kwargs))  

  

    def addanalyzer(self, ancls, *args, **kwargs):  

        '''  

        Adds an ``Analyzer`` class to the mix. Instantiation will be  

done at  

        ``run`` time  

        '''  

        self.analyzers.append((ancls, args, kwargs))  

  

    def addobserver(self, obscls, *args, **kwargs):  

        '''  

        Adds an ``Observer`` class to the mix. Instantiation will be  
﻿done at  

        ``run`` time  

        '''  

        self.observers.append((False, obscls, args, kwargs))  

  

    def addobservermulti(self, obscls, *args, **kwargs):  

        '''  

        Adds an ``Observer`` class to the mix. Instantiation will be  

done at  

        ``run`` time  

  

        It will be added once per "data" in the system. A use case is  

a  

        buy/sell observer which observes individual datas.  

  

        A counter-example is the CashValue, which observes system-wide  

values  

        '''  

        self.observers.append((True, obscls, args, kwargs))  

  

    def addstorecb(self, callback):  

        '''Adds a callback to get messages which would be handled by  

the  

        notify_store method  

  

        The signature of the callback must support the following:  

  

          - callback(msg, \*args, \*\*kwargs)  
﻿  

        The actual ``msg``, ``*args`` and ``**kwargs`` received are  

        implementation defined (depend entirely on the  

*data/broker/store*) but  

        in general one should expect them to be *printable* to allow  

for  

        reception and experimentation.  

        '''  

        self.storecbs.append(callback)  

  

    def _notify_store(self, msg, *args, **kwargs):  

        for callback in self.storecbs:  

            callback(msg, *args, **kwargs)  

  

        self.notify_store(msg, *args, **kwargs)  

  

    def notify_store(self, msg, *args, **kwargs):  

        '''Receive store notifications in cerebro  

  

        This method can be overridden in ``Cerebro`` subclasses  

  

        The actual ``msg``, ``*args`` and ``**kwargs`` received are  

        implementation defined (depend entirely on the  

*data/broker/store*) but  

        in general one should expect them to be *printable* to allow  

for  

        reception and experimentation.  

        '''  
﻿        pass  

  

    def _storenotify(self):  

        for store in self.stores:  

            for notif in store.get_notifications():  

                msg, args, kwargs = notif  

  

                self._notify_store(msg, *args, **kwargs)  

                for strat in self.runningstrats:  

                    strat.notify_store(msg, *args, **kwargs)  

  

    def adddatacb(self, callback):  

        '''Adds a callback to get messages which would be handled by  

the  

        notify_data method  

  

        The signature of the callback must support the following:  

  

          - callback(data, status, \*args, \*\*kwargs)  

  

        The actual ``*args`` and ``**kwargs`` received are  

implementation  

        defined (depend entirely on the *data/broker/store*) but in  

general one  

        should expect them to be *printable* to allow for reception  

and  

        experimentation.  

        '''  
﻿        self.datacbs.append(callback)  

  

    def _datanotify(self):  

        for data in self.datas:  

            for notif in data.get_notifications():  

                status, args, kwargs = notif  

                self._notify_data(data, status, *args, **kwargs)  

                for strat in self.runningstrats:  

                    strat.notify_data(data, status, *args, **kwargs)  

  

    def _notify_data(self, data, status, *args, **kwargs):  

        for callback in self.datacbs:  

            callback(data, status, *args, **kwargs)  

  

        self.notify_data(data, status, *args, **kwargs)  

  

    def notify_data(self, data, status, *args, **kwargs):  

        '''Receive data notifications in cerebro  

  

        This method can be overridden in ``Cerebro`` subclasses  

  

        The actual ``*args`` and ``**kwargs`` received are  

        implementation defined (depend entirely on the  

*data/broker/store*) but  

        in general one should expect them to be *printable* to allow  

for  

        reception and experimentation.  
﻿        '''  

        pass  

  

    def adddata(self, data, name=None):  

        '''  

        Adds a ``Data Feed`` instance to the mix.  

  

        If ``name`` is not None it will be put into ``data._name``  

which is  

        meant for decoration/plotting purposes.  

        '''  

        if name is not None:  

            data._name = name  

  

        data._id = next(self._dataid)  

        data.setenvironment(self)  

  

        self.datas.append(data)  

        self.datasbyname[data._name] = data  

        feed = data.getfeed()  

        if feed and feed not in self.feeds:  

            self.feeds.append(feed)  

  

        if data.islive():  

            self._dolive = True  

  

        return data  
﻿  

    def chaindata(self, *args, **kwargs):  

        '''  

        Chains several data feeds into one  

  

        If ``name`` is passed as named argument and is not None it  

will be put  

        into ``data._name`` which is meant for decoration/plotting  

purposes.  

  

        If ``None``, then the name of the 1st data will be used  

        '''  

        dname = kwargs.pop('name', None)  

        if dname is None:  

            dname = args[0]._dataname  

        d = bt.feeds.Chainer(dataname=dname, *args)  

        self.adddata(d, name=dname)  

  

        return d  

  

    def rolloverdata(self, *args, **kwargs):  

        '''Chains several data feeds into one  

  

        If ``name`` is passed as named argument and is not None it  

will be put  

        into ``data._name`` which is meant for decoration/plotting  

purposes.  

  
﻿        If ``None``, then the name of the 1st data will be used  

  

        Any other kwargs will be passed to the RollOver class  

  

        '''  

        dname = kwargs.pop('name', None)  

        if dname is None:  

            dname = args[0]._dataname  

        d = bt.feeds.RollOver(dataname=dname, *args, **kwargs)  

        self.adddata(d, name=dname)  

  

        return d  

  

    def replaydata(self, dataname, name=None, **kwargs):  

        '''  

        Adds a ``Data Feed`` to be replayed by the system  

  

        If ``name`` is not None it will be put into ``data._name``  

which is  

        meant for decoration/plotting purposes.  

  

        Any other kwargs like ``timeframe``, ``compression``,  

``todate`` which  

        are supported by the replay filter will be passed  

transparently  

        '''  

        if any(dataname is x for x in self.datas):  

            dataname = dataname.clone()  
﻿  

        dataname.replay(**kwargs)  

        self.adddata(dataname, name=name)  

        self._doreplay = True  

  

        return dataname  

  

    def resampledata(self, dataname, name=None, **kwargs):  

        '''  

        Adds a ``Data Feed`` to be resample by the system  

  

        If ``name`` is not None it will be put into ``data._name``  

which is  

        meant for decoration/plotting purposes.  

  

        Any other kwargs like ``timeframe``, ``compression``,  

``todate`` which  

        are supported by the resample filter will be passed  

transparently  

        '''  

        if any(dataname is x for x in self.datas):  

            dataname = dataname.clone()  

  

        dataname.resample(**kwargs)  

        self.adddata(dataname, name=name)  

        self._doreplay = True  

  

        return dataname  
﻿  

    def optcallback(self, cb):  

        '''  

        Adds a *callback* to the list of callbacks that will be called  

with the  

        optimizations when each of the strategies has been run  

  

        The signature: cb(strategy)  

        '''  

        self.optcbs.append(cb)  

  

    def optstrategy(self, strategy, *args, **kwargs):  

        '''  

        Adds a ``Strategy`` class to the mix for optimization.  

Instantiation  

        will happen during ``run`` time.  

  

        args and kwargs MUST BE iterables which hold the values to  

check.  

  

        Example: if a Strategy accepts a parameter ``period``, for  

optimization  

        purposes the call to ``optstrategy`` looks like:  

  

          - cerebro.optstrategy(MyStrategy, period=(15, 25))  

  

        This will execute an optimization for values 15 and 25.  

Whereas  
﻿  

          - cerebro.optstrategy(MyStrategy, period=range(15, 25))  

  

        will execute MyStrategy with ``period`` values 15 -> 25 (25  

not  

        included, because ranges are semi-open in Python)  

  

        If a parameter is passed but shall not be optimized the call  

looks  

        like:  

  

          - cerebro.optstrategy(MyStrategy, period=(15,))  

  

        Notice that ``period`` is still passed as an iterable ... of  

just 1  

        element  

  

        ``backtrader`` will anyhow try to identify situations like:  

  

          - cerebro.optstrategy(MyStrategy, period=15)  

  

        and will create an internal pseudo-iterable if possible  

        '''  

        self._dooptimize = True  

        args = self.iterize(args)  

        optargs = itertools.product(*args)  

  

        optkeys = list(kwargs)  
﻿  

        vals = self.iterize(kwargs.values())  

        optvals = itertools.product(*vals)  

  

        okwargs1 = map(zip, itertools.repeat(optkeys), optvals)  

  

        optkwargs = map(dict, okwargs1)  

  

        it = itertools.product([strategy], optargs, optkwargs)  

        self.strats.append(it)  

  

    def addstrategy(self, strategy, *args, **kwargs):  

        '''  

        Adds a ``Strategy`` class to the mix for a single pass run.  

        Instantiation will happen during ``run`` time.  

  

        args and kwargs will be passed to the strategy as they are  

during  

        instantiation.  

  

        Returns the index with which addition of other objects (like  

sizers)  

        can be referenced  

        '''  

        self.strats.append([(strategy, args, kwargs)])  

        return len(self.strats) - 1  

  
﻿    def setbroker(self, broker):  

        '''  

        Sets a specific ``broker`` instance for this strategy,  

replacing the  

        one inherited from cerebro.  

        '''  

        self._broker = broker  

        broker.cerebro = self  

        return broker  

  

    def getbroker(self):  

        '''  

        Returns the broker instance.  

  

        This is also available as a ``property`` by the name  

``broker``  

        '''  

        return self._broker  

  

    broker = property(getbroker, setbroker)  

  

    def plot(self, plotter=None, numfigs=1, iplot=True, start=None,  

end=None,  

             width=16, height=9, dpi=300, tight=True, use=None,  

             **kwargs):  

        '''  

        Plots the strategies inside cerebro  

  
﻿        If ``plotter`` is None a default ``Plot`` instance is created  

and  

        ``kwargs`` are passed to it during instantiation.  

  

        ``numfigs`` split the plot in the indicated number of charts  

reducing  

        chart density if wished  

  

        ``iplot``: if ``True`` and running in a ``notebook`` the  

charts will be  

        displayed inline  

  

        ``use``: set it to the name of the desired matplotlib backend.  

It will  

        take precedence over ``iplot``  

  

        ``start``: An index to the datetime line array of the strategy  

or a  

        ``datetime.date``, ``datetime.datetime`` instance indicating  

the start  

        of the plot  

  

        ``end``: An index to the datetime line array of the strategy  

or a  

        ``datetime.date``, ``datetime.datetime`` instance indicating  

the end  

        of the plot  

  

        ``width``: in inches of the saved figure  
﻿  

        ``height``: in inches of the saved figure  

  

        ``dpi``: quality in dots per inches of the saved figure  

  

        ``tight``: only save actual content and not the frame of the  

figure  

        '''  

        if self._exactbars > 0:  

            return  

  

        if not plotter:  

            from . import plot  

            if self.p.oldsync:  

                plotter = plot.Plot_OldSync(**kwargs)  

            else:  

                plotter = plot.Plot(**kwargs)  

  

        # pfillers = {self.datas[i]: self._plotfillers[i]  

        # for i, x in enumerate(self._plotfillers)}  

  

        # pfillers2 = {self.datas[i]: self._plotfillers2[i]  

        # for i, x in enumerate(self._plotfillers2)}  

  

        figs = []  

        for stratlist in self.runstrats:  

            for si, strat in enumerate(stratlist):  
﻿                rfig = plotter.plot(strat, figid=si * 100,  

                                    numfigs=numfigs, iplot=iplot,  

                                    start=start, end=end, use=use)  

                # pfillers=pfillers2)  

  

                figs.append(rfig)  

  

            plotter.show()  

  

        return figs  

  

    def __call__(self, iterstrat):  

        '''  

        Used during optimization to pass the cerebro over the  

multiprocesing  

        module without complains  

        '''  

  

        predata = self.p.optdatas and self._dopreload and  

self._dorunonce  

        return self.runstrategies(iterstrat, predata=predata)  

  

    def __getstate__(self):  

        '''  

        Used during optimization to prevent optimization result  

`runstrats`  

        from being pickled to subprocesses  

        '''  
﻿  

        rv = vars(self).copy()  

        if 'runstrats' in rv:  

            del(rv['runstrats'])  

        return rv  

  

    def runstop(self):  

        '''If invoked from inside a strategy or anywhere else,  

including other  

        threads the execution will stop as soon as possible.'''  

        self._event_stop = True  # signal a stop has been requested  

  

    def run(self, **kwargs):  

        '''The core method to perform backtesting. Any ``kwargs``  

passed to it  

        will affect the value of the standard parameters ``Cerebro``  

was  

        instantiated with.  

  

        If ``cerebro`` has not datas the method will immediately bail  

out.  

  

        It has different return values:  

  

          - For No Optimization: a list contanining instances of the  

Strategy  

            classes added with ``addstrategy``  

  
﻿          - For Optimization: a list of lists which contain instances  

of the  

            Strategy classes added with ``addstrategy``  

        '''  

        self._event_stop = False  # Stop is requested  

  

        if not self.datas:  

            return []  # nothing can be run  

  

        pkeys = self.params._getkeys()  

        for key, val in kwargs.items():  

            if key in pkeys:  

                setattr(self.params, key, val)  

  

        # Manage activate/deactivate object cache  

        linebuffer.LineActions.cleancache()  # clean cache  

        indicator.Indicator.cleancache()  # clean cache  

  

        linebuffer.LineActions.usecache(self.p.objcache)  

        indicator.Indicator.usecache(self.p.objcache)  

  

        self._dorunonce = self.p.runonce  

        self._dopreload = self.p.preload  

        self._exactbars = int(self.p.exactbars)  

  

        if self._exactbars:  

            self._dorunonce = False  # something is saving memory, no  
﻿runonce  

            self._dopreload = self._dopreload and self._exactbars < 1  

  

        self._doreplay = self._doreplay or any(x.replaying for x in  

self.datas)  

        if self._doreplay:  

            # preloading is not supported with replay. full timeframe  

bars  

            # are constructed in realtime  

            self._dopreload = False  

  

        if self._dolive or self.p.live:  

            # in this case both preload and runonce must be off  

            self._dorunonce = False  

            self._dopreload = False  

  

        self.runwriters = list()  

  

        # Add the system default writer if requested  

        if self.p.writer is True:  

            wr = WriterFile()  

            self.runwriters.append(wr)  

  

        # Instantiate any other writers  

        for wrcls, wrargs, wrkwargs in self.writers:  

            wr = wrcls(*wrargs, **wrkwargs)  

            self.runwriters.append(wr)  
﻿  

        # Write down if any writer wants the full csv output  

        self.writers_csv = any(map(lambda x: x.p.csv,  

self.runwriters))  

  

        self.runstrats = list()  

  

        if self.signals:  # allow processing of signals  

            signalst, sargs, skwargs = self._signal_strat  

            if signalst is None:  

                # Try to see if the 1st regular strategy is a signal  

strategy  

                try:  

                    signalst, sargs, skwargs = self.strats.pop(0)  

                except IndexError:  

                    pass  # Nothing there  

                else:  

                    if not isinstance(signalst, SignalStrategy):  

                        # no signal ... reinsert at the beginning  

                        self.strats.insert(0, (signalst, sargs,  

skwargs))  

                        signalst = None  # flag as not presetn  

  

            if signalst is None:  # recheck  

                # Still None, create a default one  

                signalst, sargs, skwargs = SignalStrategy, tuple(),  

dict()  

  
﻿            # Add the signal strategy  

            self.addstrategy(signalst,  

                             _accumulate=self._signal_accumulate,  

                             _concurrent=self._signal_concurrent,  

                             signals=self.signals,  

                             *sargs,  

                             **skwargs)  

  

        if not self.strats:  # Datas are present, add a strategy  

            self.addstrategy(Strategy)  

  

        iterstrats = itertools.product(*self.strats)  

        if not self._dooptimize or self.p.maxcpus == 1:  

            # If no optimmization is wished ... or 1 core is to be  

used  

            # let's skip process "spawning"  

            for iterstrat in iterstrats:  

                runstrat = self.runstrategies(iterstrat)  

                self.runstrats.append(runstrat)  

                if self._dooptimize:  

                    for cb in self.optcbs:  

                        cb(runstrat)  # callback receives finished  

strategy  

        else:  

            if self.p.optdatas and self._dopreload and  

self._dorunonce:  

                for data in self.datas:  

                    data.reset()  
﻿                    if self._exactbars < 1:  # datas can be full  

length  

                        data.extend(size=self.params.lookahead)  

                    data._start()  

                    if self._dopreload:  

                        data.preload()  

  

            pool = multiprocessing.Pool(self.p.maxcpus or None)  

            for r in pool.imap(self, iterstrats):  

                self.runstrats.append(r)  

                for cb in self.optcbs:  

                    cb(r)  # callback receives finished strategy  

  

            pool.close()  

  

            if self.p.optdatas and self._dopreload and  

self._dorunonce:  

                for data in self.datas:  

                    data.stop()  

  

        if not self._dooptimize:  

            # avoid a list of list for regular cases  

            return self.runstrats[0]  

  

        return self.runstrats  

  

    def _init_stcount(self):  
﻿        self.stcount = itertools.count(0)  

  

    def _next_stid(self):  

        return next(self.stcount)  

  

    def runstrategies(self, iterstrat, predata=False):  

        '''  

        Internal method invoked by ``run``` to run a set of strategies  

        '''  

        self._init_stcount()  

  

        self.runningstrats = runstrats = list()  

        for store in self.stores:  

            store.start()  

  

        if self.p.cheat_on_open and self.p.broker_coo:  

            # try to activate in broker  

            if hasattr(self._broker, 'set_coo'):  

                self._broker.set_coo(True)  

  

        if self._fhistory is not None:  

            self._broker.set_fund_history(self._fhistory)  

  

        for orders, onotify in self._ohistory:  

            self._broker.add_order_history(orders, onotify)  

  

        self._broker.start()  
﻿  

        for feed in self.feeds:  

            feed.start()  

  

        if self.writers_csv:  

            wheaders = list()  

            for data in self.datas:  

                if data.csv:  

                    wheaders.extend(data.getwriterheaders())  

  

            for writer in self.runwriters:  

                if writer.p.csv:  

                    writer.addheaders(wheaders)  

  

        # self._plotfillers = [list() for d in self.datas]  

        # self._plotfillers2 = [list() for d in self.datas]  

  

        if not predata:  

            for data in self.datas:  

                data.reset()  

                if self._exactbars < 1:  # datas can be full length  

                    data.extend(size=self.params.lookahead)  

                data._start()  

                if self._dopreload:  

                    data.preload()  

  

        for stratcls, sargs, skwargs in iterstrat:  
﻿            sargs = self.datas + list(sargs)  

            try:  

                strat = stratcls(*sargs, **skwargs)  

            except bt.errors.StrategySkipError:  

                continue  # do not add strategy to the mix  

  

            if self.p.oldsync:  

                strat._oldsync = True  # tell strategy to use old  

clock update  

            if self.p.tradehistory:  

                strat.set_tradehistory()  

            runstrats.append(strat)  

  

        tz = self.p.tz  

        if isinstance(tz, integer_types):  

            tz = self.datas[tz]._tz  

        else:  

            tz = tzparse(tz)  

  

        if runstrats:  

            # loop separated for clarity  

            defaultsizer = self.sizers.get(None, (None, None, None))  

            for idx, strat in enumerate(runstrats):  

                if self.p.stdstats:  

                    strat._addobserver(False, observers.Broker)  

                    if self.p.oldbuysell:  

                        strat._addobserver(True, observers.BuySell)  
﻿                    else:  

                        strat._addobserver(True, observers.BuySell,  

                                           barplot=True)  

  

                    if self.p.oldtrades or len(self.datas) == 1:  

                        strat._addobserver(False, observers.Trades)  

                    else:  

                        strat._addobserver(False,  

observers.DataTrades)  

  

                for multi, obscls, obsargs, obskwargs in  

self.observers:  

                    strat._addobserver(multi, obscls, *obsargs,  

**obskwargs)  

  

                for indcls, indargs, indkwargs in self.indicators:  

                    strat._addindicator(indcls, *indargs, **indkwargs)  

  

                for ancls, anargs, ankwargs in self.analyzers:  

                    strat._addanalyzer(ancls, *anargs, **ankwargs)  

  

                sizer, sargs, skwargs = self.sizers.get(idx,  

defaultsizer)  

                if sizer is not None:  

                    strat._addsizer(sizer, *sargs, **skwargs)  

  

                strat._settz(tz)  

                strat._start()  
﻿  

                for writer in self.runwriters:  

                    if writer.p.csv:  

                        writer.addheaders(strat.getwriterheaders())  

  

            if not predata:  

                for strat in runstrats:  

                    strat.qbuffer(self._exactbars,  

replaying=self._doreplay)  

  

            for writer in self.runwriters:  

                writer.start()  

  

            # Prepare timers  

            self._timers = []  

            self._timerscheat = []  

            for timer in self._pretimers:  

                # preprocess tzdata if needed  

                timer.start(self.datas[0])  

  

                if timer.params.cheat:  

                    self._timerscheat.append(timer)  

                else:  

                    self._timers.append(timer)  

  

            if self._dopreload and self._dorunonce:  

                if self.p.oldsync:  
﻿                    self._runonce_old(runstrats)  

                else:  

                    self._runonce(runstrats)  

            else:  

                if self.p.oldsync:  

                    self._runnext_old(runstrats)  

                else:  

                    self._runnext(runstrats)  

  

            for strat in runstrats:  

                strat._stop()  

  

        self._broker.stop()  

  

        if not predata:  

            for data in self.datas:  

                data.stop()  

  

        for feed in self.feeds:  

            feed.stop()  

  

        for store in self.stores:  

            store.stop()  

  

        self.stop_writers(runstrats)  

  

        if self._dooptimize and self.p.optreturn:  
﻿            # Results can be optimized  

            results = list()  

            for strat in runstrats:  

                for a in strat.analyzers:  

                    a.strategy = None  

                    a._parent = None  

                    for attrname in dir(a):  

                        if attrname.startswith('data'):  

                            setattr(a, attrname, None)  

  

                oreturn = OptReturn(strat.params,  

analyzers=strat.analyzers, strategycls=type(strat))  

                results.append(oreturn)  

  

            return results  

  

        return runstrats  

  

    def stop_writers(self, runstrats):  

        cerebroinfo = OrderedDict()  

        datainfos = OrderedDict()  

  

        for i, data in enumerate(self.datas):  

            datainfos['Data%d' % i] = data.getwriterinfo()  

  

        cerebroinfo['Datas'] = datainfos  

  
﻿        stratinfos = dict()  

        for strat in runstrats:  

            stname = strat.__class__.__name__  

            stratinfos[stname] = strat.getwriterinfo()  

  

        cerebroinfo['Strategies'] = stratinfos  

  

        for writer in self.runwriters:  

            writer.writedict(dict(Cerebro=cerebroinfo))  

            writer.stop()  

  

    def _brokernotify(self):  

        '''  

        Internal method which kicks the broker and delivers any broker  

        notification to the strategy  

        '''  

        self._broker.next()  

        while True:  

            order = self._broker.get_notification()  

            if order is None:  

                break  

  

            owner = order.owner  

            if owner is None:  

                owner = self.runningstrats[0]  # default  

  

            owner._addnotification(order,  
﻿quicknotify=self.p.quicknotify)  

  

    def _runnext_old(self, runstrats):  

        '''  

        Actual implementation of run in full next mode. All objects  

have its  

        ``next`` method invoke on each data arrival  

        '''  

        data0 = self.datas[0]  

        d0ret = True  

        while d0ret or d0ret is None:  

            lastret = False  

            # Notify anything from the store even before moving datas  

            # because datas may not move due to an error reported by  

the store  

            self._storenotify()  

            if self._event_stop:  # stop if requested  

                return  

            self._datanotify()  

            if self._event_stop:  # stop if requested  

                return  

  

            d0ret = data0.next()  

            if d0ret:  

                for data in self.datas[1:]:  

                    if not data.next(datamaster=data0):  # no delivery  

                        data._check(forcedata=data0)  # check forcing  

output  
﻿                        data.next(datamaster=data0)  # retry  

  

            elif d0ret is None:  

                # meant for things like live feeds which may not  

produce a bar  

                # at the moment but need the loop to run for  

notifications and  

                # getting resample and others to produce timely bars  

                data0._check()  

                for data in self.datas[1:]:  

                    data._check()  

            else:  

                lastret = data0._last()  

                for data in self.datas[1:]:  

                    lastret += data._last(datamaster=data0)  

  

                if not lastret:  

                    # Only go extra round if something was changed by  

"lasts"  

                    break  

  

            # Datas may have generated a new notification after next  

            self._datanotify()  

            if self._event_stop:  # stop if requested  

                return  

  

            self._brokernotify()  

            if self._event_stop:  # stop if requested  
﻿                return  

  

            if d0ret or lastret:  # bars produced by data or filters  

                for strat in runstrats:  

                    strat._next()  

                    if self._event_stop:  # stop if requested  

                        return  

  

                    self._next_writers(runstrats)  

  

        # Last notification chance before stopping  

        self._datanotify()  

        if self._event_stop:  # stop if requested  

            return  

        self._storenotify()  

        if self._event_stop:  # stop if requested  

            return  

  

    def _runonce_old(self, runstrats):  

        '''  

        Actual implementation of run in vector mode.  

        Strategies are still invoked on a pseudo-event mode in which  

``next``  

        is called for each data arrival  

        '''  

        for strat in runstrats:  

            strat._once()  
﻿  

        # The default once for strategies does nothing and therefore  

        # has not moved forward all datas/indicators/observers that  

        # were homed before calling once, Hence no "need" to do it  

        # here again, because pointers are at 0  

        data0 = self.datas[0]  

        datas = self.datas[1:]  

        for i in range(data0.buflen()):  

            data0.advance()  

            for data in datas:  

                data.advance(datamaster=data0)  

  

            self._brokernotify()  

            if self._event_stop:  # stop if requested  

                return  

  

            for strat in runstrats:  

                # data0.datetime[0] for compat. w/ new strategy's  

oncepost  

                strat._oncepost(data0.datetime[0])  

                if self._event_stop:  # stop if requested  

                    return  

  

                self._next_writers(runstrats)  

  

    def _next_writers(self, runstrats):  

        if not self.runwriters:  
﻿            return  

  

        if self.writers_csv:  

            wvalues = list()  

            for data in self.datas:  

                if data.csv:  

                    wvalues.extend(data.getwritervalues())  

  

            for strat in runstrats:  

                wvalues.extend(strat.getwritervalues())  

  

            for writer in self.runwriters:  

                if writer.p.csv:  

                    writer.addvalues(wvalues)  

  

                    writer.next()  

  

    def _disable_runonce(self):  

        '''API for lineiterators to disable runonce (see  

HeikinAshi)'''  

        self._dorunonce = False  

  

    def _runnext(self, runstrats):  

        '''  

        Actual implementation of run in full next mode. All objects  

have its  

        ``next`` method invoke on each data arrival  
﻿        '''  

        datas = sorted(self.datas,  

                       key=lambda x: (x._timeframe, x._compression))  

        datas1 = datas[1:]  

        data0 = datas[0]  

        d0ret = True  

  

        rs = [i for i, x in enumerate(datas) if x.resampling]  

        rp = [i for i, x in enumerate(datas) if x.replaying]  

        rsonly = [i for i, x in enumerate(datas)  

                  if x.resampling and not x.replaying]  

        onlyresample = len(datas) == len(rsonly)  

        noresample = not rsonly  

  

        clonecount = sum(d._clone for d in datas)  

        ldatas = len(datas)  

        ldatas_noclones = ldatas - clonecount  

        lastqcheck = False  

        dt0 = date2num(datetime.datetime.max) - 2  # default at max  

        while d0ret or d0ret is None:  

            # if any has live data in the buffer, no data will wait  

anything  

            newqcheck = not any(d.haslivedata() for d in datas)  

            if not newqcheck:  

                # If no data has reached the live status or all, wait  

for  

                # the next incoming data  
﻿                livecount = sum(d._laststatus == d.LIVE for d in  

datas)  

                newqcheck = not livecount or livecount ==  

ldatas_noclones  

  

            lastret = False  

            # Notify anything from the store even before moving datas  

            # because datas may not move due to an error reported by  

the store  

            self._storenotify()  

            if self._event_stop:  # stop if requested  

                return  

            self._datanotify()  

            if self._event_stop:  # stop if requested  

                return  

  

            # record starting time and tell feeds to discount the  

elapsed time  

            # from the qcheck value  

            drets = []  

            qstart = datetime.datetime.utcnow()  

            for d in datas:  

                qlapse = datetime.datetime.utcnow() - qstart  

                d.do_qcheck(newqcheck, qlapse.total_seconds())  

                drets.append(d.next(ticks=False))  

  

            d0ret = any((dret for dret in drets))  

            if not d0ret and any((dret is None for dret in drets)):  
﻿                d0ret = None  

  

            if d0ret:  

                dts = []  

                for i, ret in enumerate(drets):  

                    dts.append(datas[i].datetime[0] if ret else None)  

  

                # Get index to minimum datetime  

                if onlyresample or noresample:  

                    dt0 = min((d for d in dts if d is not None))  

                else:  

                    dt0 = min((d for i, d in enumerate(dts)  

                               if d is not None and i not in rsonly))  

  

                dmaster = datas[dts.index(dt0)]  # and timemaster  

                self._dtmaster = dmaster.num2date(dt0)  

                self._udtmaster = num2date(dt0)  

  

                # slen = len(runstrats[0])  

                # Try to get something for those that didn't return  

                for i, ret in enumerate(drets):  

                    if ret:  # dts already contains a valid datetime  

for this i  

                        continue  

  

                    # try to get a data by checking with a master  

                    d = datas[i]  
﻿                    d._check(forcedata=dmaster)  # check to force  

output  

                    if d.next(datamaster=dmaster, ticks=False):  #  

retry  

                        dts[i] = d.datetime[0]  # good -> store  

                        # self._plotfillers2[i].append(slen)  # mark  

as fill  

                    else:  

                        # self._plotfillers[i].append(slen)  # mark as  

empty  

                        pass  

  

                # make sure only those at dmaster level end up  

delivering  

                for i, dti in enumerate(dts):  

                    if dti is not None:  

                        di = datas[i]  

                        rpi = False and di.replaying   # to check  

behavior  

                        if dti > dt0:  

                            if not rpi:  # must see all ticks ...  

                                di.rewind()  # cannot deliver yet  

                            # self._plotfillers[i].append(slen)  

                        elif not di.replaying:  

                            # Replay forces tick fill, else force here  

                            di._tick_fill(force=True)  

  

                        # self._plotfillers2[i].append(slen)  # mark  

as fill  
﻿  

            elif d0ret is None:  

                # meant for things like live feeds which may not  

produce a bar  

                # at the moment but need the loop to run for  

notifications and  

                # getting resample and others to produce timely bars  

                for data in datas:  

                    data._check()  

            else:  

                lastret = data0._last()  

                for data in datas1:  

                    lastret += data._last(datamaster=data0)  

  

                if not lastret:  

                    # Only go extra round if something was changed by  

"lasts"  

                    break  

  

            # Datas may have generated a new notification after next  

            self._datanotify()  

            if self._event_stop:  # stop if requested  

                return  

  

            if d0ret or lastret:  # if any bar, check timers before  

broker  

                self._check_timers(runstrats, dt0, cheat=True)  

                if self.p.cheat_on_open:  
﻿                    for strat in runstrats:  

                        strat._next_open()  

                        if self._event_stop:  # stop if requested  

                            return  

  

            self._brokernotify()  

            if self._event_stop:  # stop if requested  

                return  

  

            if d0ret or lastret:  # bars produced by data or filters  

                self._check_timers(runstrats, dt0, cheat=False)  

                for strat in runstrats:  

                    strat._next()  

                    if self._event_stop:  # stop if requested  

                        return  

  

                    self._next_writers(runstrats)  

  

        # Last notification chance before stopping  

        self._datanotify()  

        if self._event_stop:  # stop if requested  

            return  

        self._storenotify()  

        if self._event_stop:  # stop if requested  

            return  

  

    def _runonce(self, runstrats):  
﻿        '''  

        Actual implementation of run in vector mode.  

  

        Strategies are still invoked on a pseudo-event mode in which  

``next``  

        is called for each data arrival  

        '''  

        for strat in runstrats:  

            strat._once()  

            strat.reset()  # strat called next by next - reset lines  

  

        # The default once for strategies does nothing and therefore  

        # has not moved forward all datas/indicators/observers that  

        # were homed before calling once, Hence no "need" to do it  

        # here again, because pointers are at 0  

        datas = sorted(self.datas,  

                       key=lambda x: (x._timeframe, x._compression))  

  

        while True:  

            # Check next incoming date in the datas  

            dts = [d.advance_peek() for d in datas]  

            dt0 = min(dts)  

            if dt0 == float('inf'):  

                break  # no data delivers anything  

  

            # Timemaster if needed be  

            # dmaster = datas[dts.index(dt0)]  # and timemaster  
﻿            slen = len(runstrats[0])  

            for i, dti in enumerate(dts):  

                if dti <= dt0:  

                    datas[i].advance()  

                    # self._plotfillers2[i].append(slen)  # mark as  

fill  

                else:  

                    # self._plotfillers[i].append(slen)  

                    pass  

  

            self._check_timers(runstrats, dt0, cheat=True)  

  

            if self.p.cheat_on_open:  

                for strat in runstrats:  

                    strat._oncepost_open()  

                    if self._event_stop:  # stop if requested  

                        return  

  

            self._brokernotify()  

            if self._event_stop:  # stop if requested  

                return  

  

            self._check_timers(runstrats, dt0, cheat=False)  

  

            for strat in runstrats:  

                strat._oncepost(dt0)  

                if self._event_stop:  # stop if requested  
﻿                    return  

  

                self._next_writers(runstrats)  

  

    def _check_timers(self, runstrats, dt0, cheat=False):  

        timers = self._timers if not cheat else self._timerscheat  

        for t in timers:  

            if not t.check(dt0):  

                continue  

  

            t.params.owner.notify_timer(t, t.lastwhen, *t.args,  

**t.kwargs)  

  

            if t.params.strats:  

                for strat in runstrats:  

                    strat.notify_timer(t, t.lastwhen, *t.args,  

**t.kwargs)  

  

  

  

##############################  

# 文件: comminfo.txt  

##############################  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  
﻿#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import datetime  

  

from .utils.py3 import with_metaclass  

from .metabase import MetaParams  

  
﻿  

class CommInfoBase(with_metaclass(MetaParams)):  

    '''Base Class for the Commission Schemes.  

  

    Params:  

  

      - ``commission`` (def: ``0.0``): base commission value in  

percentage or  

        monetary units  

  

      - ``mult`` (def ``1.0``): multiplier applied to the asset for  

        value/profit  

  

      - ``margin`` (def: ``None``): amount of monetary units needed to  

        open/hold an operation. It only applies if the final  

``_stocklike``  

        attribute in the class is set to ``False``  

  

      - ``automargin`` (def: ``False``): Used by the method  

``get_margin``  

        to automatically calculate the margin/guarantees needed with  

the  

        following policy  

  

          - Use param ``margin`` if param ``automargin`` evaluates to  

``False``  

  

          - Use param ``mult`` * ``price`` if ``automargin < 0``  
﻿  

          - Use param ``automargin`` * ``price`` if ``automargin > 0``  

  

      - ``commtype`` (def: ``None``): Supported values are  

        ``CommInfoBase.COMM_PERC`` (commission to be understood as %)  

and  

        ``CommInfoBase.COMM_FIXED`` (commission to be understood as  

monetary  

        units)  

  

        The default value of ``None`` is a supported value to retain  

        compatibility with the legacy ``CommissionInfo`` object. If  

        ``commtype`` is set to None, then the following applies:  

  

          - ``margin`` is ``None``: Internal ``_commtype`` is set to  

            ``COMM_PERC`` and ``_stocklike`` is set to ``True``  

(Operating  

            %-wise with Stocks)  

  

          - ``margin`` is not ``None``: ``_commtype`` set to  

``COMM_FIXED`` and  

            ``_stocklike`` set to ``False`` (Operating with fixed  

rount-trip  

            commission with Futures)  

  

        If this param is set to something else than ``None``, then it  

will be  

        passed to the internal ``_commtype`` attribute and the same  

will be  
﻿        done with the param ``stocklike`` and the internal attribute  

        ``_stocklike``  

  

      - ``stocklike`` (def: ``False``): Indicates if the instrument is  

        Stock-like or Futures-like (see the ``commtype`` discussion  

above)  

  

      - ``percabs`` (def: ``False``): when ``commtype`` is set to  

COMM_PERC,  

        whether the parameter ``commission`` has to be understood as  

XX% or  

        0.XX  

  

        If this param is ``True``: 0.XX  

        If this param is ``False``: XX%  

  

      - ``interest`` (def: ``0.0``)  

  

        If this is non-zero, this is the yearly interest charged for  

holding a  

        short selling position. This is mostly meant for stock short- 

selling  

  

        The formula: ``days * price * abs(size) * (interest / 365)``  

  

        It must be specified in absolute terms: 0.05 -> 5%  

  

        .. note:: the behavior can be changed by overriding the  
﻿method:  

                 ``_get_credit_interest``  

  

      - ``interest_long`` (def: ``False``)  

  

        Some products like ETFs get charged on interest for short and  

long  

        positions. If ths is ``True`` and ``interest`` is non-zero the  

interest  

        will be charged on both directions  

  

      - ``leverage`` (def: ``1.0``)  

  

        Amount of leverage for the asset with regards to the needed  

cash  

  

    Attributes:  

  

      - ``_stocklike``: Final value to use for Stock-like/Futures-like  

behavior  

      - ``_commtype``: Final value to use for PERC vs FIXED  

commissions  

  

      This two are used internally instead of the declared params to  

enable the  

      compatibility check described above for the legacy  

``CommissionInfo``  

      object  

  
﻿    '''  

  

    COMM_PERC, COMM_FIXED = range(2)  

  

    params = (  

         ('commission', 0.0), ('mult', 1.0), ('margin', None),  

         ('commtype', None),  

         ('stocklike', False),  

         ('percabs', False),  

         ('interest', 0.0),  

         ('interest_long', False),  

         ('leverage', 1.0),  

         ('automargin', False),  

    )  

  

    def __init__(self):  

        super(CommInfoBase, self).__init__()  

  

        self._stocklike = self.p.stocklike  

        self._commtype = self.p.commtype  

  

        # The intial block checks for the behavior of the original  

        # CommissionInfo in which the commission scheme (perc/fixed)  

was  

        # determined by parameter "margin" evaluating to False/True  

        # If the parameter "commtype" is None, this behavior is  

emulated  
﻿        # else, the parameter values are used  

  

        if self._commtype is None:  # original CommissionInfo behavior  

applies  

            if self.p.margin:  

                self._stocklike = False  

                self._commtype = self.COMM_FIXED  

            else:  

                self._stocklike = True  

                self._commtype = self.COMM_PERC  

  

        if not self._stocklike and not self.p.margin:  

            self.p.margin = 1.0  # avoid having None/0  

  

        if self._commtype == self.COMM_PERC and not self.p.percabs:  

            self.p.commission /= 100.0  

  

        self._creditrate = self.p.interest / 365.0  

  

    @property  

    def margin(self):  

        return self.p.margin  

  

    @property  

    def stocklike(self):  

        return self._stocklike  

  
﻿    def get_margin(self, price):  

        '''Returns the actual margin/guarantees needed for a single  

item of the  

        asset at the given price. The default implementation has this  

policy:  

  

          - Use param ``margin`` if param ``automargin`` evaluates to  

``False``  

  

          - Use param ``mult`` * ``price`` if ``automargin < 0``  

  

          - Use param ``automargin`` * ``price`` if ``automargin > 0``  

        '''  

        if not self.p.automargin:  

            return self.p.margin  

  

        elif self.p.automargin < 0:  

            return price * self.p.mult  

  

        return price * self.p.automargin  # int/float expected  

  

    def get_leverage(self):  

  

        '''Returns the level of leverage allowed for this comission  

scheme'''  

        return self.p.leverage  

  

    def getsize(self, price, cash):  
﻿        '''Returns the needed size to meet a cash operation at a given  

price'''  

        if not self._stocklike:  

            return int(self.p.leverage * (cash //  

self.get_margin(price)))  

  

        return int(self.p.leverage * (cash // price))  

  

    def getoperationcost(self, size, price):  

        '''Returns the needed amount of cash an operation would  

cost'''  

        if not self._stocklike:  

            return abs(size) * self.get_margin(price)  

  

        return abs(size) * price  

  

    def getvaluesize(self, size, price):  

        '''Returns the value of size for given a price. For future- 

like  

        objects it is fixed at size * margin'''  

        if not self._stocklike:  

            return abs(size) * self.get_margin(price)  

  

        return size * price  

  

    def getvalue(self, position, price):  

        '''Returns the value of a position given a price. For future- 

like  
﻿        objects it is fixed at size * margin'''  

        if not self._stocklike:  

            return abs(position.size) * self.get_margin(price)  

  

        size = position.size  

        if size >= 0:  

            return size * price  

  

        # With stocks, a short position is worth more as the price  

goes down  

        value = position.price * size  # original value  

        value += (position.price - price) * size  # increased value  

        return value  

  

    def _getcommission(self, size, price, pseudoexec):  

        '''Calculates the commission of an operation at a given price  

  

        pseudoexec: if True the operation has not yet been executed  

        '''  

        if self._commtype == self.COMM_PERC:  

            return abs(size) * self.p.commission * price  

  

        return abs(size) * self.p.commission  

  

    def getcommission(self, size, price):  

        '''Calculates the commission of an operation at a given price  

        '''  
﻿        return self._getcommission(size, price, pseudoexec=True)  

  

    def confirmexec(self, size, price):  

        return self._getcommission(size, price, pseudoexec=False)  

  

    def profitandloss(self, size, price, newprice):  

        '''Return actual profit and loss a position has'''  

        return size * (newprice - price) * self.p.mult  

  

    def cashadjust(self, size, price, newprice):  

        '''Calculates cash adjustment for a given price difference'''  

        if not self._stocklike:  

            return size * (newprice - price) * self.p.mult  

  

        return 0.0  

  

    def get_credit_interest(self, data, pos, dt):  

        '''Calculates the credit due for short selling or product  

specific'''  

        size, price = pos.size, pos.price  

  

        if size > 0 and not self.p.interest_long:  

            return 0.0  # long positions not charged  

  

        dt0 = dt.date()  

        dt1 = pos.datetime.date()  

  
﻿        if dt0 <= dt1:  

            return 0.0  

  

        return self._get_credit_interest(data, size, price,  

                                          (dt0 - dt1).days, dt0, dt1)  

  

    def _get_credit_interest(self, data, size, price, days, dt0, dt1):  

        '''  

        This method returns  the cost in terms of credit interest  

charged by  

        the broker.  

  

        In the case of ``size > 0`` this method will only be called if  

the  

        parameter to the class ``interest_long`` is ``True``  

  

        The formulat for the calculation of the credit interest rate  

is:  

  

          The formula: ``days * price * abs(size) * (interest / 365)``  

  

  

        Params:  

          - ``data``: data feed for which interest is charged  

  

          - ``size``: current position size. > 0 for long positions  

and < 0 for  

            short positions (this parameter will not be ``0``)  
﻿  

          - ``price``: current position price  

  

          - ``days``: number of days elapsed since last credit  

calculation  

             (this is (dt0 - dt1).days)  

  

          - ``dt0``: (datetime.datetime) current datetime  

  

          - ``dt1``: (datetime.datetime) datetime of previous  

calculation  

  

        ``dt0`` and ``dt1`` are not used in the default implementation  

and are  

        provided as extra input for overridden methods  

        '''  

        return days * self._creditrate * abs(size) * price  

  

  

class CommissionInfo(CommInfoBase):  

    '''Base Class for the actual Commission Schemes.  

  

    CommInfoBase was created to keep suppor for the original,  

incomplete,  

    support provided by *backtrader*. New commission schemes derive  

from this  

    class which subclasses ``CommInfoBase``.  

  
﻿    The default value of ``percabs`` is also changed to ``True``  

  

    Params:  

  

      - ``percabs`` (def: True): when ``commtype`` is set to  

COMM_PERC, whether  

        the parameter ``commission`` has to be understood as XX% or  

0.XX  

  

        If this param is True: 0.XX  

        If this param is False: XX%  

  

    '''  

    params = (  

         ('percabs', True),  # Original CommissionInfo took 0.xx for  

percentages  

    )  

  

  

  

##############################  

# 文件: dataseries.txt  

##############################  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  
﻿#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import datetime as _datetime  

from datetime import datetime  

import inspect  

  

from .utils.py3 import range, with_metaclass  
﻿from .lineseries import LineSeries  

from .utils import AutoOrderedDict, OrderedDict, date2num  

  

  

class TimeFrame(object):  

     (Ticks, MicroSeconds, Seconds, Minutes,  

     Days, Weeks, Months, Years, NoTimeFrame) = range(1, 10)  

  

    Names = ['', 'Ticks', 'MicroSeconds', 'Seconds', 'Minutes',  

             'Days', 'Weeks', 'Months', 'Years', 'NoTimeFrame']  

  

    names = Names  # support old naming convention  

  

    @classmethod  

    def getname(cls, tframe, compression=None):  

        tname = cls.Names[tframe]  

        if compression > 1 or tname == cls.Names[-1]:  

            return tname  # for plural or 'NoTimeFrame' return plain  

entry  

  

        # return singular if compression is 1  

        return cls.Names[tframe][:-1]  

  

    @classmethod  

    def TFrame(cls, name):  

        return getattr(cls, name)  

  
﻿    @classmethod  

    def TName(cls, tframe):  

        return cls.Names[tframe]  

  

  

class DataSeries(LineSeries):  

    plotinfo = dict(plot=True, plotind=True, plotylimited=True)  

  

    _name = ''  

    _compression = 1  

    _timeframe = TimeFrame.Days  

  

    Close, Low, High, Open, Volume, OpenInterest, DateTime = range(7)  

  

    LineOrder = [DateTime, Open, High, Low, Close, Volume,  

OpenInterest]  

  

    def getwriterheaders(self):  

        headers = [self._name, 'len']  

  

        for lo in self.LineOrder:  

            headers.append(self._getlinealias(lo))  

  

        morelines = self.getlinealiases()[len(self.LineOrder):]  

        headers.extend(morelines)  

  

        return headers  
﻿  

    def getwritervalues(self):  

        l = len(self)  

        values = [self._name, l]  

  

        if l:  

            values.append(self.datetime.datetime(0))  

            for line in self.LineOrder[1:]:  

                values.append(self.lines[line][0])  

            for i in range(len(self.LineOrder), self.lines.size()):  

                values.append(self.lines[i][0])  

        else:  

            values.extend([''] * self.lines.size())  # no values yet  

  

        return values  

  

    def getwriterinfo(self):  

        # returns dictionary with information  

        info = OrderedDict()  

        info['Name'] = self._name  

        info['Timeframe'] = TimeFrame.TName(self._timeframe)  

        info['Compression'] = self._compression  

  

        return info  

  

  

class OHLC(DataSeries):  
﻿    lines = ('close', 'low', 'high', 'open', 'volume',  

'openinterest',)  

  

  

class OHLCDateTime(OHLC):  

    lines = (('datetime'),)  

  

  

class SimpleFilterWrapper(object):  

    '''Wrapper for filters added via .addfilter to turn them  

    into processors.  

  

    Filters are callables which  

  

      - Take a ``data`` as an argument  

      - Return False if the current bar has not triggered the filter  

      - Return True if the current bar must be filtered  

  

    The wrapper takes the return value and executes the bar removal  

    if needed be  

    '''  

    def __init__(self, data, ffilter, *args, **kwargs):  

        if inspect.isclass(ffilter):  

            ffilter = ffilter(data, *args, **kwargs)  

            args = []  

            kwargs = {}  

  
﻿        self.ffilter = ffilter  

        self.args = args  

        self.kwargs = kwargs  

  

    def __call__(self, data):  

        if self.ffilter(data, *self.args, **self.kwargs):  

            data.backwards()  

            return True  

  

        return False  

  

  

class _Bar(AutoOrderedDict):  

    '''  

    This class is a placeholder for the values of the standard lines  

of a  

    DataBase class (from OHLCDateTime)  

  

    It inherits from AutoOrderedDict to be able to easily return the  

values as  

    an iterable and address the keys as attributes  

  

    Order of definition is important and must match that of the lines  

    definition in DataBase (which directly inherits from OHLCDateTime)  

    '''  

    replaying = False  

  
﻿    # Without - 1 ... converting back to time will not work  

    # Need another -1 to support timezones which may move the time  

forward  

    MAXDATE = date2num(_datetime.datetime.max) - 2  

  

    def __init__(self, maxdate=False):  

        super(_Bar, self).__init__()  

        self.bstart(maxdate=maxdate)  

  

    def bstart(self, maxdate=False):  

        '''Initializes a bar to the default not-updated vaues'''  

        # Order is important: defined in DataSeries/OHLC/OHLCDateTime  

        self.close = float('NaN')  

        self.low = float('inf')  

        self.high = float('-inf')  

        self.open = float('NaN')  

        self.volume = 0.0  

        self.openinterest = 0.0  

        self.datetime = self.MAXDATE if maxdate else None  

  

    def isopen(self):  

        '''Returns if a bar has already been updated  

  

        Uses the fact that NaN is the value which is not equal to  

itself  

        and ``open`` is initialized to NaN  

        '''  
﻿        o = self.open  

        return o == o  # False if NaN, True in other cases  

  

    def bupdate(self, data, reopen=False):  

        '''Updates a bar with the values from data  

  

        Returns True if the update was the 1st on a bar (just opened)  

  

        Returns False otherwise  

        '''  

        if reopen:  

            self.bstart()  

  

        self.datetime = data.datetime[0]  

  

        self.high = max(self.high, data.high[0])  

        self.low = min(self.low, data.low[0])  

        self.close = data.close[0]  

  

        self.volume += data.volume[0]  

        self.openinterest = data.openinterest[0]  

  

        o = self.open  

        if reopen or not o == o:  

            self.open = data.open[0]  

            return True  # just opened the bar  

  
﻿        return False  

  

  

  

##############################  

# 文件: errors.txt  

##############################  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  
﻿<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

  

__all__ = ['BacktraderError', 'StrategySkipError']  

  

  

class BacktraderError(Exception):  

    '''Base exception for all other exceptions'''  

    pass  

  

  

class StrategySkipError(BacktraderError):  

    '''Requests the platform to skip this strategy for backtesting. To  

be  

    raised during the initialization (``__init__``) phase of the  

instance'''  

    pass  

  

  

class ModuleImportError(BacktraderError):  

    '''Raised if a class requests a module to be present to work and  

it cannot  

    be imported'''  
﻿    def __init__(self, message, *args):  

        super(ModuleImportError, self).__init__(message)  

        self.args = args  

  

  

class FromModuleImportError(ModuleImportError):  

    '''Raised if a class requests a module to be present to work and  

it cannot  

    be imported'''  

    def __init__(self, message, *args):  

        super(FromModuleImportError, self).__init__(message, *args)  

  

  

  

##############################  

# 文件: feed.txt  

##############################  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  
﻿# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import collections  

import datetime  

import inspect  

import io  

import os.path  

  

import backtrader as bt  

from backtrader import (date2num, num2date, time2num, TimeFrame,  

dataseries,  

                        metabase)  

  
﻿from backtrader.utils.py3 import with_metaclass, zip, range,  

string_types  

from backtrader.utils import tzparse  

from .dataseries import SimpleFilterWrapper  

from .resamplerfilter import Resampler, Replayer  

from .tradingcal import PandasMarketCalendar  

  

  

class MetaAbstractDataBase(dataseries.OHLCDateTime.__class__):  

    _indcol = dict()  

  

    def __init__(cls, name, bases, dct):  

        '''  

        Class has already been created ... register subclasses  

        '''  

        # Initialize the class  

        super(MetaAbstractDataBase, cls).__init__(name, bases, dct)  

  

        if not cls.aliased and \  

           name != 'DataBase' and not name.startswith('_'):  

            cls._indcol[name] = cls  

  

    def dopreinit(cls, _obj, *args, **kwargs):  

        _obj, args, kwargs = \  

            super(MetaAbstractDataBase, cls).dopreinit(_obj, *args,  

**kwargs)  

  
﻿        # Find the owner and store it  

        _obj._feed = metabase.findowner(_obj, FeedBase)  

  

        _obj.notifs = collections.deque()  # store notifications for  

cerebro  

  

        _obj._dataname = _obj.p.dataname  

        _obj._name = ''  

        return _obj, args, kwargs  

  

    def dopostinit(cls, _obj, *args, **kwargs):  

        _obj, args, kwargs = \  

            super(MetaAbstractDataBase, cls).dopostinit(_obj, *args,  

**kwargs)  

  

        # Either set by subclass or the parameter or use the dataname  

(ticker)  

        _obj._name = _obj._name or _obj.p.name  

        if not _obj._name and isinstance(_obj.p.dataname,  

string_types):  

            _obj._name = _obj.p.dataname  

        _obj._compression = _obj.p.compression  

        _obj._timeframe = _obj.p.timeframe  

  

        if isinstance(_obj.p.sessionstart, datetime.datetime):  

            _obj.p.sessionstart = _obj.p.sessionstart.time()  

  

        elif _obj.p.sessionstart is None:  
﻿            _obj.p.sessionstart = datetime.time.min  

  

        if isinstance(_obj.p.sessionend, datetime.datetime):  

            _obj.p.sessionend = _obj.p.sessionend.time()  

  

        elif _obj.p.sessionend is None:  

            # remove 9 to avoid precision rounding errors  

            _obj.p.sessionend = datetime.time(23, 59, 59, 999990)  

  

        if isinstance(_obj.p.fromdate, datetime.date):  

            # push it to the end of the day, or else intraday  

            # values before the end of the day would be gone  

            if not hasattr(_obj.p.fromdate, 'hour'):  

                _obj.p.fromdate = datetime.datetime.combine(  

                    _obj.p.fromdate, _obj.p.sessionstart)  

  

        if isinstance(_obj.p.todate, datetime.date):  

            # push it to the end of the day, or else intraday  

            # values before the end of the day would be gone  

            if not hasattr(_obj.p.todate, 'hour'):  

                _obj.p.todate = datetime.datetime.combine(  

                    _obj.p.todate, _obj.p.sessionend)  

  

        _obj._barstack = collections.deque()  # for filter operations  

        _obj._barstash = collections.deque()  # for filter operations  

  

        _obj._filters = list()  
﻿        _obj._ffilters = list()  

        for fp in _obj.p.filters:  

            if inspect.isclass(fp):  

                fp = fp(_obj)  

                if hasattr(fp, 'last'):  

                    _obj._ffilters.append((fp, [], {}))  

  

            _obj._filters.append((fp, [], {}))  

  

        return _obj, args, kwargs  

  

  

class AbstractDataBase(with_metaclass(MetaAbstractDataBase,  

                                      dataseries.OHLCDateTime)):  

  

    params = (  

         ('dataname', None),  

         ('name', ''),  

         ('compression', 1),  

         ('timeframe', TimeFrame.Days),  

         ('fromdate', None),  

         ('todate', None),  

         ('sessionstart', None),  

         ('sessionend', None),  

         ('filters', []),  

         ('tz', None),  

         ('tzinput', None),  
﻿         ('qcheck', 0.0),  # timeout in seconds (float) to check for  

events  

         ('calendar', None),  

    )  

  

     (CONNECTED, DISCONNECTED, CONNBROKEN, DELAYED,  

     LIVE, NOTSUBSCRIBED, NOTSUPPORTED_TF, UNKNOWN) = range(8)  

  

    _NOTIFNAMES = [  

        'CONNECTED', 'DISCONNECTED', 'CONNBROKEN', 'DELAYED',  

        'LIVE', 'NOTSUBSCRIBED', 'NOTSUPPORTED_TIMEFRAME', 'UNKNOWN']  

  

    @classmethod  

    def _getstatusname(cls, status):  

        return cls._NOTIFNAMES[status]  

  

    _compensate = None  

    _feed = None  

    _store = None  

  

    _clone = False  

    _qcheck = 0.0  

  

    _tmoffset = datetime.timedelta()  

  

    # Set to non 0 if resampling/replaying  

    resampling = 0  
﻿    replaying = 0  

  

    _started = False  

  

    def _start_finish(self):  

        # A live feed (for example) may have learnt something about  

the  

        # timezones after the start and that's why the date/time  

related  

        # parameters are converted at this late stage  

        # Get the output timezone (if any)  

        self._tz = self._gettz()  

        # Lines have already been create, set the tz  

        self.lines.datetime._settz(self._tz)  

  

        # This should probably be also called from an override-able  

method  

        self._tzinput = bt.utils.date.Localizer(self._gettzinput())  

  

        # Convert user input times to the output timezone (or min/max)  

        if self.p.fromdate is None:  

            self.fromdate = float('-inf')  

        else:  

            self.fromdate = self.date2num(self.p.fromdate)  

  

        if self.p.todate is None:  

            self.todate = float('inf')  

        else:  
﻿            self.todate = self.date2num(self.p.todate)  

  

        # FIXME: These two are never used and could be removed  

        self.sessionstart = time2num(self.p.sessionstart)  

        self.sessionend = time2num(self.p.sessionend)  

  

        self._calendar = cal = self.p.calendar  

        if cal is None:  

            self._calendar = self._env._tradingcal  

        elif isinstance(cal, string_types):  

            self._calendar = PandasMarketCalendar(calendar=cal)  

  

        self._started = True  

  

    def _start(self):  

        self.start()  

  

        if not self._started:  

            self._start_finish()  

  

    def _timeoffset(self):  

        return self._tmoffset  

  

    def _getnexteos(self):  

        '''Returns the next eos using a trading calendar if  

available'''  

        if self._clone:  
﻿            return self.data._getnexteos()  

  

        if not len(self):  

            return datetime.datetime.min, 0.0  

  

        dt = self.lines.datetime[0]  

        dtime = num2date(dt)  

        if self._calendar is None:  

            nexteos = datetime.datetime.combine(dtime,  

self.p.sessionend)  

            nextdteos = self.date2num(nexteos)  # locl'ed -> utc-like  

            nexteos = num2date(nextdteos)  # utc  

            while dtime > nexteos:  

                nexteos += datetime.timedelta(days=1)  # already utc- 

like  

  

            nextdteos = date2num(nexteos)  # -> utc-like  

  

        else:  

            # returns times in utc  

            _, nexteos = self._calendar.schedule(dtime, self._tz)  

            nextdteos = date2num(nexteos)  # nextos is already utc  

  

        return nexteos, nextdteos  

  

    def _gettzinput(self):  

        '''Can be overriden by classes to return a timezone for  

input'''  
﻿        return tzparse(self.p.tzinput)  

  

    def _gettz(self):  

        '''To be overriden by subclasses which may auto-calculate the  

        timezone'''  

        return tzparse(self.p.tz)  

  

    def date2num(self, dt):  

        if self._tz is not None:  

            return date2num(self._tz.localize(dt))  

  

        return date2num(dt)  

  

    def num2date(self, dt=None, tz=None, naive=True):  

        if dt is None:  

            return num2date(self.lines.datetime[0], tz or self._tz,  

naive)  

  

        return num2date(dt, tz or self._tz, naive)  

  

    def haslivedata(self):  

        return False  # must be overriden for those that can  

  

    def do_qcheck(self, onoff, qlapse):  

        # if onoff is True the data will wait p.qcheck for incoming  

live data  

        # on its queue.  
﻿        qwait = self.p.qcheck if onoff else 0.0  

        qwait = max(0.0, qwait - qlapse)  

        self._qcheck = qwait  

  

    def islive(self):  

        '''If this returns True, ``Cerebro`` will deactivate  

``preload`` and  

        ``runonce`` because a live data source must be fetched tick by  

tick (or  

        bar by bar)'''  

        return False  

  

    def put_notification(self, status, *args, **kwargs):  

        '''Add arguments to notification queue'''  

        if self._laststatus != status:  

            self.notifs.append((status, args, kwargs))  

            self._laststatus = status  

  

    def get_notifications(self):  

        '''Return the pending "store" notifications'''  

        # The background thread could keep on adding notifications.  

The None  

        # mark allows to identify which is the last notification to  

deliver  

        self.notifs.append(None)  # put a mark  

        notifs = list()  

        while True:  

            notif = self.notifs.popleft()  
﻿            if notif is None:  # mark is reached  

                break  

            notifs.append(notif)  

  

        return notifs  

  

    def getfeed(self):  

        return self._feed  

  

    def qbuffer(self, savemem=0, replaying=False):  

        extrasize = self.resampling or replaying  

        for line in self.lines:  

            line.qbuffer(savemem=savemem, extrasize=extrasize)  

  

    def start(self):  

        self._barstack = collections.deque()  

        self._barstash = collections.deque()  

        self._laststatus = self.CONNECTED  

  

    def stop(self):  

        pass  

  

    def clone(self, **kwargs):  

        return DataClone(dataname=self, **kwargs)  

  

    def copyas(self, _dataname, **kwargs):  

        d = DataClone(dataname=self, **kwargs)  
﻿        d._dataname = _dataname  

        d._name = _dataname  

        return d  

  

    def setenvironment(self, env):  

        '''Keep a reference to the environment'''  

        self._env = env  

  

    def getenvironment(self):  

        return self._env  

  

    def addfilter_simple(self, f, *args, **kwargs):  

        fp = SimpleFilterWrapper(self, f, *args, **kwargs)  

        self._filters.append((fp, fp.args, fp.kwargs))  

  

    def addfilter(self, p, *args, **kwargs):  

        if inspect.isclass(p):  

            pobj = p(self, *args, **kwargs)  

            self._filters.append((pobj, [], {}))  

  

            if hasattr(pobj, 'last'):  

                self._ffilters.append((pobj, [], {}))  

  

        else:  

            self._filters.append((p, args, kwargs))  

  

    def compensate(self, other):  
﻿        '''Call it to let the broker know that actions on this asset  

will  

        compensate open positions in another'''  

  

        self._compensate = other  

  

    def _tick_nullify(self):  

        # These are the updating prices in case the new bar is  

"updated"  

        # and the length doesn't change like if a replay is happening  

or  

        # a real-time data feed is in use and 1 minutes bars are being  

        # constructed with 5 seconds updates  

        for lalias in self.getlinealiases():  

            if lalias != 'datetime':  

                setattr(self, 'tick_' + lalias, None)  

  

        self.tick_last = None  

  

    def _tick_fill(self, force=False):  

        # If nothing filled the tick_xxx attributes, the bar is the  

tick  

        alias0 = self._getlinealias(0)  

        if force or getattr(self, 'tick_' + alias0, None) is None:  

            for lalias in self.getlinealiases():  

                if lalias != 'datetime':  

                    setattr(self, 'tick_' + lalias,  

                            getattr(self.lines, lalias)[0])  
﻿  

            self.tick_last = getattr(self.lines, alias0)[0]  

  

    def advance_peek(self):  

        if len(self) < self.buflen():  

            return self.lines.datetime[1]  # return the future  

  

        return float('inf')  # max date else  

  

    def advance(self, size=1, datamaster=None, ticks=True):  

        if ticks:  

            self._tick_nullify()  

  

        # Need intercepting this call to support datas with  

        # different lengths (timeframes)  

        self.lines.advance(size)  

  

        if datamaster is not None:  

            if len(self) > self.buflen():  

                # if no bar can be delivered, fill with an empty bar  

                self.rewind()  

                self.lines.forward()  

                return  

  

            if self.lines.datetime[0] > datamaster.lines.datetime[0]:  

                self.lines.rewind()  

            else:  
﻿                if ticks:  

                    self._tick_fill()  

        elif len(self) < self.buflen():  

            # a resampler may have advance us past the last point  

            if ticks:  

                self._tick_fill()  

  

    def next(self, datamaster=None, ticks=True):  

  

        if len(self) >= self.buflen():  

            if ticks:  

                self._tick_nullify()  

  

            # not preloaded - request next bar  

            ret = self.load()  

            if not ret:  

                # if load cannot produce bars - forward the result  

                return ret  

  

            if datamaster is None:  

                # bar is there and no master ... return load's result  

                if ticks:  

                    self._tick_fill()  

                return ret  

        else:  

            self.advance(ticks=ticks)  

  
﻿        # a bar is "loaded" or was preloaded - index has been moved to  

it  

        if datamaster is not None:  

            # there is a time reference to check against  

            if self.lines.datetime[0] > datamaster.lines.datetime[0]:  

                # can't deliver new bar, too early, go back  

                self.rewind()  

                return False  

            else:  

                if ticks:  

                    self._tick_fill()  

  

        else:  

            if ticks:  

                self._tick_fill()  

  

        # tell the world there is a bar (either the new or the  

previous  

        return True  

  

    def preload(self):  

        while self.load():  

            pass  

  

        self._last()  

        self.home()  

  
﻿    def _last(self, datamaster=None):  

        # Last chance for filters to deliver something  

        ret = 0  

        for ff, fargs, fkwargs in self._ffilters:  

            ret += ff.last(self, *fargs, **fkwargs)  

  

        doticks = False  

        if datamaster is not None and self._barstack:  

            doticks = True  

  

        while self._fromstack(forward=True):  

            # consume bar(s) produced by "last"s - adding room  

            pass  

  

        if doticks:  

            self._tick_fill()  

  

        return bool(ret)  

  

    def _check(self, forcedata=None):  

        ret = 0  

        for ff, fargs, fkwargs in self._filters:  

            if not hasattr(ff, 'check'):  

                continue  

            ff.check(self, _forcedata=forcedata, *fargs, **fkwargs)  

  

    def load(self):  
﻿        while True:  

            # move data pointer forward for new bar  

            self.forward()  

  

            if self._fromstack():  # bar is available  

                return True  

  

            if not self._fromstack(stash=True):  

                _loadret = self._load()  

                if not _loadret:  # no bar use force to make sure in  

exactbars  

                    # the pointer is undone this covers especially  

(but not  

                    # uniquely) the case in which the last bar has  

been seen  

                    # and a backwards would ruin pointer accounting in  

the  

                    # "stop" method of the strategy  

                    self.backwards(force=True)  # undo data pointer  

  

                    # return the actual returned value which may be  

None to  

                    # signal no bar is available, but the data feed is  

not  

                    # done. False means game over  

                    return _loadret  

  

            # Get a reference to current loaded time  
﻿            dt = self.lines.datetime[0]  

  

            # A bar has been loaded, adapt the time  

            if self._tzinput:  

                # Input has been converted at face value but it's not  

UTC in  

                # the input stream  

                dtime = num2date(dt)  # get it in a naive datetime  

                # localize it  

                dtime = self._tzinput.localize(dtime)  # pytz  

compatible-ized  

                self.lines.datetime[0] = dt = date2num(dtime)  # keep  

UTC val  

  

            # Check standard date from/to filters  

            if dt < self.fromdate:  

                # discard loaded bar and carry on  

                self.backwards()  

                continue  

            if dt > self.todate:  

                # discard loaded bar and break out  

                self.backwards(force=True)  

                break  

  

            # Pass through filters  

            retff = False  

            for ff, fargs, fkwargs in self._filters:  

                # previous filter may have put things onto the stack  
﻿                if self._barstack:  

                    for i in range(len(self._barstack)):  

                        self._fromstack(forward=True)  

                        retff = ff(self, *fargs, **fkwargs)  

                else:  

                    retff = ff(self, *fargs, **fkwargs)  

  

                if retff:  # bar removed from systemn  

                    break  # out of the inner loop  

  

            if retff:  # bar removed from system - loop to get new bar  

                continue  # in the greater loop  

  

            # Checks let the bar through ... notify it  

            return True  

  

        # Out of the loop ... no more bars or past todate  

        return False  

  

    def _load(self):  

        return False  

  

    def _add2stack(self, bar, stash=False):  

        '''Saves given bar (list of values) to the stack for later  

retrieval'''  

        if not stash:  

            self._barstack.append(bar)  
﻿        else:  

            self._barstash.append(bar)  

  

    def _save2stack(self, erase=False, force=False, stash=False):  

        '''Saves current bar to the bar stack for later retrieval  

  

        Parameter ``erase`` determines removal from the data stream  

        '''  

        bar = [line[0] for line in self.itersize()]  

        if not stash:  

            self._barstack.append(bar)  

        else:  

            self._barstash.append(bar)  

  

        if erase:  # remove bar if requested  

            self.backwards(force=force)  

  

    def _updatebar(self, bar, forward=False, ago=0):  

        '''Load a value from the stack onto the lines to form the new  

bar  

  

        Returns True if values are present, False otherwise  

        '''  

        if forward:  

            self.forward()  

  

        for line, val in zip(self.itersize(), bar):  
﻿            line[0 + ago] = val  

  

    def _fromstack(self, forward=False, stash=False):  

        '''Load a value from the stack onto the lines to form the new  

bar  

  

        Returns True if values are present, False otherwise  

        '''  

  

        coll = self._barstack if not stash else self._barstash  

  

        if coll:  

            if forward:  

                self.forward()  

  

            for line, val in zip(self.itersize(), coll.popleft()):  

                line[0] = val  

  

            return True  

  

        return False  

  

    def resample(self, **kwargs):  

        self.addfilter(Resampler, **kwargs)  

  

    def replay(self, **kwargs):  

        self.addfilter(Replayer, **kwargs)  
﻿  

  

class DataBase(AbstractDataBase):  

    pass  

  

  

class FeedBase(with_metaclass(metabase.MetaParams, object)):  

    params = () + DataBase.params._gettuple()  

  

    def __init__(self):  

        self.datas = list()  

  

    def start(self):  

        for data in self.datas:  

            data.start()  

  

    def stop(self):  

        for data in self.datas:  

            data.stop()  

  

    def getdata(self, dataname, name=None, **kwargs):  

        for pname, pvalue in self.p._getitems():  

            kwargs.setdefault(pname, getattr(self.p, pname))  

  

        kwargs['dataname'] = dataname  

        data = self._getdata(**kwargs)  

  
﻿        data._name = name  

  

        self.datas.append(data)  

        return data  

  

    def _getdata(self, dataname, **kwargs):  

        for pname, pvalue in self.p._getitems():  

            kwargs.setdefault(pname, getattr(self.p, pname))  

  

        kwargs['dataname'] = dataname  

        return self.DataCls(**kwargs)  

  

  

class MetaCSVDataBase(DataBase.__class__):  

    def dopostinit(cls, _obj, *args, **kwargs):  

        # Before going to the base class to make sure it overrides the  

default  

        if not _obj.p.name and not _obj._name:  

            _obj._name, _ =  

os.path.splitext(os.path.basename(_obj.p.dataname))  

  

        _obj, args, kwargs = \  

            super(MetaCSVDataBase, cls).dopostinit(_obj, *args,  

**kwargs)  

  

        return _obj, args, kwargs  

  

  
﻿class CSVDataBase(with_metaclass(MetaCSVDataBase, DataBase)):  

    '''  

    Base class for classes implementing CSV DataFeeds  

  

    The class takes care of opening the file, reading the lines and  

    tokenizing them.  

  

    Subclasses do only need to override:  

  

      - _loadline(tokens)  

  

    The return value of ``_loadline`` (True/False) will be the return  

value  

    of ``_load`` which has been overriden by this base class  

    '''  

  

    f = None  

    params = (('headers', True), ('separator', ','),)  

  

    def start(self):  

        super(CSVDataBase, self).start()  

  

        if self.f is None:  

            if hasattr(self.p.dataname, 'readline'):  

                self.f = self.p.dataname  

            else:  

                # Let an exception propagate to let the caller know  
﻿                self.f = io.open(self.p.dataname, 'r')  

  

        if self.p.headers:  

            self.f.readline()  # skip the headers  

  

        self.separator = self.p.separator  

  

    def stop(self):  

        super(CSVDataBase, self).stop()  

        if self.f is not None:  

            self.f.close()  

            self.f = None  

  

    def preload(self):  

        while self.load():  

            pass  

  

        self._last()  

        self.home()  

  

        # preloaded - no need to keep the object around - breaks  

multip in 3.x  

        self.f.close()  

        self.f = None  

  

    def _load(self):  

        if self.f is None:  
﻿            return False  

  

        # Let an exception propagate to let the caller know  

        line = self.f.readline()  

  

        if not line:  

            return False  

  

        line = line.rstrip('\n')  

        linetokens = line.split(self.separator)  

        return self._loadline(linetokens)  

  

    def _getnextline(self):  

        if self.f is None:  

            return None  

  

        # Let an exception propagate to let the caller know  

        line = self.f.readline()  

  

        if not line:  

            return None  

  

        line = line.rstrip('\n')  

        linetokens = line.split(self.separator)  

        return linetokens  

  

  
﻿class CSVFeedBase(FeedBase):  

    params = (('basepath', ''),) + CSVDataBase.params._gettuple()  

  

    def _getdata(self, dataname, **kwargs):  

        return self.DataCls(dataname=self.p.basepath + dataname,  

                            **self.p._getkwargs())  

  

  

class DataClone(AbstractDataBase):  

    _clone = True  

  

    def __init__(self):  

        self.data = self.p.dataname  

        self._dataname = self.data._dataname  

  

        # Copy date/session parameters  

        self.p.fromdate = self.p.fromdate  

        self.p.todate = self.p.todate  

        self.p.sessionstart = self.data.p.sessionstart  

        self.p.sessionend = self.data.p.sessionend  

  

        self.p.timeframe = self.data.p.timeframe  

        self.p.compression = self.data.p.compression  

  

    def _start(self):  

        # redefine to copy data bits from guest data  

        self.start()  
﻿  

        # Copy tz infos  

        self._tz = self.data._tz  

        self.lines.datetime._settz(self._tz)  

  

        self._calendar = self.data._calendar  

  

        # input has already been converted by guest data  

        self._tzinput = None  # no need to further converr  

  

        # Copy dates/session infos  

        self.fromdate = self.data.fromdate  

        self.todate = self.data.todate  

  

        # FIXME: if removed from guest, remove here too  

        self.sessionstart = self.data.sessionstart  

        self.sessionend = self.data.sessionend  

  

    def start(self):  

        super(DataClone, self).start()  

        self._dlen = 0  

        self._preloading = False  

  

    def preload(self):  

        self._preloading = True  

        super(DataClone, self).preload()  

        self.data.home()  # preloading data was pushed forward  
﻿        self._preloading = False  

  

    def _load(self):  

        # assumption: the data is in the system  

        # simply copy the lines  

        if self._preloading:  

            # data is preloaded, we are preloading too, can move  

            # forward until have full bar or data source is exhausted  

            self.data.advance()  

            if len(self.data) > self.data.buflen():  

                return False  

  

            for line, dline in zip(self.lines, self.data.lines):  

                line[0] = dline[0]  

  

            return True  

  

        # Not preloading  

        if not (len(self.data) > self._dlen):  

            # Data not beyond last seen bar  

            return False  

  

        self._dlen += 1  

  

        for line, dline in zip(self.lines, self.data.lines):  

            line[0] = dline[0]  

  
﻿        return True  

  

    def advance(self, size=1, datamaster=None, ticks=True):  

        self._dlen += size  

        super(DataClone, self).advance(size, datamaster, ticks=ticks)  

  

  

  

##############################  

# 文件: fillers.txt  

##############################  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  
﻿# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

  

from backtrader.utils.py3 import MAXINT, with_metaclass  

  

from backtrader.metabase import MetaParams  

  

  

class FixedSize(with_metaclass(MetaParams, object)):  

    '''Returns the execution size for a given order using a  

*percentage* of the  

    volume in a bar.  

  

    This percentage is set with the parameter ``perc``  

  

    Params:  

  

      - ``size`` (default: ``None``)  maximum size to be executed. The  

actual  
﻿        volume of the bar at execution time is also a limit if smaller  

than the  

        size  

  

        If the value of this parameter evaluates to False, the entire  

volume  

        of the bar will be used to match the order  

    '''  

    params = (('size', None),)  

  

    def __call__(self, order, price, ago):  

        size = self.p.size or MAXINT  

        return min((order.data.volume[ago],  

abs(order.executed.remsize), size))  

  

  

class FixedBarPerc(with_metaclass(MetaParams, object)):  

    '''Returns the execution size for a given order using a  

*percentage* of the  

    volume in a bar.  

  

    This percentage is set with the parameter ``perc``  

  

    Params:  

  

      - ``perc`` (default: ``100.0``) (valied values: ``0.0 - 100.0``)  

  

        Percentage of the volume bar to use to execute an order  
﻿    '''  

    params = (('perc', 100.0),)  

  

    def __call__(self, order, price, ago):  

        # Get the volume and scale it to the requested perc  

        maxsize = (order.data.volume[ago] * self.p.perc) // 100  

        # Return the maximum possible executed volume  

        return min(maxsize, abs(order.executed.remsize))  

  

  

class BarPointPerc(with_metaclass(MetaParams, object)):  

    '''Returns the execution size for a given order. The volume will  

be  

    distributed uniformly in the range *high*-*low* using ``minmov``  

to  

    partition.  

  

    From the allocated volume for the given price, the ``perc``  

percentage will  

    be used  

  

    Params:  

  

      - ``minmov`` (default: ``0.01``)  

  

        Minimum price movement. Used to partition the range *high*- 

*low* to  

        proportionally distribute the volume amongst possible prices  
﻿  

      - ``perc`` (default: ``100.0``) (valied values: ``0.0 - 100.0``)  

  

        Percentage of the volume allocated to the order execution  

price to use  

        for matching  

  

    '''  

    params = (  

         ('minmov', None),  

         ('perc', 100.0),  

    )  

  

    def __call__(self, order, price, ago):  

        data = order.data  

        minmov = self.p.minmov  

  

        parts = 1  

        if minmov:  

            # high - low + minmov to account for open ended minus op  

            parts = (data.high[ago] - data.low[ago] + minmov) //  

minmov  

  

        alloc_vol = ((data.volume[ago] / parts) * self.p.perc) //  

100.0  

  

        # return max possible executable volume  

        return min(alloc_vol, abs(order.executed.remsize))  
﻿  

  

  

##############################  

# 文件: flt.txt  

##############################  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  
﻿#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

  

from .metabase import MetaParams  

from .utils.py3 import with_metaclass  

  

  

__all__ = ['Filter']  

  

  

class MetaFilter(MetaParams):  

    pass  

  

  

class Filter(with_metaclass(MetaParams, object)):  

  

    _firsttime = True  

  

    def __init__(self, data):  

        pass  

  

    def __call__(self, data):  

        if self._firsttime:  
﻿            self.nextstart(data)  

            self._firsttime = False  

  

        self.next(data)  

  

    def nextstart(self, data):  

        pass  

  

    def next(self, data):  

        pass  

  

  

  

##############################  

# 文件: functions.txt  

##############################  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  
﻿# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import functools  

import math  

  

from .linebuffer import LineActions  

from .utils.py3 import cmp, range  

  

  

# Generate a List equivalent which uses "is" for contains  

class List(list):  

    def __contains__(self, other):  

        return any(x.__hash__() == other.__hash__() for x in self)  
﻿  

  

class Logic(LineActions):  

    def __init__(self, *args):  

        super(Logic, self).__init__()  

        self.args = [self.arrayize(arg) for arg in args]  

  

  

class DivByZero(Logic):  

    '''This operation is a Lines object and fills it values by  

executing a  

    division on the numerator / denominator arguments and avoiding a  

division  

    by zero exception by checking the denominator  

  

    Params:  

      - a: numerator (numeric or iterable object ... mostly a Lines  

object)  

      - b: denominator (numeric or iterable object ... mostly a Lines  

object)  

      - zero (def: 0.0): value to apply if division by zero would be  

raised  

  

    '''  

    def __init__(self, a, b, zero=0.0):  

        super(DivByZero, self).__init__(a, b)  

        self.a = a  

        self.b = b  
﻿        self.zero = zero  

  

    def next(self):  

        b = self.b[0]  

        self[0] = self.a[0] / b if b else self.zero  

  

    def once(self, start, end):  

        # cache python dictionary lookups  

        dst = self.array  

        srca = self.a.array  

        srcb = self.b.array  

        zero = self.zero  

  

        for i in range(start, end):  

            b = srcb[i]  

            dst[i] = srca[i] / b if b else zero  

  

  

class DivZeroByZero(Logic):  

    '''This operation is a Lines object and fills it values by  

executing a  

    division on the numerator / denominator arguments and avoiding a  

division  

    by zero exception or an indetermination by checking the  

    denominator/numerator pair  

  

    Params:  
﻿      - a: numerator (numeric or iterable object ... mostly a Lines  

object)  

      - b: denominator (numeric or iterable object ... mostly a Lines  

object)  

      - single (def: +inf): value to apply if division is x / 0  

      - dual (def: 0.0): value to apply if division is 0 / 0  

    '''  

    def __init__(self, a, b, single=float('inf'), dual=0.0):  

        super(DivZeroByZero, self).__init__(a, b)  

        self.a = a  

        self.b = b  

        self.single = single  

        self.dual = dual  

  

    def next(self):  

        b = self.b[0]  

        a = self.a[0]  

        if b == 0.0:  

            self[0] = self.dual if a == 0.0 else self.single  

        else:  

            self[0] = self.a[0] / b  

  

    def once(self, start, end):  

        # cache python dictionary lookups  

        dst = self.array  

        srca = self.a.array  

        srcb = self.b.array  
﻿        single = self.single  

        dual = self.dual  

  

        for i in range(start, end):  

            b = srcb[i]  

            a = srca[i]  

            if b == 0.0:  

                dst[i] = dual if a == 0.0 else single  

            else:  

                dst[i] = a / b  

  

  

class Cmp(Logic):  

    def __init__(self, a, b):  

        super(Cmp, self).__init__(a, b)  

        self.a = self.args[0]  

        self.b = self.args[1]  

  

    def next(self):  

        self[0] = cmp(self.a[0], self.b[0])  

  

    def once(self, start, end):  

        # cache python dictionary lookups  

        dst = self.array  

        srca = self.a.array  

        srcb = self.b.array  

  
﻿        for i in range(start, end):  

            dst[i] = cmp(srca[i], srcb[i])  

  

  

class CmpEx(Logic):  

    def __init__(self, a, b, r1, r2, r3):  

        super(CmpEx, self).__init__(a, b, r1, r2, r3)  

        self.a = self.args[0]  

        self.b = self.args[1]  

        self.r1 = self.args[2]  

        self.r2 = self.args[3]  

        self.r3 = self.args[4]  

  

    def next(self):  

        self[0] = cmp(self.a[0], self.b[0])  

  

    def once(self, start, end):  

        # cache python dictionary lookups  

        dst = self.array  

        srca = self.a.array  

        srcb = self.b.array  

        r1 = self.r1.array  

        r2 = self.r2.array  

        r3 = self.r3.array  

  

        for i in range(start, end):  

            ai = srca[i]  
﻿            bi = srcb[i]  

  

            if ai < bi:  

                dst[i] = r1[i]  

            elif ai > bi:  

                dst[i] = r3[i]  

            else:  

                dst[i] = r2[i]  

  

  

class If(Logic):  

    def __init__(self, cond, a, b):  

        super(If, self).__init__(a, b)  

        self.a = self.args[0]  

        self.b = self.args[1]  

        self.cond = self.arrayize(cond)  

  

    def next(self):  

        self[0] = self.a[0] if self.cond[0] else self.b[0]  

  

    def once(self, start, end):  

        # cache python dictionary lookups  

        dst = self.array  

        srca = self.a.array  

        srcb = self.b.array  

        cond = self.cond.array  

  
﻿        for i in range(start, end):  

            dst[i] = srca[i] if cond[i] else srcb[i]  

  

  

class MultiLogic(Logic):  

    def next(self):  

        self[0] = self.flogic([arg[0] for arg in self.args])  

  

    def once(self, start, end):  

        # cache python dictionary lookups  

        dst = self.array  

        arrays = [arg.array for arg in self.args]  

        flogic = self.flogic  

  

        for i in range(start, end):  

            dst[i] = flogic([arr[i] for arr in arrays])  

  

  

class MultiLogicReduce(MultiLogic):  

    def __init__(self, *args, **kwargs):  

        super(MultiLogicReduce, self).__init__(*args)  

        if 'initializer' not in kwargs:  

            self.flogic = functools.partial(functools.reduce,  

self.flogic)  

        else:  

            self.flogic = functools.partial(functools.reduce,  

self.flogic,  
﻿                                             

initializer=kwargs['initializer'])  

  

  

class Reduce(MultiLogicReduce):  

    def __init__(self, flogic, *args, **kwargs):  

        self.flogic = flogic  

        super(Reduce, self).__init__(*args, **kwargs)  

  

  

# The _xxxlogic functions are defined at module scope to make them  

# pickable and therefore compatible with multiprocessing  

def _andlogic(x, y):  

    return bool(x and y)  

  

  

class And(MultiLogicReduce):  

    flogic = staticmethod(_andlogic)  

  

  

def _orlogic(x, y):  

    return bool(x or y)  

  

  

class Or(MultiLogicReduce):  

    flogic = staticmethod(_orlogic)  

  
﻿  

class Max(MultiLogic):  

    flogic = max  

  

  

class Min(MultiLogic):  

    flogic = min  

  

  

class Sum(MultiLogic):  

    flogic = math.fsum  

  

  

class Any(MultiLogic):  

    flogic = any  

  

  

class All(MultiLogic):  

    flogic = all  

  

  

  

##############################  

# 文件: indicator.txt  

##############################  

  

#!/usr/bin/env python  
﻿# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

  

from .utils.py3 import range, with_metaclass  

  
﻿from .lineiterator import LineIterator, IndicatorBase  

from .lineseries import LineSeriesMaker, Lines  

from .metabase import AutoInfoClass  

  

  

class MetaIndicator(IndicatorBase.__class__):  

    _refname = '_indcol'  

    _indcol = dict()  

  

    _icache = dict()  

    _icacheuse = False  

  

    @classmethod  

    def cleancache(cls):  

        cls._icache = dict()  

  

    @classmethod  

    def usecache(cls, onoff):  

        cls._icacheuse = onoff  

  

    # Object cache deactivated on 2016-08-17. If the object is being  

used  

    # inside another object, the minperiod information carried over  

    # influences the first usage when being modified during the 2nd  

usage  

  

    def __call__(cls, *args, **kwargs):  
﻿        if not cls._icacheuse:  

            return super(MetaIndicator, cls).__call__(*args, **kwargs)  

  

        # implement a cache to avoid duplicating lines actions  

        ckey = (cls, tuple(args), tuple(kwargs.items()))  # tuples  

hashable  

        try:  

            return cls._icache[ckey]  

        except TypeError:  # something not hashable  

            return super(MetaIndicator, cls).__call__(*args, **kwargs)  

        except KeyError:  

            pass  # hashable but not in the cache  

  

        _obj = super(MetaIndicator, cls).__call__(*args, **kwargs)  

        return cls._icache.setdefault(ckey, _obj)  

  

    def __init__(cls, name, bases, dct):  

        '''  

        Class has already been created ... register subclasses  

        '''  

        # Initialize the class  

        super(MetaIndicator, cls).__init__(name, bases, dct)  

  

        if not cls.aliased and \  

           name != 'Indicator' and not name.startswith('_'):  

            refattr = getattr(cls, cls._refname)  

            refattr[name] = cls  
﻿  

        # Check if next and once have both been overridden  

        next_over = cls.next != IndicatorBase.next  

        once_over = cls.once != IndicatorBase.once  

  

        if next_over and not once_over:  

            # No -> need pointer movement to once simulation via next  

            cls.once = cls.once_via_next  

            cls.preonce = cls.preonce_via_prenext  

            cls.oncestart = cls.oncestart_via_nextstart  

  

  

class Indicator(with_metaclass(MetaIndicator, IndicatorBase)):  

    _ltype = LineIterator.IndType  

  

    csv = False  

  

    def advance(self, size=1):  

        # Need intercepting this call to support datas with  

        # different lengths (timeframes)  

        if len(self) < len(self._clock):  

            self.lines.advance(size=size)  

  

    def preonce_via_prenext(self, start, end):  

        # generic implementation if prenext is overridden but preonce  

is not  

        for i in range(start, end):  
﻿            for data in self.datas:  

                data.advance()  

  

            for indicator in  

self._lineiterators[LineIterator.IndType]:  

                indicator.advance()  

  

            self.advance()  

            self.prenext()  

  

    def oncestart_via_nextstart(self, start, end):  

        # nextstart has been overriden, but oncestart has not and the  

code is  

        # here. call the overriden nextstart  

        for i in range(start, end):  

            for data in self.datas:  

                data.advance()  

  

            for indicator in  

self._lineiterators[LineIterator.IndType]:  

                indicator.advance()  

  

            self.advance()  

            self.nextstart()  

  

    def once_via_next(self, start, end):  

        # Not overridden, next must be there ...  

        for i in range(start, end):  
﻿            for data in self.datas:  

                data.advance()  

  

            for indicator in  

self._lineiterators[LineIterator.IndType]:  

                indicator.advance()  

  

            self.advance()  

            self.next()  

  

  

class MtLinePlotterIndicator(Indicator.__class__):  

    def donew(cls, *args, **kwargs):  

        lname = kwargs.pop('name')  

        name = cls.__name__  

  

        lines = getattr(cls, 'lines', Lines)  

        cls.lines = lines._derive(name, (lname,), 0, [])  

  

        plotlines = AutoInfoClass  

        newplotlines = dict()  

        newplotlines.setdefault(lname, dict())  

        cls.plotlines = plotlines._derive(name, newplotlines, [],  

recurse=True)  

  

        # Create the object and set the params in place  

        _obj, args, kwargs =  \  
﻿            super(MtLinePlotterIndicator, cls).donew(*args, **kwargs)  

  

        _obj.owner = _obj.data.owner._clock  

        _obj.data.lines[0].addbinding(_obj.lines[0])  

  

        # Return the object and arguments to the chain  

        return _obj, args, kwargs  

  

  

class LinePlotterIndicator(with_metaclass(MtLinePlotterIndicator,  

Indicator)):  

    pass  

  

  

  

##############################  

# 文件: linebuffer.txt  

##############################  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  
﻿# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

'''  

  

.. module:: linebuffer  

  

Classes that hold the buffer for a *line* and can operate on it  

with appends, forwarding, rewinding, resetting and other  

  

.. moduleauthor:: Daniel Rodriguez  

  

'''  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  
﻿  

import array  

import collections  

import datetime  

from itertools import islice  

import math  

  

from .utils.py3 import range, with_metaclass, string_types  

  

from .lineroot import LineRoot, LineSingle, LineMultiple  

from . import metabase  

from .utils import num2date, time2num  

  

  

NAN = float('NaN')  

  

  

class LineBuffer(LineSingle):  

    '''  

    LineBuffer defines an interface to an "array.array" (or list) in  

which  

    index 0 points to the item which is active for input and output.  

  

    Positive indices fetch values from the past (left hand side)  

    Negative indices fetch values from the future (if the array has  

been  

    extended on the right hand side)  
﻿  

    With this behavior no index has to be passed around to entities  

which have  

    to work with the current value produced by other entities: the  

value is  

    always reachable at "0".  

  

    Likewise storing the current value produced by "self" is done at  

0.  

  

    Additional operations to move the pointer (home, forward, extend,  

rewind,  

    advance getzero) are provided  

  

    The class can also hold "bindings" to other LineBuffers. When a  

value  

    is set in this class  

    it will also be set in the binding.  

    '''  

  

    UnBounded, QBuffer = (0, 1)  

  

    def __init__(self):  

        self.lines = [self]  

        self.mode = self.UnBounded  

        self.bindings = list()  

        self.reset()  

        self._tz = None  
﻿  

    def get_idx(self):  

        return self._idx  

  

    def set_idx(self, idx, force=False):  

        # if QBuffer and the last position of the buffer was reached,  

keep  

        # it (unless force) as index 0. This allows resampling  

        #  - forward adds a position, but the 1st one is discarded,  

the 0 is  

        #  invariant  

        # force supports replaying, which needs the extra bar to float  

        # forward/backwards, because the last input is read, and after  

a  

        # "backwards" is used to update the previous data. Unless the  

position  

        # 0 was moved to the previous index, it would fail  

        if self.mode == self.QBuffer:  

            if force or self._idx < self.lenmark:  

                self._idx = idx  

        else:  # default: UnBounded  

            self._idx = idx  

  

    idx = property(get_idx, set_idx)  

  

    def reset(self):  

        ''' Resets the internal buffer structure and the indices  

        '''  
﻿        if self.mode == self.QBuffer:  

            # add extrasize to ensure resample/replay work because  

they will  

            # use backwards to erase the last bar/tick before  

delivering a new  

            # bar The previous forward would have discarded the bar  

"period"  

            # times ago and it will not come back. Having + 1 in the  

size  

            # allows the forward without removing that bar  

            self.array = collections.deque(maxlen=self.maxlen +  

self.extrasize)  

            self.useislice = True  

        else:  

            self.array = array.array(str('d'))  

            self.useislice = False  

  

        self.lencount = 0  

        self.idx = -1  

        self.extension = 0  

  

    def qbuffer(self, savemem=0, extrasize=0):  

        self.mode = self.QBuffer  

        self.maxlen = self._minperiod  

        self.extrasize = extrasize  

        self.lenmark = self.maxlen -  (not self.extrasize)  

        self.reset()  

  
﻿    def getindicators(self):  

        return []  

  

    def minbuffer(self, size):  

        '''The linebuffer must guarantee the minimum requested size to  

be  

        available.  

  

        In non-dqbuffer mode, this is always true (of course until  

data is  

        filled at the beginning, there are less values, but minperiod  

in the  

        framework should account for this.  

  

        In dqbuffer mode the buffer has to be adjusted for this if  

currently  

        less than requested  

        '''  

        if self.mode != self.QBuffer or self.maxlen >= size:  

            return  

  

        self.maxlen = size  

        self.lenmark = self.maxlen -  (not self.extrasize)  

        self.reset()  

  

    def __len__(self):  

        return self.lencount  

  
﻿    def buflen(self):  

        ''' Real data that can be currently held in the internal  

buffer  

  

        The internal buffer can be longer than the actual stored data  

to  

        allow for "lookahead" operations. The real amount of data that  

is  

        held/can be held in the buffer  

        is returned  

        '''  

        return len(self.array) - self.extension  

  

    def __getitem__(self, ago):  

        return self.array[self.idx + ago]  

  

    def get(self, ago=0, size=1):  

        ''' Returns a slice of the array relative to *ago*  

  

        Keyword Args:  

            ago (int): Point of the array to which size will be added  

            to return the slice size(int): size of the slice to  

return,  

            can be positive or negative  

  

        If size is positive *ago* will mark the end of the iterable  

and vice  

        versa if size is negative  
﻿  

        Returns:  

            A slice of the underlying buffer  

        '''  

        if self.useislice:  

            start = self.idx + ago - size + 1  

            end = self.idx + ago + 1  

            return list(islice(self.array, start, end))  

  

        return self.array[self.idx + ago - size + 1:self.idx + ago +  

1]  

  

    def getzeroval(self, idx=0):  

        ''' Returns a single value of the array relative to the real  

zero  

        of the buffer  

  

        Keyword Args:  

            idx (int): Where to start relative to the real start of  

the buffer  

            size(int): size of the slice to return  

  

        Returns:  

            A slice of the underlying buffer  

        '''  

        return self.array[idx]  

  

    def getzero(self, idx=0, size=1):  
﻿        ''' Returns a slice of the array relative to the real zero of  

the buffer  

  

        Keyword Args:  

            idx (int): Where to start relative to the real start of  

the buffer  

            size(int): size of the slice to return  

  

        Returns:  

            A slice of the underlying buffer  

        '''  

        if self.useislice:  

            return list(islice(self.array, idx, idx + size))  

  

        return self.array[idx:idx + size]  

  

    def __setitem__(self, ago, value):  

        ''' Sets a value at position "ago" and executes any associated  

bindings  

  

        Keyword Args:  

            ago (int): Point of the array to which size will be added  

to return  

            the slice  

            value (variable): value to be set  

        '''  

        self.array[self.idx + ago] = value  

        for binding in self.bindings:  
﻿            binding[ago] = value  

  

    def set(self, value, ago=0):  

        ''' Sets a value at position "ago" and executes any associated  

bindings  

  

        Keyword Args:  

            value (variable): value to be set  

            ago (int): Point of the array to which size will be added  

to return  

            the slice  

        '''  

        self.array[self.idx + ago] = value  

        for binding in self.bindings:  

            binding[ago] = value  

  

    def home(self):  

        ''' Rewinds the logical index to the beginning  

  

        The underlying buffer remains untouched and the actual len can  

be found  

        out with buflen  

        '''  

        self.idx = -1  

        self.lencount = 0  

  

    def forward(self, value=NAN, size=1):  

        ''' Moves the logical index foward and enlarges the buffer as  
﻿much as needed  

  

        Keyword Args:  

            value (variable): value to be set in new positins  

            size (int): How many extra positions to enlarge the buffer  

        '''  

        self.idx += size  

        self.lencount += size  

  

        for i in range(size):  

            self.array.append(value)  

  

    def backwards(self, size=1, force=False):  

        ''' Moves the logical index backwards and reduces the buffer  

as much as needed  

  

        Keyword Args:  

            size (int): How many extra positions to rewind and reduce  

the  

            buffer  

        '''  

        # Go directly to property setter to support force  

        self.set_idx(self._idx - size, force=force)  

        self.lencount -= size  

        for i in range(size):  

            self.array.pop()  

  
﻿    def rewind(self, size=1):  

        self.idx -= size  

        self.lencount -= size  

  

    def advance(self, size=1):  

        ''' Advances the logical index without touching the underlying  

buffer  

  

        Keyword Args:  

            size (int): How many extra positions to move forward  

        '''  

        self.idx += size  

        self.lencount += size  

  

    def extend(self, value=NAN, size=0):  

        ''' Extends the underlying array with positions that the index  

will not reach  

  

        Keyword Args:  

            value (variable): value to be set in new positins  

            size (int): How many extra positions to enlarge the buffer  

  

        The purpose is to allow for lookahead operations or to be able  

to  

        set values in the buffer "future"  

        '''  

        self.extension += size  

        for i in range(size):  
﻿            self.array.append(value)  

  

    def addbinding(self, binding):  

        ''' Adds another line binding  

  

        Keyword Args:  

            binding (LineBuffer): another line that must be set when  

this line  

            becomes a value  

        '''  

        self.bindings.append(binding)  

        # record in the binding when the period is starting (never  

sooner  

        # than self)  

        binding.updateminperiod(self._minperiod)  

  

    def plot(self, idx=0, size=None):  

        ''' Returns a slice of the array relative to the real zero of  

the buffer  

  

        Keyword Args:  

            idx (int): Where to start relative to the real start of  

the buffer  

            size(int): size of the slice to return  

  

        This is a variant of getzero which unless told otherwise  

returns the  

        entire buffer, which is usually the idea behind plottint (all  
﻿must  

        plotted)  

  

        Returns:  

            A slice of the underlying buffer  

        '''  

        return self.getzero(idx, size or len(self))  

  

    def plotrange(self, start, end):  

        if self.useislice:  

            return list(islice(self.array, start, end))  

  

        return self.array[start:end]  

  

    def oncebinding(self):  

        '''  

        Executes the bindings when running in "once" mode  

        '''  

        larray = self.array  

        blen = self.buflen()  

        for binding in self.bindings:  

            binding.array[0:blen] = larray[0:blen]  

  

    def bind2lines(self, binding=0):  

        '''  

        Stores a binding to another line. "binding" can be an index or  

a name  
﻿        '''  

        if isinstance(binding, string_types):  

            line = getattr(self._owner.lines, binding)  

        else:  

            line = self._owner.lines[binding]  

  

        self.addbinding(line)  

  

        return self  

  

    bind2line = bind2lines  

  

    def __call__(self, ago=None):  

        '''Returns either a delayed verison of itself in the form of a  

        LineDelay object or a timeframe adapting version with regards  

to a ago  

  

        Param: ago (default: None)  

  

          If ago is None or an instance of LineRoot (a lines object)  

the  

          returned valued is a LineCoupler instance  

  

          If ago is anything else, it is assumed to be an int and a  

LineDelay  

          object will be returned  

        '''  

        from .lineiterator import LineCoupler  
﻿        if ago is None or isinstance(ago, LineRoot):  

            return LineCoupler(self, ago)  

  

        return LineDelay(self, ago)  

  

    def _makeoperation(self, other, operation, r=False,  

_ownerskip=None):  

        return LinesOperation(self, other, operation, r=r,  

                              _ownerskip=_ownerskip)  

  

    def _makeoperationown(self, operation, _ownerskip=None):  

        return LineOwnOperation(self, operation,  

_ownerskip=_ownerskip)  

  

    def _settz(self, tz):  

        self._tz = tz  

  

    def datetime(self, ago=0, tz=None, naive=True):  

        return num2date(self.array[self.idx + ago],  

                        tz=tz or self._tz, naive=naive)  

  

    def date(self, ago=0, tz=None, naive=True):  

        return num2date(self.array[self.idx + ago],  

                        tz=tz or self._tz, naive=naive).date()  

  

    def time(self, ago=0, tz=None, naive=True):  

        return num2date(self.array[self.idx + ago],  
﻿                        tz=tz or self._tz, naive=naive).time()  

  

    def dt(self, ago=0):  

        '''  

        return numeric date part of datetimefloat  

        '''  

        return math.trunc(self.array[self.idx + ago])  

  

    def tm_raw(self, ago=0):  

        '''  

        return raw numeric time part of datetimefloat  

        '''  

        # This function is named raw because it retrieves the  

fractional part  

        # without transforming it to time to avoid the influence of  

the day  

        # count (integer part of coding)  

        return math.modf(self.array[self.idx + ago])[0]  

  

    def tm(self, ago=0):  

        '''  

        return numeric time part of datetimefloat  

        '''  

        # To avoid precision errors, this returns the fractional part  

after  

        # having converted it to a datetime.time object to avoid  

precision  

        # errors in comparisons  
﻿        return time2num(num2date(self.array[self.idx + ago]).time())  

  

    def tm_lt(self, other, ago=0):  

        '''  

        return numeric time part of datetimefloat  

        '''  

        # To compare a raw "tm" part (fractional part of coded  

datetime)  

        # with the tm of the current datetime, the raw "tm" has to be  

        # brought in sync with the current "day" count (integer part)  

to avoid  

        dtime = self.array[self.idx + ago]  

        tm, dt = math.modf(dtime)  

  

        return dtime < (dt + other)  

  

    def tm_le(self, other, ago=0):  

        '''  

        return numeric time part of datetimefloat  

        '''  

        # To compare a raw "tm" part (fractional part of coded  

datetime)  

        # with the tm of the current datetime, the raw "tm" has to be  

        # brought in sync with the current "day" count (integer part)  

to avoid  

        dtime = self.array[self.idx + ago]  

        tm, dt = math.modf(dtime)  

  
﻿        return dtime <= (dt + other)  

  

    def tm_eq(self, other, ago=0):  

        '''  

        return numeric time part of datetimefloat  

        '''  

        # To compare a raw "tm" part (fractional part of coded  

datetime)  

        # with the tm of the current datetime, the raw "tm" has to be  

        # brought in sync with the current "day" count (integer part)  

to avoid  

        dtime = self.array[self.idx + ago]  

        tm, dt = math.modf(dtime)  

  

        return dtime == (dt + other)  

  

    def tm_gt(self, other, ago=0):  

        '''  

        return numeric time part of datetimefloat  

        '''  

        # To compare a raw "tm" part (fractional part of coded  

datetime)  

        # with the tm of the current datetime, the raw "tm" has to be  

        # brought in sync with the current "day" count (integer part)  

to avoid  

        dtime = self.array[self.idx + ago]  

        tm, dt = math.modf(dtime)  

  
﻿        return dtime > (dt + other)  

  

    def tm_ge(self, other, ago=0):  

        '''  

        return numeric time part of datetimefloat  

        '''  

        # To compare a raw "tm" part (fractional part of coded  

datetime)  

        # with the tm of the current datetime, the raw "tm" has to be  

        # brought in sync with the current "day" count (integer part)  

to avoid  

        dtime = self.array[self.idx + ago]  

        tm, dt = math.modf(dtime)  

  

        return dtime >= (dt + other)  

  

    def tm2dtime(self, tm, ago=0):  

        '''  

        Returns the given ``tm`` in the frame of the (ago bars)  

datatime.  

  

        Useful for external comparisons to avoid precision errors  

        '''  

        return int(self.array[self.idx + ago]) + tm  

  

    def tm2datetime(self, tm, ago=0):  

        '''  

        Returns the given ``tm`` in the frame of the (ago bars)  
﻿datatime.  

  

        Useful for external comparisons to avoid precision errors  

        '''  

        return num2date(int(self.array[self.idx + ago]) + tm)  

  

  

class MetaLineActions(LineBuffer.__class__):  

    '''  

    Metaclass for Lineactions  

  

    Scans the instance before init for LineBuffer (or parentclass  

LineSingle)  

    instances to calculate the minperiod for this instance  

  

    postinit it registers the instance to the owner (remember that  

owner has  

    been found in the base Metaclass for LineRoot)  

    '''  

    _acache = dict()  

    _acacheuse = False  

  

    @classmethod  

    def cleancache(cls):  

        cls._acache = dict()  

  

    @classmethod  
﻿    def usecache(cls, onoff):  

        cls._acacheuse = onoff  

  

    def __call__(cls, *args, **kwargs):  

        if not cls._acacheuse:  

            return super(MetaLineActions, cls).__call__(*args,  

**kwargs)  

  

        # implement a cache to avoid duplicating lines actions  

        ckey = (cls, tuple(args), tuple(kwargs.items()))  # tuples  

hashable  

        try:  

            return cls._acache[ckey]  

        except TypeError:  # something not hashable  

            return super(MetaLineActions, cls).__call__(*args,  

**kwargs)  

        except KeyError:  

            pass  # hashable but not in the cache  

  

        _obj = super(MetaLineActions, cls).__call__(*args, **kwargs)  

        return cls._acache.setdefault(ckey, _obj)  

  

    def dopreinit(cls, _obj, *args, **kwargs):  

        _obj, args, kwargs = \  

            super(MetaLineActions, cls).dopreinit(_obj, *args,  

**kwargs)  

  

        _obj._clock = _obj._owner  # default setting  
﻿  

        if isinstance(args[0], LineRoot):  

            _obj._clock = args[0]  

  

        # Keep a reference to the datas for buffer adjustment purposes  

        _obj._datas = [x for x in args if isinstance(x, LineRoot)]  

  

        # Do not produce anything until the operation lines produce  

something  

        _minperiods = [x._minperiod for x in args if isinstance(x,  

LineSingle)]  

  

        mlines = [x.lines[0] for x in args if isinstance(x,  

LineMultiple)]  

        _minperiods += [x._minperiod for x in mlines]  

  

        _minperiod = max(_minperiods or [1])  

  

        # update own minperiod if needed  

        _obj.updateminperiod(_minperiod)  

  

        return _obj, args, kwargs  

  

    def dopostinit(cls, _obj, *args, **kwargs):  

        _obj, args, kwargs = \  

            super(MetaLineActions, cls).dopostinit(_obj, *args,  

**kwargs)  

  
﻿        # register with _owner to be kicked later  

        _obj._owner.addindicator(_obj)  

  

        return _obj, args, kwargs  

  

  

class PseudoArray(object):  

    def __init__(self, wrapped):  

        self.wrapped = wrapped  

  

    def __getitem__(self, key):  

        return self.wrapped  

  

    @property  

    def array(self):  

        return self  

  

  

class LineActions(with_metaclass(MetaLineActions, LineBuffer)):  

    '''  

    Base class derived from LineBuffer intented to defined the  

    minimum interface to make it compatible with a LineIterator by  

    providing operational _next and _once interfaces.  

  

    The metaclass does the dirty job of calculating minperiods and  

registering  

    '''  
﻿  

    _ltype = LineBuffer.IndType  

  

    def getindicators(self):  

        return []  

  

    def qbuffer(self, savemem=0):  

        super(LineActions, self).qbuffer(savemem=savemem)  

        for data in self._datas:  

            data.minbuffer(size=self._minperiod)  

  

    @staticmethod  

    def arrayize(obj):  

        if isinstance(obj, LineRoot):  

            if not isinstance(obj, LineSingle):  

                obj = obj.lines[0]  # get 1st line from multiline  

        else:  

            obj = PseudoArray(obj)  

  

        return obj  

  

    def _next(self):  

        clock_len = len(self._clock)  

        if clock_len > len(self):  

            self.forward()  

  

        if clock_len > self._minperiod:  
﻿            self.next()  

        elif clock_len == self._minperiod:  

            # only called for the 1st value  

            self.nextstart()  

        else:  

            self.prenext()  

  

    def _once(self):  

        self.forward(size=self._clock.buflen())  

        self.home()  

  

        self.preonce(0, self._minperiod - 1)  

        self.oncestart(self._minperiod - 1, self._minperiod)  

        self.once(self._minperiod, self.buflen())  

  

        self.oncebinding()  

  

  

def LineDelay(a, ago=0, **kwargs):  

    if ago <= 0:  

        return _LineDelay(a, ago, **kwargs)  

  

    return _LineForward(a, ago, **kwargs)  

  

  

def LineNum(num):  

    return LineDelay(PseudoArray(num))  
﻿  

  

class _LineDelay(LineActions):  

    '''  

    Takes a LineBuffer (or derived) object and stores the value from  

    "ago" periods effectively delaying the delivery of data  

    '''  

    def __init__(self, a, ago):  

        super(_LineDelay, self).__init__()  

        self.a = a  

        self.ago = ago  

  

        # Need to add the delay to the period. "ago" is 0 based and  

therefore  

        # we need to pass and extra 1 which is the minimum defined  

period for  

        # any data (which will be substracted inside addminperiod)  

        self.addminperiod(abs(ago) + 1)  

  

    def next(self):  

        self[0] = self.a[self.ago]  

  

    def once(self, start, end):  

        # cache python dictionary lookups  

        dst = self.array  

        src = self.a.array  

        ago = self.ago  
﻿  

        for i in range(start, end):  

            dst[i] = src[i + ago]  

  

  

class _LineForward(LineActions):  

    '''  

    Takes a LineBuffer (or derived) object and stores the value from  

    "ago" periods from the future  

    '''  

    def __init__(self, a, ago):  

        super(_LineForward, self).__init__()  

        self.a = a  

        self.ago = ago  

  

        # Need to add the delay to the period. "ago" is 0 based and  

therefore  

        # we need to pass and extra 1 which is the minimum defined  

period for  

        # any data (which will be substracted inside addminperiod)  

        # self.addminperiod(abs(ago) + 1)  

        if ago > self.a._minperiod:  

            self.addminperiod(ago - self.a._minperiod + 1)  

  

    def next(self):  

        self[-self.ago] = self.a[0]  

  
﻿    def once(self, start, end):  

        # cache python dictionary lookups  

        dst = self.array  

        src = self.a.array  

        ago = self.ago  

  

        for i in range(start, end):  

            dst[i - ago] = src[i]  

  

  

class LinesOperation(LineActions):  

  

    '''  

    Holds an operation that operates on a two operands. Example: mul  

  

    It will "next"/traverse the array applying the operation on the  

    two operands and storing the result in self.  

  

    To optimize the operations and avoid conditional checks the right  

    next/once is chosen using the operation direction (normal or  

reversed)  

    and the nature of the operands (LineBuffer vs non-LineBuffer)  

  

    In the "once" operations "map" could be used as in:  

  

        operated = map(self.operation, srca[start:end],  

srcb[start:end])  
﻿        self.array[start:end] = array.array(str(self.typecode),  

operated)  

  

    No real execution time benefits were appreciated and therefore the  

loops  

    have been kept in place for clarity (although the maps are not  

really  

    unclear here)  

    '''  

  

    def __init__(self, a, b, operation, r=False):  

        super(LinesOperation, self).__init__()  

  

        self.operation = operation  

        self.a = a  # always a linebuffer  

        self.b = b  

  

        self.r = r  

        self.bline = isinstance(b, LineBuffer)  

        self.btime = isinstance(b, datetime.time)  

        self.bfloat = not self.bline and not self.btime  

  

        if r:  

            self.a, self.b = b, a  

  

    def next(self):  

        if self.bline:  

            self[0] = self.operation(self.a[0], self.b[0])  
﻿        elif not self.r:  

            if not self.btime:  

                self[0] = self.operation(self.a[0], self.b)  

            else:  

                self[0] = self.operation(self.a.time(), self.b)  

        else:  

            self[0] = self.operation(self.a, self.b[0])  

  

    def once(self, start, end):  

        if self.bline:  

            self._once_op(start, end)  

        elif not self.r:  

            if not self.btime:  

                self._once_val_op(start, end)  

            else:  

                self._once_time_op(start, end)  

        else:  

            self._once_val_op_r(start, end)  

  

    def _once_op(self, start, end):  

        # cache python dictionary lookups  

        dst = self.array  

        srca = self.a.array  

        srcb = self.b.array  

        op = self.operation  

  

        for i in range(start, end):  
﻿            dst[i] = op(srca[i], srcb[i])  

  

    def _once_time_op(self, start, end):  

        # cache python dictionary lookups  

        dst = self.array  

        srca = self.a.array  

        srcb = self.b  

        op = self.operation  

        tz = self._tz  

  

        for i in range(start, end):  

            dst[i] = op(num2date(srca[i], tz=tz).time(), srcb)  

  

    def _once_val_op(self, start, end):  

        # cache python dictionary lookups  

        dst = self.array  

        srca = self.a.array  

        srcb = self.b  

        op = self.operation  

  

        for i in range(start, end):  

            dst[i] = op(srca[i], srcb)  

  

    def _once_val_op_r(self, start, end):  

        # cache python dictionary lookups  

        dst = self.array  

        srca = self.a  
﻿        srcb = self.b.array  

        op = self.operation  

  

        for i in range(start, end):  

            dst[i] = op(srca, srcb[i])  

  

  

class LineOwnOperation(LineActions):  

    '''  

    Holds an operation that operates on a single operand. Example: abs  

  

    It will "next"/traverse the array applying the operation and  

storing  

    the result in self  

    '''  

    def __init__(self, a, operation):  

        super(LineOwnOperation, self).__init__()  

  

        self.operation = operation  

        self.a = a  

  

    def next(self):  

        self[0] = self.operation(self.a[0])  

  

    def once(self, start, end):  

        # cache python dictionary lookups  

        dst = self.array  
﻿        srca = self.a.array  

        op = self.operation  

  

        for i in range(start, end):  

            dst[i] = op(srca[i])  

  

  

  

##############################  

# 文件: lineiterator.txt  

##############################  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  
﻿# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import collections  

import operator  

import sys  

  

from .utils.py3 import map, range, zip, with_metaclass, string_types  

from .utils import DotDict  

  

from .lineroot import LineRoot, LineSingle  

from .linebuffer import LineActions, LineNum  

from .lineseries import LineSeries, LineSeriesMaker  

from .dataseries import DataSeries  

from . import metabase  

  

  

class MetaLineIterator(LineSeries.__class__):  

    def donew(cls, *args, **kwargs):  
﻿        _obj, args, kwargs = \  

            super(MetaLineIterator, cls).donew(*args, **kwargs)  

  

        # Prepare to hold children that need to be calculated and  

        # influence minperiod - Moved here to support LineNum below  

        _obj._lineiterators = collections.defaultdict(list)  

  

        # Scan args for datas ... if none are found,  

        # use the _owner (to have a clock)  

        mindatas = _obj._mindatas  

        lastarg = 0  

        _obj.datas = []  

        for arg in args:  

            if isinstance(arg, LineRoot):  

                _obj.datas.append(LineSeriesMaker(arg))  

  

            elif not mindatas:  

                break  # found not data and must not be collected  

            else:  

                try:  

                    _obj.datas.append(LineSeriesMaker(LineNum(arg)))  

                except:  

                    # Not a LineNum and is not a LineSeries - bail out  

                    break  

  

            mindatas = max(0, mindatas - 1)  

            lastarg += 1  
﻿  

        newargs = args[lastarg:]  

  

        # If no datas have been passed to an indicator ... use the  

        # main datas of the owner, easing up adding "self.data" ...  

        if not _obj.datas and isinstance(_obj, (IndicatorBase,  

ObserverBase)):  

            _obj.datas = _obj._owner.datas[0:mindatas]  

  

        # Create a dictionary to be able to check for presence  

        # lists in python use "==" operator when testing for presence  

with "in"  

        # which doesn't really check for presence but for equality  

        _obj.ddatas = {x: None for x in _obj.datas}  

  

        # For each found data add access member -  

        # for the first data 2 (data and data0)  

        if _obj.datas:  

            _obj.data = data = _obj.datas[0]  

  

            for l, line in enumerate(data.lines):  

                linealias = data._getlinealias(l)  

                if linealias:  

                    setattr(_obj, 'data_%s' % linealias, line)  

                setattr(_obj, 'data_%d' % l, line)  

  

            for d, data in enumerate(_obj.datas):  
﻿                setattr(_obj, 'data%d' % d, data)  

  

                for l, line in enumerate(data.lines):  

                    linealias = data._getlinealias(l)  

                    if linealias:  

                        setattr(_obj, 'data%d_%s' % (d, linealias),  

line)  

                    setattr(_obj, 'data%d_%d' % (d, l), line)  

  

        # Parameter values have now been set before __init__  

        _obj.dnames = DotDict([(d._name, d)  

                               for d in _obj.datas if getattr(d,  

'_name', '')])  

  

        return _obj, newargs, kwargs  

  

    def dopreinit(cls, _obj, *args, **kwargs):  

        _obj, args, kwargs = \  

            super(MetaLineIterator, cls).dopreinit(_obj, *args,  

**kwargs)  

  

        # if no datas were found use, use the _owner (to have a clock)  

        _obj.datas = _obj.datas or [_obj._owner]  

  

        # 1st data source is our ticking clock  

        _obj._clock = _obj.datas[0]  

  

        # To automatically set the period Start by scanning the found  
﻿datas  

        # No calculation can take place until all datas have yielded  

"data"  

        # A data could be an indicator and it could take x bars until  

        # something is produced  

        _obj._minperiod = \  

            max([x._minperiod for x in _obj.datas] or  

[_obj._minperiod])  

  

        # The lines carry at least the same minperiod as  

        # that provided by the datas  

        for line in _obj.lines:  

            line.addminperiod(_obj._minperiod)  

  

        return _obj, args, kwargs  

  

    def dopostinit(cls, _obj, *args, **kwargs):  

        _obj, args, kwargs = \  

            super(MetaLineIterator, cls).dopostinit(_obj, *args,  

**kwargs)  

  

        # my minperiod is as large as the minperiod of my lines  

        _obj._minperiod = max([x._minperiod for x in _obj.lines])  

  

        # Recalc the period  

        _obj._periodrecalc()  

  

        # Register (my)self as indicator to owner once  
﻿        # _minperiod has been calculated  

        if _obj._owner is not None:  

            _obj._owner.addindicator(_obj)  

  

        return _obj, args, kwargs  

  

  

class LineIterator(with_metaclass(MetaLineIterator, LineSeries)):  

    _nextforce = False  # force cerebro to run in next mode  

(runonce=False)  

  

    _mindatas = 1  

    _ltype = LineSeries.IndType  

  

    plotinfo = dict(plot=True,  

                    subplot=True,  

                    plotname='',  

                    plotskip=False,  

                    plotabove=False,  

                    plotlinelabels=False,  

                    plotlinevalues=True,  

                    plotvaluetags=True,  

                    plotymargin=0.0,  

                    plotyhlines=[],  

                    plotyticks=[],  

                    plothlines=[],  

                    plotforce=False,  
﻿                    plotmaster=None,)  

  

    def _periodrecalc(self):  

        # last check in case not all lineiterators were assigned to  

        # lines (directly or indirectly after some operations)  

        # An example is Kaufman's Adaptive Moving Average  

        indicators = self._lineiterators[LineIterator.IndType]  

        indperiods = [ind._minperiod for ind in indicators]  

        indminperiod = max(indperiods or [self._minperiod])  

        self.updateminperiod(indminperiod)  

  

    def _stage2(self):  

        super(LineIterator, self)._stage2()  

  

        for data in self.datas:  

            data._stage2()  

  

        for lineiterators in self._lineiterators.values():  

            for lineiterator in lineiterators:  

                lineiterator._stage2()  

  

    def _stage1(self):  

        super(LineIterator, self)._stage1()  

  

        for data in self.datas:  

            data._stage1()  

  
﻿        for lineiterators in self._lineiterators.values():  

            for lineiterator in lineiterators:  

                lineiterator._stage1()  

  

    def getindicators(self):  

        return self._lineiterators[LineIterator.IndType]  

  

    def getindicators_lines(self):  

        return [x for x in self._lineiterators[LineIterator.IndType]  

                if hasattr(x.lines, 'getlinealiases')]  

  

    def getobservers(self):  

        return self._lineiterators[LineIterator.ObsType]  

  

    def addindicator(self, indicator):  

        # store in right queue  

        self._lineiterators[indicator._ltype].append(indicator)  

  

        # use getattr because line buffers don't have this attribute  

        if getattr(indicator, '_nextforce', False):  

            # the indicator needs runonce=False  

            o = self  

            while o is not None:  

                if o._ltype == LineIterator.StratType:  

                    o.cerebro._disable_runonce()  

                    break  

  
﻿                o = o._owner  # move up the hierarchy  

  

    def bindlines(self, owner=None, own=None):  

        if not owner:  

            owner = 0  

  

        if isinstance(owner, string_types):  

            owner = [owner]  

        elif not isinstance(owner, collections.Iterable):  

            owner = [owner]  

  

        if not own:  

            own = range(len(owner))  

  

        if isinstance(own, string_types):  

            own = [own]  

        elif not isinstance(own, collections.Iterable):  

            own = [own]  

  

        for lineowner, lineown in zip(owner, own):  

            if isinstance(lineowner, string_types):  

                lownerref = getattr(self._owner.lines, lineowner)  

            else:  

                lownerref = self._owner.lines[lineowner]  

  

            if isinstance(lineown, string_types):  

                lownref = getattr(self.lines, lineown)  
﻿            else:  

                lownref = self.lines[lineown]  

  

            lownref.addbinding(lownerref)  

  

        return self  

  

    # Alias which may be more readable  

    bind2lines = bindlines  

    bind2line = bind2lines  

  

    def _next(self):  

        clock_len = self._clk_update()  

  

        for indicator in self._lineiterators[LineIterator.IndType]:  

            indicator._next()  

  

        self._notify()  

  

        if self._ltype == LineIterator.StratType:  

            # supporting datas with different lengths  

            minperstatus = self._getminperstatus()  

            if minperstatus < 0:  

                self.next()  

            elif minperstatus == 0:  

                self.nextstart()  # only called for the 1st value  

            else:  
﻿                self.prenext()  

        else:  

            # assume indicators and others operate on same length  

datas  

            # although the above operation can be generalized  

            if clock_len > self._minperiod:  

                self.next()  

            elif clock_len == self._minperiod:  

                self.nextstart()  # only called for the 1st value  

            elif clock_len:  

                self.prenext()  

  

    def _clk_update(self):  

        clock_len = len(self._clock)  

        if clock_len != len(self):  

            self.forward()  

  

        return clock_len  

  

    def _once(self):  

        self.forward(size=self._clock.buflen())  

  

        for indicator in self._lineiterators[LineIterator.IndType]:  

            indicator._once()  

  

        for observer in self._lineiterators[LineIterator.ObsType]:  

            observer.forward(size=self.buflen())  
﻿  

        for data in self.datas:  

            data.home()  

  

        for indicator in self._lineiterators[LineIterator.IndType]:  

            indicator.home()  

  

        for observer in self._lineiterators[LineIterator.ObsType]:  

            observer.home()  

  

        self.home()  

  

        # These 3 remain empty for a strategy and therefore play no  

role  

        # because a strategy will always be executed on a next basis  

        # indicators are each called with its min period  

        self.preonce(0, self._minperiod - 1)  

        self.oncestart(self._minperiod - 1, self._minperiod)  

        self.once(self._minperiod, self.buflen())  

  

        for line in self.lines:  

            line.oncebinding()  

  

    def preonce(self, start, end):  

        pass  

  

    def oncestart(self, start, end):  
﻿        self.once(start, end)  

  

    def once(self, start, end):  

        pass  

  

    def prenext(self):  

        '''  

        This method will be called before the minimum period of all  

        datas/indicators have been meet for the strategy to start  

executing  

        '''  

        pass  

  

    def nextstart(self):  

        '''  

        This method will be called once, exactly when the minimum  

period for  

        all datas/indicators have been meet. The default behavior is  

to call  

        next  

        '''  

  

        # Called once for 1st full calculation - defaults to regular  

next  

        self.next()  

  

    def next(self):  

        '''  
﻿        This method will be called for all remaining data points when  

the  

        minimum period for all datas/indicators have been meet.  

        '''  

        pass  

  

    def _addnotification(self, *args, **kwargs):  

        pass  

  

    def _notify(self):  

        pass  

  

    def _plotinit(self):  

        pass  

  

    def qbuffer(self, savemem=0):  

        if savemem:  

            for line in self.lines:  

                line.qbuffer()  

  

        # If called, anything under it, must save  

        for obj in self._lineiterators[self.IndType]:  

            obj.qbuffer(savemem=1)  

  

        # Tell datas to adjust buffer to minimum period  

        for data in self.datas:  

            data.minbuffer(self._minperiod)  
﻿  

  

# This 3 subclasses can be used for identification purposes within  

LineIterator  

# or even outside (like in LineObservers)  

# for the 3 subbranches without generating circular import references  

  

class DataAccessor(LineIterator):  

    PriceClose = DataSeries.Close  

    PriceLow = DataSeries.Low  

    PriceHigh = DataSeries.High  

    PriceOpen = DataSeries.Open  

    PriceVolume = DataSeries.Volume  

    PriceOpenInteres = DataSeries.OpenInterest  

    PriceDateTime = DataSeries.DateTime  

  

  

class IndicatorBase(DataAccessor):  

    pass  

  

  

class ObserverBase(DataAccessor):  

    pass  

  

  

class StrategyBase(DataAccessor):  

    pass  
﻿  

  

# Utility class to couple lines/lineiterators which may have different  

lengths  

# Will only work when runonce=False is passed to Cerebro  

  

class SingleCoupler(LineActions):  

    def __init__(self, cdata, clock=None):  

        super(SingleCoupler, self).__init__()  

        self._clock = clock if clock is not None else self._owner  

  

        self.cdata = cdata  

        self.dlen = 0  

        self.val = float('NaN')  

  

    def next(self):  

        if len(self.cdata) > self.dlen:  

            self.val = self.cdata[0]  

            self.dlen += 1  

  

        self[0] = self.val  

  

  

class MultiCoupler(LineIterator):  

    _ltype = LineIterator.IndType  

  

    def __init__(self):  
﻿        super(MultiCoupler, self).__init__()  

        self.dlen = 0  

        self.dsize = self.fullsize()  # shorcut for number of lines  

        self.dvals = [float('NaN')] * self.dsize  

  

    def next(self):  

        if len(self.data) > self.dlen:  

            self.dlen += 1  

  

            for i in range(self.dsize):  

                self.dvals[i] = self.data.lines[i][0]  

  

        for i in range(self.dsize):  

            self.lines[i][0] = self.dvals[i]  

  

  

def LinesCoupler(cdata, clock=None, **kwargs):  

    if isinstance(cdata, LineSingle):  

        return SingleCoupler(cdata, clock)  # return for single line  

  

    cdatacls = cdata.__class__  # copy important structures before  

creation  

    try:  

        LinesCoupler.counter += 1  # counter for unique class name  

    except AttributeError:  

        LinesCoupler.counter = 0  

  
﻿    # Prepare a MultiCoupler subclass  

    nclsname = str('LinesCoupler_%d' % LinesCoupler.counter)  

    ncls = type(nclsname, (MultiCoupler,), {})  

    thismod = sys.modules[LinesCoupler.__module__]  

    setattr(thismod, ncls.__name__, ncls)  

    # Replace lines et al., to get a sensible clone  

    ncls.lines = cdatacls.lines  

    ncls.params = cdatacls.params  

    ncls.plotinfo = cdatacls.plotinfo  

    ncls.plotlines = cdatacls.plotlines  

  

    obj = ncls(cdata, **kwargs)  # instantiate  

    # The clock is set here to avoid it being interpreted as a data by  

the  

    # LineIterator background scanning code  

    if clock is None:  

        clock = getattr(cdata, '_clock', None)  

        if clock is not None:  

            nclock = getattr(clock, '_clock', None)  

            if nclock is not None:  

                clock = nclock  

            else:  

                nclock = getattr(clock, 'data', None)  

                if nclock is not None:  

                    clock = nclock  

  

        if clock is None:  
﻿            clock = obj._owner  

  

    obj._clock = clock  

    return obj  

  

  

# Add an alias (which seems a lot more sensible for "Single Line"  

lines  

LineCoupler = LinesCoupler  

  

  

  

##############################  

# 文件: lineroot.txt  

##############################  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  
﻿#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

'''  

  

.. module:: lineroot  

  

Definition of the base class LineRoot and base classes  

LineSingle/LineMultiple  

to define interfaces and hierarchy for the real operational classes  

  

.. moduleauthor:: Daniel Rodriguez  

  

'''  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import operator  

  
﻿from .utils.py3 import range, with_metaclass  

  

from . import metabase  

  

  

class MetaLineRoot(metabase.MetaParams):  

    '''  

    Once the object is created (effectively pre-init) the "owner" of  

this  

    class is sought  

    '''  

  

    def donew(cls, *args, **kwargs):  

        _obj, args, kwargs = super(MetaLineRoot, cls).donew(*args,  

**kwargs)  

  

        # Find the owner and store it  

        # startlevel = 4 ... to skip intermediate call stacks  

        ownerskip = kwargs.pop('_ownerskip', None)  

        _obj._owner = metabase.findowner(_obj,  

                                         _obj._OwnerCls or  

LineMultiple,  

                                         skip=ownerskip)  

  

        # Parameter values have now been set before __init__  

        return _obj, args, kwargs  

  

  
﻿class LineRoot(with_metaclass(MetaLineRoot, object)):  

    '''  

    Defines a common base and interfaces for Single and Multiple  

    LineXXX instances  

  

        Period management  

        Iteration management  

        Operation (dual/single operand) Management  

        Rich Comparison operator definition  

    '''  

    _OwnerCls = None  

    _minperiod = 1  

    _opstage = 1  

  

    IndType, StratType, ObsType = range(3)  

  

    def _stage1(self):  

        self._opstage = 1  

  

    def _stage2(self):  

        self._opstage = 2  

  

    def _operation(self, other, operation, r=False, intify=False):  

        if self._opstage == 1:  

            return self._operation_stage1(  

                other, operation, r=r, intify=intify)  

  
﻿        return self._operation_stage2(other, operation, r=r)  

  

    def _operationown(self, operation):  

        if self._opstage == 1:  

            return self._operationown_stage1(operation)  

  

        return self._operationown_stage2(operation)  

  

    def qbuffer(self, savemem=0):  

        '''Change the lines to implement a minimum size qbuffer  

scheme'''  

        raise NotImplementedError  

  

    def minbuffer(self, size):  

        '''Receive notification of how large the buffer must at least  

be'''  

        raise NotImplementedError  

  

    def setminperiod(self, minperiod):  

        '''  

        Direct minperiod manipulation. It could be used for example  

        by a strategy  

        to not wait for all indicators to produce a value  

        '''  

        self._minperiod = minperiod  

  

    def updateminperiod(self, minperiod):  
﻿        '''  

        Update the minperiod if needed. The minperiod will have been  

        calculated elsewhere  

        and has to take over if greater that self's  

        '''  

        self._minperiod = max(self._minperiod, minperiod)  

  

    def addminperiod(self, minperiod):  

        '''  

        Add a minperiod to own ... to be defined by subclasses  

        '''  

        raise NotImplementedError  

  

    def incminperiod(self, minperiod):  

        '''  

        Increment the minperiod with no considerations  

        '''  

        raise NotImplementedError  

  

    def prenext(self):  

        '''  

        It will be called during the "minperiod" phase of an  

iteration.  

        '''  

        pass  

  

    def nextstart(self):  
﻿        '''  

        It will be called when the minperiod phase is over for the 1st  

        post-minperiod value. Only called once and defaults to  

automatically  

        calling next  

        '''  

        self.next()  

  

    def next(self):  

        '''  

        Called to calculate values when the minperiod is over  

        '''  

        pass  

  

    def preonce(self, start, end):  

        '''  

        It will be called during the "minperiod" phase of a "once"  

iteration  

        '''  

        pass  

  

    def oncestart(self, start, end):  

        '''  

        It will be called when the minperiod phase is over for the 1st  

        post-minperiod value  

  

        Only called once and defaults to automatically calling once  
﻿        '''  

        self.once(start, end)  

  

    def once(self, start, end):  

        '''  

        Called to calculate values at "once" when the minperiod is  

over  

        '''  

        pass  

  

    # Arithmetic operators  

    def _makeoperation(self, other, operation, r=False,  

_ownerskip=None):  

        raise NotImplementedError  

  

    def _makeoperationown(self, operation, _ownerskip=None):  

        raise NotImplementedError  

  

    def _operationown_stage1(self, operation):  

        '''  

        Operation with single operand which is "self"  

        '''  

        return self._makeoperationown(operation, _ownerskip=self)  

  

    def _roperation(self, other, operation, intify=False):  

        '''  

        Relies on self._operation to and passes "r" True to define a  
﻿        reverse operation  

        '''  

        return self._operation(other, operation, r=True,  

intify=intify)  

  

    def _operation_stage1(self, other, operation, r=False,  

intify=False):  

        '''  

        Two operands' operation. Scanning of other happens to  

understand  

        if other must be directly an operand or rather a subitem  

thereof  

        '''  

        if isinstance(other, LineMultiple):  

            other = other.lines[0]  

  

        return self._makeoperation(other, operation, r, self)  

  

    def _operation_stage2(self, other, operation, r=False):  

        '''  

        Rich Comparison operators. Scans other and returns either an  

        operation with other directly or a subitem from other  

        '''  

        if isinstance(other, LineRoot):  

            other = other[0]  

  

        # operation(float, other) ... expecting other to be a float  

        if r:  
﻿            return operation(other, self[0])  

  

        return operation(self[0], other)  

  

    def _operationown_stage2(self, operation):  

        return operation(self[0])  

  

    def __add__(self, other):  

        return self._operation(other, operator.__add__)  

  

    def __radd__(self, other):  

        return self._roperation(other, operator.__add__)  

  

    def __sub__(self, other):  

        return self._operation(other, operator.__sub__)  

  

    def __rsub__(self, other):  

        return self._roperation(other, operator.__sub__)  

  

    def __mul__(self, other):  

        return self._operation(other, operator.__mul__)  

  

    def __rmul__(self, other):  

        return self._roperation(other, operator.__mul__)  

  

    def __div__(self, other):  

        return self._operation(other, operator.__div__)  
﻿  

    def __rdiv__(self, other):  

        return self._roperation(other, operator.__div__)  

  

    def __floordiv__(self, other):  

        return self._operation(other, operator.__floordiv__)  

  

    def __rfloordiv__(self, other):  

        return self._roperation(other, operator.__floordiv__)  

  

    def __truediv__(self, other):  

        return self._operation(other, operator.__truediv__)  

  

    def __rtruediv__(self, other):  

        return self._roperation(other, operator.__truediv__)  

  

    def __pow__(self, other):  

        return self._operation(other, operator.__pow__)  

  

    def __rpow__(self, other):  

        return self._roperation(other, operator.__pow__)  

  

    def __abs__(self):  

        return self._operationown(operator.__abs__)  

  

    def __neg__(self):  

        return self._operationown(operator.__neg__)  
﻿  

    def __lt__(self, other):  

        return self._operation(other, operator.__lt__)  

  

    def __gt__(self, other):  

        return self._operation(other, operator.__gt__)  

  

    def __le__(self, other):  

        return self._operation(other, operator.__le__)  

  

    def __ge__(self, other):  

        return self._operation(other, operator.__ge__)  

  

    def __eq__(self, other):  

        return self._operation(other, operator.__eq__)  

  

    def __ne__(self, other):  

        return self._operation(other, operator.__ne__)  

  

    def __nonzero__(self):  

        return self._operationown(bool)  

  

    __bool__ = __nonzero__  

  

    # Python 3 forces explicit implementation of hash if  

    # the class has redefined __eq__  

    __hash__ = object.__hash__  
﻿  

  

class LineMultiple(LineRoot):  

    '''  

    Base class for LineXXX instances that hold more than one line  

    '''  

    def reset(self):  

        self._stage1()  

        self.lines.reset()  

  

    def _stage1(self):  

        super(LineMultiple, self)._stage1()  

        for line in self.lines:  

            line._stage1()  

  

    def _stage2(self):  

        super(LineMultiple, self)._stage2()  

        for line in self.lines:  

            line._stage2()  

  

    def addminperiod(self, minperiod):  

        '''  

        The passed minperiod is fed to the lines  

        '''  

        # pass it down to the lines  

        for line in self.lines:  

            line.addminperiod(minperiod)  
﻿  

    def incminperiod(self, minperiod):  

        '''  

        The passed minperiod is fed to the lines  

        '''  

        # pass it down to the lines  

        for line in self.lines:  

            line.incminperiod(minperiod)  

  

    def _makeoperation(self, other, operation, r=False,  

_ownerskip=None):  

        return self.lines[0]._makeoperation(other, operation, r,  

_ownerskip)  

  

    def _makeoperationown(self, operation, _ownerskip=None):  

        return self.lines[0]._makeoperationown(operation, _ownerskip)  

  

    def qbuffer(self, savemem=0):  

        for line in self.lines:  

            line.qbuffer(savemem=1)  

  

    def minbuffer(self, size):  

        for line in self.lines:  

            line.minbuffer(size)  

  

  

class LineSingle(LineRoot):  
﻿    '''  

    Base class for LineXXX instances that hold a single line  

    '''  

    def addminperiod(self, minperiod):  

        '''  

        Add the minperiod (substracting the overlapping 1 minimum  

period)  

        '''  

        self._minperiod += minperiod - 1  

  

    def incminperiod(self, minperiod):  

        '''  

        Increment the minperiod with no considerations  

        '''  

        self._minperiod += minperiod  

  

  

  

##############################  

# 文件: lineseries.txt  

##############################  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  
﻿# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

'''  

  

.. module:: lineroot  

  

Defines LineSeries and Descriptors inside of it for classes that hold  

multiple  

lines at once.  

  

.. moduleauthor:: Daniel Rodriguez  

  
﻿'''  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import sys  

  

from .utils.py3 import map, range, string_types, with_metaclass  

  

from .linebuffer import LineBuffer, LineActions, LinesOperation,  

LineDelay, NAN  

from .lineroot import LineRoot, LineSingle, LineMultiple  

from .metabase import AutoInfoClass  

from . import metabase  

  

  

class LineAlias(object):  

    ''' Descriptor class that store a line reference and returns that  

line  

    from the owner  

  

    Keyword Args:  

        line (int): reference to the line that will be returned from  

        owner's *lines* buffer  

  

    As a convenience the __set__ method of the descriptor is used not  

set  

    the *line* reference because this is a constant along the live of  

the  
﻿    descriptor instance, but rather to set the value of the *line* at  

the  

    instant '0' (the current one)  

    '''  

  

    def __init__(self, line):  

        self.line = line  

  

    def __get__(self, obj, cls=None):  

        return obj.lines[self.line]  

  

    def __set__(self, obj, value):  

        '''  

        A line cannot be "set" once it has been created. But the  

values  

        inside the line can be "set". This is achieved by adding a  

binding  

        to the line inside "value"  

        '''  

        if isinstance(value, LineMultiple):  

            value = value.lines[0]  

  

        # If the now for sure, LineBuffer 'value' is not a LineActions  

the  

        # binding below could kick-in too early in the chain writing  

the value  

        # into a not yet "forwarded" line, effectively writing the  

value 1  
﻿        # index too early and breaking the functionality (all in next  

mode)  

        # Hence the need to transform it into a LineDelay object of  

null delay  

        if not isinstance(value, LineActions):  

            value = value(0)  

  

        value.addbinding(obj.lines[self.line])  

  

  

class Lines(object):  

    '''  

    Defines an "array" of lines which also has most of the interface  

of  

    a LineBuffer class (forward, rewind, advance...).  

  

    This interface operations are passed to the lines held by self  

  

    The class can autosubclass itself (_derive) to hold new lines  

keeping them  

    in the defined order.  

    '''  

    _getlinesbase = classmethod(lambda cls: ())  

    _getlines = classmethod(lambda cls: ())  

    _getlinesextra = classmethod(lambda cls: 0)  

    _getlinesextrabase = classmethod(lambda cls: 0)  

  

    @classmethod  
﻿    def _derive(cls, name, lines, extralines, otherbases,  

linesoverride=False,  

                lalias=None):  

        '''  

        Creates a subclass of this class with the lines of this class  

as  

        initial input for the subclass. It will include num  

"extralines" and  

        lines present in "otherbases"  

  

        "name" will be used as the suffix of the final class name  

  

        "linesoverride": if True the lines of all bases will be  

discarded and  

        the baseclass will be the topmost class "Lines". This is  

intended to  

        create a new hierarchy  

        '''  

        obaseslines = ()  

        obasesextralines = 0  

  

        for otherbase in otherbases:  

            if isinstance(otherbase, tuple):  

                obaseslines += otherbase  

            else:  

                obaseslines += otherbase._getlines()  

                obasesextralines += otherbase._getlinesextra()  

  
﻿        if not linesoverride:  

            baselines = cls._getlines() + obaseslines  

            baseextralines = cls._getlinesextra() + obasesextralines  

        else:  # overriding lines, skip anything from baseclasses  

            baselines = ()  

            baseextralines = 0  

  

        clslines = baselines + lines  

        clsextralines = baseextralines + extralines  

        lines2add = obaseslines + lines  

  

        # str for Python 2/3 compatibility  

        basecls = cls if not linesoverride else Lines  

  

        newcls = type(str(cls.__name__ + '_' + name), (basecls,), {})  

        clsmodule = sys.modules[cls.__module__]  

        newcls.__module__ = cls.__module__  

        setattr(clsmodule, str(cls.__name__ + '_' + name), newcls)  

  

        setattr(newcls, '_getlinesbase', classmethod(lambda cls:  

baselines))  

        setattr(newcls, '_getlines', classmethod(lambda cls:  

clslines))  

  

        setattr(newcls, '_getlinesextrabase',  

                classmethod(lambda cls: baseextralines))  

        setattr(newcls, '_getlinesextra',  
﻿                classmethod(lambda cls: clsextralines))  

  

        l2start = len(cls._getlines()) if not linesoverride else 0  

        l2add = enumerate(lines2add, start=l2start)  

        l2alias = {} if lalias is None else lalias._getkwargsdefault()  

        for line, linealias in l2add:  

            if not isinstance(linealias, string_types):  

                # a tuple or list was passed, 1st is name  

                linealias = linealias[0]  

  

            desc = LineAlias(line)  # keep a reference below  

            setattr(newcls, linealias, desc)  

  

        # Create extra aliases for the given name, checking if the  

names is in  

        # l2alias (which is from the argument lalias and comes from  

the  

        # directive 'linealias', hence the confusion here (the  

LineAlias come  

        # from the directive 'lines')  

        for line, linealias in enumerate(newcls._getlines()):  

            if not isinstance(linealias, string_types):  

                # a tuple or list was passed, 1st is name  

                linealias = linealias[0]  

  

            desc = LineAlias(line)  # keep a reference below  

            if linealias in l2alias:  

                extranames = l2alias[linealias]  
﻿                if isinstance(linealias, string_types):  

                    extranames = [extranames]  

  

                for ename in extranames:  

                    setattr(newcls, ename, desc)  

  

        return newcls  

  

    @classmethod  

    def _getlinealias(cls, i):  

        '''  

        Return the alias for a line given the index  

        '''  

        lines = cls._getlines()  

        if i >= len(lines):  

            return ''  

        linealias = lines[i]  

        return linealias  

  

    @classmethod  

    def getlinealiases(cls):  

        return cls._getlines()  

  

    def itersize(self):  

        return iter(self.lines[0:self.size()])  

  

    def __init__(self, initlines=None):  
﻿        '''  

        Create the lines recording during "_derive" or else use the  

        provided "initlines"  

        '''  

        self.lines = list()  

        for line, linealias in enumerate(self._getlines()):  

            kwargs = dict()  

            self.lines.append(LineBuffer(**kwargs))  

  

        # Add the required extralines  

        for i in range(self._getlinesextra()):  

            if not initlines:  

                self.lines.append(LineBuffer())  

            else:  

                self.lines.append(initlines[i])  

  

    def __len__(self):  

        '''  

        Proxy line operation  

        '''  

        return len(self.lines[0])  

  

    def size(self):  

        return len(self.lines) - self._getlinesextra()  

  

    def fullsize(self):  

        return len(self.lines)  
﻿  

    def extrasize(self):  

        return self._getlinesextra()  

  

    def __getitem__(self, line):  

        '''  

        Proxy line operation  

        '''  

        return self.lines[line]  

  

    def get(self, ago=0, size=1, line=0):  

        '''  

        Proxy line operation  

        '''  

        return self.lines[line].get(ago, size=size)  

  

    def __setitem__(self, line, value):  

        '''  

        Proxy line operation  

        '''  

        setattr(self, self._getlinealias(line), value)  

  

    def forward(self, value=NAN, size=1):  

        '''  

        Proxy line operation  

        '''  

        for line in self.lines:  
﻿            line.forward(value, size=size)  

  

    def backwards(self, size=1, force=False):  

        '''  

        Proxy line operation  

        '''  

        for line in self.lines:  

            line.backwards(size, force=force)  

  

    def rewind(self, size=1):  

        '''  

        Proxy line operation  

        '''  

        for line in self.lines:  

            line.rewind(size)  

  

    def extend(self, value=NAN, size=0):  

        '''  

        Proxy line operation  

        '''  

        for line in self.lines:  

            line.extend(value, size)  

  

    def reset(self):  

        '''  

        Proxy line operation  

        '''  
﻿        for line in self.lines:  

            line.reset()  

  

    def home(self):  

        '''  

        Proxy line operation  

        '''  

        for line in self.lines:  

            line.home()  

  

    def advance(self, size=1):  

        '''  

        Proxy line operation  

        '''  

        for line in self.lines:  

            line.advance(size)  

  

    def buflen(self, line=0):  

        '''  

        Proxy line operation  

        '''  

        return self.lines[line].buflen()  

  

  

class MetaLineSeries(LineMultiple.__class__):  

    '''  

    Dirty job manager for a LineSeries  
﻿  

      - During __new__ (class creation), it reads "lines", "plotinfo",  

        "plotlines" class variable definitions and turns them into  

        Classes of type Lines or AutoClassInfo (plotinfo/plotlines)  

  

      - During "new" (instance creation) the lines/plotinfo/plotlines  

        classes are substituted in the instance with instances of the  

        aforementioned classes and aliases are added for the "lines"  

held  

        in the "lines" instance  

  

        Additionally and for remaining kwargs, these are matched  

against  

        args in plotinfo and if existent are set there and removed  

from kwargs  

  

        Remember that this Metaclass has a MetaParams (from metabase)  

        as root class and therefore "params" defined for the class  

have been  

        removed from kwargs at an earlier state  

    '''  

  

    def __new__(meta, name, bases, dct):  

        '''  

        Intercept class creation, identifiy lines/plotinfo/plotlines  

class  

        attributes and create corresponding classes for them which  

take over  
﻿        the class attributes  

        '''  

  

        # Get the aliases - don't leave it there for subclasses  

        aliases = dct.setdefault('alias', ())  

        aliased = dct.setdefault('aliased', '')  

  

        # Remove the line definition (if any) from the class creation  

        linesoverride = dct.pop('linesoverride', False)  

        newlines = dct.pop('lines', ())  

        extralines = dct.pop('extralines', 0)  

  

        # remove the new plotinfo/plotlines definition if any  

        newlalias = dict(dct.pop('linealias', {}))  

  

        # remove the new plotinfo/plotlines definition if any  

        newplotinfo = dict(dct.pop('plotinfo', {}))  

        newplotlines = dict(dct.pop('plotlines', {}))  

  

        # Create the class - pulling in any existing "lines"  

        cls = super(MetaLineSeries, meta).__new__(meta, name, bases,  

dct)  

  

        # Check the line aliases before creating the lines  

        lalias = getattr(cls, 'linealias', AutoInfoClass)  

        oblalias = [x.linealias for x in bases[1:] if hasattr(x,  

'linealias')]  
﻿        cls.linealias = la = lalias._derive('la_' + name, newlalias,  

oblalias)  

  

        # Get the actual lines or a default  

        lines = getattr(cls, 'lines', Lines)  

  

        # Create a subclass of the lines class with our name and  

newlines  

        # and put it in the class  

        morebaseslines = [x.lines for x in bases[1:] if hasattr(x,  

'lines')]  

        cls.lines = lines._derive(name, newlines, extralines,  

morebaseslines,  

                                  linesoverride, lalias=la)  

  

        # Get a copy from base class plotinfo/plotlines (created with  

the  

        # class or set a default)  

        plotinfo = getattr(cls, 'plotinfo', AutoInfoClass)  

        plotlines = getattr(cls, 'plotlines', AutoInfoClass)  

  

        # Create a plotinfo/plotlines subclass and set it in the class  

        morebasesplotinfo = \  

             [x.plotinfo for x in bases[1:] if hasattr(x, 'plotinfo')]  

        cls.plotinfo = plotinfo._derive('pi_' + name, newplotinfo,  

                                        morebasesplotinfo)  

  

        # Before doing plotline newlines have been added and no  
﻿plotlineinfo  

        # is there add a default  

        for line in newlines:  

            newplotlines.setdefault(line, dict())  

  

        morebasesplotlines = \  

             [x.plotlines for x in bases[1:] if hasattr(x,  

'plotlines')]  

        cls.plotlines = plotlines._derive(  

            'pl_' + name, newplotlines, morebasesplotlines,  

recurse=True)  

  

        # create declared class aliases (a subclass with no  

modifications)  

        for alias in aliases:  

            newdct = {'__doc__': cls.__doc__,  

                      '__module__': cls.__module__,  

                      'aliased': cls.__name__}  

  

            if not isinstance(alias, string_types):  

                # a tuple or list was passed, 1st is name, 2nd  

plotname  

                aliasplotname = alias[1]  

                alias = alias[0]  

                newdct['plotinfo'] = dict(plotname=aliasplotname)  

  

            newcls = type(str(alias), (cls,), newdct)  

            clsmodule = sys.modules[cls.__module__]  
﻿            setattr(clsmodule, alias, newcls)  

  

        # return the class  

        return cls  

  

    def donew(cls, *args, **kwargs):  

        '''  

        Intercept instance creation, take over  

lines/plotinfo/plotlines  

        class attributes by creating corresponding instance variables  

and add  

        aliases for "lines" and the "lines" held within it  

        '''  

        # _obj.plotinfo shadows the plotinfo (class) definition in the  

class  

        plotinfo = cls.plotinfo()  

  

        for pname, pdef in cls.plotinfo._getitems():  

            setattr(plotinfo, pname, kwargs.pop(pname, pdef))  

  

        # Create the object and set the params in place  

        _obj, args, kwargs = super(MetaLineSeries, cls).donew(*args,  

**kwargs)  

  

        # set the plotinfo member in the class  

        _obj.plotinfo = plotinfo  

  

        # _obj.lines shadows the lines (class) definition in the class  
﻿        _obj.lines = cls.lines()  

  

        # _obj.plotinfo shadows the plotinfo (class) definition in the  

class  

        _obj.plotlines = cls.plotlines()  

  

        # add aliases for lines and for the lines class itself  

        _obj.l = _obj.lines  

        if _obj.lines.fullsize():  

            _obj.line = _obj.lines[0]  

  

        for l, line in enumerate(_obj.lines):  

            setattr(_obj, 'line_%s' % l, _obj._getlinealias(l))  

            setattr(_obj, 'line_%d' % l, line)  

            setattr(_obj, 'line%d' % l, line)  

  

        # Parameter values have now been set before __init__  

        return _obj, args, kwargs  

  

  

class LineSeries(with_metaclass(MetaLineSeries, LineMultiple)):  

    plotinfo = dict(  

        plot=True,  

        plotmaster=None,  

        legendloc=None,  

    )  

  
﻿    csv = True  

  

    @property  

    def array(self):  

        return self.lines[0].array  

  

    def __getattr__(self, name):  

        # to refer to line by name directly if the attribute was not  

found  

        # in this object if we set an attribute in this object it will  

be  

        # found before we end up here  

        return getattr(self.lines, name)  

  

    def __len__(self):  

        return len(self.lines)  

  

    def __getitem__(self, key):  

        return self.lines[0][key]  

  

    def __setitem__(self, key, value):  

        setattr(self.lines, self.lines._getlinealias(key), value)  

  

    def __init__(self, *args, **kwargs):  

        # if any args, kwargs make it up to here, something is broken  

        # defining a __init__ guarantees the existence of im_func to  

findbases  

        # in lineiterator later, because object.__init__ has no  
﻿im_func  

        # (object has slots)  

        super(LineSeries, self).__init__()  

        pass  

  

    def plotlabel(self):  

        label = self.plotinfo.plotname or self.__class__.__name__  

        sublabels = self._plotlabel()  

        if sublabels:  

            for i, sublabel in enumerate(sublabels):  

                # if isinstance(sublabel, LineSeries): ## DOESN'T  

WORK ???  

                if hasattr(sublabel, 'plotinfo'):  

                    try:  

                        s = sublabel.plotinfo.plotname  

                    except:  

                        s = ''  

  

                    sublabels[i] = s or sublabel.__name__  

  

            label += ' (%s)' % ', '.join(map(str, sublabels))  

        return label  

  

    def _plotlabel(self):  

        return self.params._getvalues()  

  

    def _getline(self, line, minusall=False):  
﻿        if isinstance(line, string_types):  

            lineobj = getattr(self.lines, line)  

        else:  

            if line == -1:  # restore original api behavior - default  

-> 0  

                if minusall:  # minus means ... all lines  

                    return None  

                line = 0  

            lineobj = self.lines[line]  

  

        return lineobj  

  

    def __call__(self, ago=None, line=-1):  

        '''Returns either a delayed verison of itself in the form of a  

        LineDelay object or a timeframe adapting version with regards  

to a ago  

  

        Param: ago (default: None)  

  

          If ago is None or an instance of LineRoot (a lines object)  

the  

          returned valued is a LineCoupler instance  

  

          If ago is anything else, it is assumed to be an int and a  

LineDelay  

          object will be returned  

  

        Param: line (default: -1)  
﻿          If a LinesCoupler will be returned ``-1`` means to return a  

          LinesCoupler which adapts all lines of the current  

LineMultiple  

          object. Else the appropriate line (referenced by name or  

index) will  

          be LineCoupled  

  

          If a LineDelay object will be returned, ``-1`` is the same  

as ``0``  

           (to retain compatibility with the previous default value of  

0). This  

          behavior will change to return all existing lines in a  

LineDelayed  

          form  

  

          The referenced line (index or name) will be LineDelayed  

        '''  

        from .lineiterator import LinesCoupler  # avoid circular  

import  

  

        if ago is None or isinstance(ago, LineRoot):  

            args = [self, ago]  

            lineobj = self._getline(line, minusall=True)  

            if lineobj is not None:  

                args[0] = lineobj  

  

            return LinesCoupler(*args, _ownerskip=self)  

  
﻿        # else -> assume type(ago) == int -> return LineDelay object  

        return LineDelay(self._getline(line), ago, _ownerskip=self)  

  

    # The operations below have to be overriden to make sure  

subclasses can  

    # reach them using "super" which will not call __getattr__ and  

    # LineSeriesStub (see below) already uses super  

    def forward(self, value=NAN, size=1):  

        self.lines.forward(value, size)  

  

    def backwards(self, size=1, force=False):  

        self.lines.backwards(size, force=force)  

  

    def rewind(self, size=1):  

        self.lines.rewind(size)  

  

    def extend(self, value=NAN, size=0):  

        self.lines.extend(value, size)  

  

    def reset(self):  

        self.lines.reset()  

  

    def home(self):  

        self.lines.home()  

  

    def advance(self, size=1):  

        self.lines.advance(size)  
﻿  

  

class LineSeriesStub(LineSeries):  

    '''Simulates a LineMultiple object based on LineSeries from a  

single line  

  

    The index management operations are overriden to take into account  

if the  

    line is a slave, ie:  

  

      - The line reference is a line from many in a LineMultiple  

object  

      - Both the LineMultiple object and the Line are managed by the  

same  

        object  

  

    Were slave not to be taken into account, the individual line would  

for  

    example be advanced twice:  

  

      - Once under when the LineMultiple object is advanced (because  

it  

        advances all lines it is holding  

      - Again as part of the regular management of the object holding  

it  

    '''  

  

    extralines = 1  

  
﻿    def __init__(self, line, slave=False):  

        self.lines = self.__class__.lines(initlines=[line])  

        # give a change to find the line owner (for plotting at least)  

        self.owner = self._owner = line._owner  

        self._minperiod = line._minperiod  

        self.slave = slave  

  

    # Only execute the operations below if the object is not a slave  

    def forward(self, value=NAN, size=1):  

        if not self.slave:  

            super(LineSeriesStub, self).forward(value, size)  

  

    def backwards(self, size=1, force=False):  

        if not self.slave:  

            super(LineSeriesStub, self).backwards(size, force=force)  

  

    def rewind(self, size=1):  

        if not self.slave:  

            super(LineSeriesStub, self).rewind(size)  

  

    def extend(self, value=NAN, size=0):  

        if not self.slave:  

            super(LineSeriesStub, self).extend(value, size)  

  

    def reset(self):  

        if not self.slave:  

            super(LineSeriesStub, self).reset()  
﻿  

    def home(self):  

        if not self.slave:  

            super(LineSeriesStub, self).home()  

  

    def advance(self, size=1):  

        if not self.slave:  

            super(LineSeriesStub, self).advance(size)  

  

    def qbuffer(self):  

        if not self.slave:  

            super(LineSeriesStub, self).qbuffer()  

  

    def minbuffer(self, size):  

        if not self.slave:  

            super(LineSeriesStub, self).minbuffer(size)  

  

  

def LineSeriesMaker(arg, slave=False):  

    if isinstance(arg, LineSeries):  

        return arg  

  

    return LineSeriesStub(arg, slave=slave)  

  

  

  

##############################  
﻿# 文件: mathsupport.txt  

##############################  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  
﻿  

import math  

  

  

def average(x, bessel=False):  

    '''  

    Args:  

      x: iterable with len  

  

      oneless: (default ``False``) reduces the length of the array for  

the  

                division.  

  

    Returns:  

      A float with the average of the elements of x  

    '''  

    return math.fsum(x) / (len(x) - bessel)  

  

  

def variance(x, avgx=None):  

    '''  

    Args:  

      x: iterable with len  

  

    Returns:  

      A list with the variance for each element of x  

    '''  
﻿    if avgx is None:  

        avgx = average(x)  

    return [pow(y - avgx, 2.0) for y in x]  

  

  

def standarddev(x, avgx=None, bessel=False):  

    '''  

    Args:  

      x: iterable with len  

  

      bessel: (default ``False``) to be passed to the average to  

divide by  

      ``N - 1`` (Bessel's correction)  

  

    Returns:  

      A float with the standard deviation of the elements of x  

    '''  

    return math.sqrt(average(variance(x, avgx), bessel=bessel))  

  

  

  

##############################  

# 文件: metabase.txt  

##############################  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  
﻿###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

from collections import OrderedDict  

import itertools  

import sys  

  
﻿import backtrader as bt  

from .utils.py3 import zip, string_types, with_metaclass  

  

  

def findbases(kls, topclass):  

    retval = list()  

    for base in kls.__bases__:  

        if issubclass(base, topclass):  

            retval.extend(findbases(base, topclass))  

            retval.append(base)  

  

    return retval  

  

  

def findowner(owned, cls, startlevel=2, skip=None):  

    # skip this frame and the caller's -> start at 2  

    for framelevel in itertools.count(startlevel):  

        try:  

            frame = sys._getframe(framelevel)  

        except ValueError:  

            # Frame depth exceeded ... no owner ... break away  

            break  

  

        # 'self' in regular code  

        self_ = frame.f_locals.get('self', None)  

        if skip is not self_:  

            if self_ is not owned and isinstance(self_, cls):  
﻿                return self_  

  

        # '_obj' in metaclasses  

        obj_ = frame.f_locals.get('_obj', None)  

        if skip is not obj_:  

            if obj_ is not owned and isinstance(obj_, cls):  

                return obj_  

  

    return None  

  

  

class MetaBase(type):  

    def doprenew(cls, *args, **kwargs):  

        return cls, args, kwargs  

  

    def donew(cls, *args, **kwargs):  

        _obj = cls.__new__(cls, *args, **kwargs)  

        return _obj, args, kwargs  

  

    def dopreinit(cls, _obj, *args, **kwargs):  

        return _obj, args, kwargs  

  

    def doinit(cls, _obj, *args, **kwargs):  

        _obj.__init__(*args, **kwargs)  

        return _obj, args, kwargs  

  

    def dopostinit(cls, _obj, *args, **kwargs):  
﻿        return _obj, args, kwargs  

  

    def __call__(cls, *args, **kwargs):  

        cls, args, kwargs = cls.doprenew(*args, **kwargs)  

        _obj, args, kwargs = cls.donew(*args, **kwargs)  

        _obj, args, kwargs = cls.dopreinit(_obj, *args, **kwargs)  

        _obj, args, kwargs = cls.doinit(_obj, *args, **kwargs)  

        _obj, args, kwargs = cls.dopostinit(_obj, *args, **kwargs)  

        return _obj  

  

  

class AutoInfoClass(object):  

    _getpairsbase = classmethod(lambda cls: OrderedDict())  

    _getpairs = classmethod(lambda cls: OrderedDict())  

    _getrecurse = classmethod(lambda cls: False)  

  

    @classmethod  

    def _derive(cls, name, info, otherbases, recurse=False):  

        # collect the 3 set of infos  

        # info = OrderedDict(info)  

        baseinfo = cls._getpairs().copy()  

        obasesinfo = OrderedDict()  

        for obase in otherbases:  

            if isinstance(obase, (tuple, dict)):  

                obasesinfo.update(obase)  

            else:  

                obasesinfo.update(obase._getpairs())  
﻿  

        # update the info of this class (base) with that from the  

other bases  

        baseinfo.update(obasesinfo)  

  

        # The info of the new class is a copy of the full base info  

        # plus and update from parameter  

        clsinfo = baseinfo.copy()  

        clsinfo.update(info)  

  

        # The new items to update/set are those from the otherbase  

plus the new  

        info2add = obasesinfo.copy()  

        info2add.update(info)  

  

        clsmodule = sys.modules[cls.__module__]  

        newclsname = str(cls.__name__ + '_' + name)  # str - Python  

2/3 compat  

  

        # This loop makes sure that if the name has already been  

defined, a new  

        # unique name is found. A collision example is in the  

plotlines names  

        # definitions of bt.indicators.MACD and bt.talib.MACD. Both  

end up  

        # definining a MACD_pl_macd and this makes it impossible for  

the pickle  

        # module to send results over a multiprocessing channel  

        namecounter = 1  
﻿        while hasattr(clsmodule, newclsname):  

            newclsname += str(namecounter)  

            namecounter += 1  

  

        newcls = type(newclsname, (cls,), {})  

        setattr(clsmodule, newclsname, newcls)  

  

        setattr(newcls, '_getpairsbase',  

                classmethod(lambda cls: baseinfo.copy()))  

        setattr(newcls, '_getpairs', classmethod(lambda cls:  

clsinfo.copy()))  

        setattr(newcls, '_getrecurse', classmethod(lambda cls:  

recurse))  

  

        for infoname, infoval in info2add.items():  

            if recurse:  

                recursecls = getattr(newcls, infoname, AutoInfoClass)  

                infoval = recursecls._derive(name + '_' + infoname,  

                                             infoval,  

                                              [])  

  

            setattr(newcls, infoname, infoval)  

  

        return newcls  

  

    def isdefault(self, pname):  

        return self._get(pname) == self._getkwargsdefault()[pname]  
﻿  

    def notdefault(self, pname):  

        return self._get(pname) != self._getkwargsdefault()[pname]  

  

    def _get(self, name, default=None):  

        return getattr(self, name, default)  

  

    @classmethod  

    def _getkwargsdefault(cls):  

        return cls._getpairs()  

  

    @classmethod  

    def _getkeys(cls):  

        return cls._getpairs().keys()  

  

    @classmethod  

    def _getdefaults(cls):  

        return list(cls._getpairs().values())  

  

    @classmethod  

    def _getitems(cls):  

        return cls._getpairs().items()  

  

    @classmethod  

    def _gettuple(cls):  

        return tuple(cls._getpairs().items())  

  
﻿    def _getkwargs(self, skip_=False):  

        l = [  

             (x, getattr(self, x))  

            for x in self._getkeys() if not skip_ or not  

x.startswith('_')]  

        return OrderedDict(l)  

  

    def _getvalues(self):  

        return [getattr(self, x) for x in self._getkeys()]  

  

    def __new__(cls, *args, **kwargs):  

        obj = super(AutoInfoClass, cls).__new__(cls, *args, **kwargs)  

  

        if cls._getrecurse():  

            for infoname in obj._getkeys():  

                recursecls = getattr(cls, infoname)  

                setattr(obj, infoname, recursecls())  

  

        return obj  

  

  

class MetaParams(MetaBase):  

    def __new__(meta, name, bases, dct):  

        # Remove params from class definition to avoid inheritance  

        # (and hence "repetition")  

        newparams = dct.pop('params', ())  

  
﻿        packs = 'packages'  

        newpackages = tuple(dct.pop(packs, ()))  # remove before  

creation  

  

        fpacks = 'frompackages'  

        fnewpackages = tuple(dct.pop(fpacks, ()))  # remove before  

creation  

  

        # Create the new class - this pulls predefined "params"  

        cls = super(MetaParams, meta).__new__(meta, name, bases, dct)  

  

        # Pulls the param class out of it - default is the empty class  

        params = getattr(cls, 'params', AutoInfoClass)  

  

        # Pulls the packages class out of it - default is the empty  

class  

        packages = tuple(getattr(cls, packs, ()))  

        fpackages = tuple(getattr(cls, fpacks, ()))  

  

        # get extra (to the right) base classes which have a param  

attribute  

        morebasesparams = [x.params for x in bases[1:] if hasattr(x,  

'params')]  

  

        # Get extra packages, add them to the packages and put all in  

the class  

        for y in [x.packages for x in bases[1:] if hasattr(x, packs)]:  

            packages += tuple(y)  
﻿  

        for y in [x.frompackages for x in bases[1:] if hasattr(x,  

fpacks)]:  

            fpackages += tuple(y)  

  

        cls.packages = packages + newpackages  

        cls.frompackages = fpackages + fnewpackages  

  

        # Subclass and store the newly derived params class  

        cls.params = params._derive(name, newparams, morebasesparams)  

  

        return cls  

  

    def donew(cls, *args, **kwargs):  

        clsmod = sys.modules[cls.__module__]  

        # import specified packages  

        for p in cls.packages:  

            if isinstance(p, (tuple, list)):  

                p, palias = p  

            else:  

                palias = p  

  

            pmod = __import__(p)  

  

            plevels = p.split('.')  

            if p == palias and len(plevels) > 1:  # 'os.path' not  

aliased  
﻿                setattr(clsmod, pmod.__name__, pmod)  # set 'os' in  

module  

  

            else:  # aliased and/or dots  

                for plevel in plevels[1:]:  # recurse down the mod  

                    pmod = getattr(pmod, plevel)  

  

                setattr(clsmod, palias, pmod)  

  

        # import from specified packages - the 2nd part is a string or  

iterable  

        for p, frompackage in cls.frompackages:  

            if isinstance(frompackage, string_types):  

                frompackage = (frompackage,)  # make it a tuple  

  

            for fp in frompackage:  

                if isinstance(fp, (tuple, list)):  

                    fp, falias = fp  

                else:  

                    fp, falias = fp, fp  # assumed is string  

  

                # complain "not string" without fp (unicode vs bytes)  

                pmod = __import__(p, fromlist=[str(fp)])  

                pattr = getattr(pmod, fp)  

                setattr(clsmod, falias, pattr)  

                for basecls in cls.__bases__:  

                    setattr(sys.modules[basecls.__module__], falias,  

pattr)  
﻿  

        # Create params and set the values from the kwargs  

        params = cls.params()  

        for pname, pdef in cls.params._getitems():  

            setattr(params, pname, kwargs.pop(pname, pdef))  

  

        # Create the object and set the params in place  

        _obj, args, kwargs = super(MetaParams, cls).donew(*args,  

**kwargs)  

        _obj.params = params  

        _obj.p = params  # shorter alias  

  

        # Parameter values have now been set before __init__  

        return _obj, args, kwargs  

  

  

class ParamsBase(with_metaclass(MetaParams, object)):  

    pass  # stub to allow easy subclassing without metaclasses  

  

  

class ItemCollection(object):  

    '''  

    Holds a collection of items that can be reached by  

  

      - Index  

      - Name (if set in the append operation)  

    '''  
﻿    def __init__(self):  

        self._items = list()  

        self._names = list()  

  

    def __len__(self):  

        return len(self._items)  

  

    def append(self, item, name=None):  

        setattr(self, name, item)  

        self._items.append(item)  

        if name:  

            self._names.append(name)  

  

    def __getitem__(self, key):  

        return self._items[key]  

  

    def getnames(self):  

        return self._names  

  

    def getitems(self):  

        return zip(self._names, self._items)  

  

    def getbyname(self, name):  

        idx = self._names.index(name)  

        return self._items[idx]  

  

  
﻿  

##############################  

# 文件: observer.txt  

##############################  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  
﻿from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

  

from .lineiterator import LineIterator, ObserverBase, StrategyBase  

from backtrader.utils.py3 import with_metaclass  

  

  

class MetaObserver(ObserverBase.__class__):  

    def donew(cls, *args, **kwargs):  

        _obj, args, kwargs = super(MetaObserver, cls).donew(*args,  

**kwargs)  

        _obj._analyzers = list()  # keep children analyzers  

  

        return _obj, args, kwargs  # return the instantiated object  

and args  

  

    def dopreinit(cls, _obj, *args, **kwargs):  

        _obj, args, kwargs = \  

            super(MetaObserver, cls).dopreinit(_obj, *args, **kwargs)  

  

        if _obj._stclock:  # Change clock if strategy wide observer  

            _obj._clock = _obj._owner  

  

        return _obj, args, kwargs  

  

  
﻿class Observer(with_metaclass(MetaObserver, ObserverBase)):  

    _stclock = False  

  

    _OwnerCls = StrategyBase  

    _ltype = LineIterator.ObsType  

  

    csv = True  

  

    plotinfo = dict(plot=False, subplot=True)  

  

    # An Observer is ideally always observing and that' why prenext  

calls  

    # next. The behaviour can be overriden by subclasses  

    def prenext(self):  

        self.next()  

  

    def _register_analyzer(self, analyzer):  

        self._analyzers.append(analyzer)  

  

    def _start(self):  

        self.start()  

  

    def start(self):  

        pass  

  

  

  
﻿##############################  

# 文件: order.txt  

##############################  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  
﻿                        unicode_literals)  

  

import collections  

from copy import copy  

import datetime  

import itertools  

  

from .utils.py3 import range, with_metaclass, iteritems  

  

from .metabase import MetaParams  

from .utils import AutoOrderedDict  

  

  

class OrderExecutionBit(object):  

    '''  

    Intended to hold information about order execution. A "bit" does  

not  

    determine if the order has been fully/partially executed, it just  

holds  

    information.  

  

    Member Attributes:  

  

      - dt: datetime (float) execution time  

      - size: how much was executed  

      - price: execution price  

      - closed: how much of the execution closed an existing postion  
﻿      - opened: how much of the execution opened a new position  

      - openedvalue: market value of the "opened" part  

      - closedvalue: market value of the "closed" part  

      - closedcomm: commission for the "closed" part  

      - openedcomm: commission for the "opened" part  

  

      - value: market value for the entire bit size  

      - comm: commission for the entire bit execution  

      - pnl: pnl generated by this bit (if something was closed)  

  

      - psize: current open position size  

      - pprice: current open position price  

  

    '''  

  

    def __init__(self,  

                 dt=None, size=0, price=0.0,  

                 closed=0, closedvalue=0.0, closedcomm=0.0,  

                 opened=0, openedvalue=0.0, openedcomm=0.0,  

                 pnl=0.0,  

                 psize=0, pprice=0.0):  

  

        self.dt = dt  

        self.size = size  

        self.price = price  

  

        self.closed = closed  
﻿        self.opened = opened  

        self.closedvalue = closedvalue  

        self.openedvalue = openedvalue  

        self.closedcomm = closedcomm  

        self.openedcomm = openedcomm  

  

        self.value = closedvalue + openedvalue  

        self.comm = closedcomm + openedcomm  

        self.pnl = pnl  

  

        self.psize = psize  

        self.pprice = pprice  

  

  

class OrderData(object):  

    '''  

    Holds actual order data for Creation and Execution.  

  

    In the case of Creation the request made and in the case of  

Execution the  

    actual outcome.  

  

    Member Attributes:  

  

      - exbits : iterable of OrderExecutionBits for this OrderData  

  

      - dt: datetime (float) creation/execution time  
﻿      - size: requested/executed size  

      - price: execution price  

        Note: if no price is given and no pricelimite is given, the  

closing  

        price at the time or order creation will be used as reference  

      - pricelimit: holds pricelimit for StopLimit (which has trigger  

first)  

      - trailamount: absolute price distance in trailing stops  

      - trailpercent: percentage price distance in trailing stops  

  

      - value: market value for the entire bit size  

      - comm: commission for the entire bit execution  

      - pnl: pnl generated by this bit (if something was closed)  

      - margin: margin incurred by the Order (if any)  

  

      - psize: current open position size  

      - pprice: current open position price  

  

    '''  

    # According to the docs, collections.deque is thread-safe with  

appends at  

    # both ends, there will be no pop (nowhere) and therefore to know  

which the  

    # new exbits are two indices are needed. At time of cloning  

(__copy__) the  

    # indices can be updated to match the previous end, and the new  

end  

    # (len(exbits)  
﻿    # Example: start 0, 0 -> islice(exbits, 0, 0) -> []  

    # One added -> copy -> updated 0, 1 -> islice(exbits, 0, 1) -> [1  

elem]  

    # Other added -> copy -> updated 1, 2 -> islice(exbits, 1, 2) ->  

[1 elem]  

    # "add" and "__copy__" happen always in the same thread (with all  

current  

    # implementations) and therefore no append will happen during a  

copy and  

    # the len of the exbits can be queried with no concerns about  

another  

    # thread making an append and with no need for a lock  

  

    def __init__(self, dt=None, size=0, price=0.0, pricelimit=0.0,  

remsize=0,  

                 pclose=0.0, trailamount=0.0, trailpercent=0.0):  

  

        self.pclose = pclose  

        self.exbits = collections.deque()  # for historical purposes  

        self.p1, self.p2 = 0, 0  # indices to pending notifications  

  

        self.dt = dt  

        self.size = size  

        self.remsize = remsize  

        self.price = price  

        self.pricelimit = pricelimit  

        self.trailamount = trailamount  

        self.trailpercent = trailpercent  
﻿  

        if not pricelimit:  

            # if no pricelimit is given, use the given price  

            self.pricelimit = self.price  

  

        if pricelimit and not price:  

            # price must always be set if pricelimit is set ...  

            self.price = pricelimit  

  

        self.plimit = pricelimit  

  

        self.value = 0.0  

        self.comm = 0.0  

        self.margin = None  

        self.pnl = 0.0  

  

        self.psize = 0  

        self.pprice = 0  

  

    def _getplimit(self):  

        return self._plimit  

  

    def _setplimit(self, val):  

        self._plimit = val  

  

    plimit = property(_getplimit, _setplimit)  

  
﻿    def __len__(self):  

        return len(self.exbits)  

  

    def __getitem__(self, key):  

        return self.exbits[key]  

  

    def add(self, dt, size, price,  

            closed=0, closedvalue=0.0, closedcomm=0.0,  

            opened=0, openedvalue=0.0, openedcomm=0.0,  

            pnl=0.0,  

            psize=0, pprice=0.0):  

  

        self.addbit(  

            OrderExecutionBit(dt, size, price,  

                              closed, closedvalue, closedcomm,  

                              opened, openedvalue, openedcomm, pnl,  

                              psize, pprice))  

  

    def addbit(self, exbit):  

        # Stores an ExecutionBit and recalculates own values from  

ExBit  

        self.exbits.append(exbit)  

  

        self.remsize -= exbit.size  

  

        self.dt = exbit.dt  

        oldvalue = self.size * self.price  
﻿        newvalue = exbit.size * exbit.price  

        self.size += exbit.size  

        self.price = (oldvalue + newvalue) / self.size  

        self.value += exbit.value  

        self.comm += exbit.comm  

        self.pnl += exbit.pnl  

        self.psize = exbit.psize  

        self.pprice = exbit.pprice  

  

    def getpending(self):  

        return list(self.iterpending())  

  

    def iterpending(self):  

        return itertools.islice(self.exbits, self.p1, self.p2)  

  

    def markpending(self):  

        # rebuild the indices to mark which exbits are pending in  

clone  

        self.p1, self.p2 = self.p2, len(self.exbits)  

  

    def clone(self):  

        self.markpending()  

        obj = copy(self)  

        return obj  

  

  

class OrderBase(with_metaclass(MetaParams, object)):  
﻿    params = (  

         ('owner', None), ('data', None),  

         ('size', None), ('price', None), ('pricelimit', None),  

         ('exectype', None), ('valid', None), ('tradeid', 0), ('oco',  

None),  

         ('trailamount', None), ('trailpercent', None),  

         ('parent', None), ('transmit', True),  

         ('simulated', False),  

        # To support historical order evaluation  

         ('histnotify', False),  

    )  

  

    DAY = datetime.timedelta()  # constant for DAY order  

identification  

  

    # Time Restrictions for orders  

    T_Close, T_Day, T_Date, T_None = range(4)  

  

    # Volume Restrictions for orders  

    V_None = range(1)  

  

     (Market, Close, Limit, Stop, StopLimit, StopTrail, StopTrailLimit,  

     Historical) = range(8)  

    ExecTypes = ['Market', 'Close', 'Limit', 'Stop', 'StopLimit',  

'StopTrail',  

                 'StopTrailLimit', 'Historical']  

  

    OrdTypes = ['Buy', 'Sell']  
﻿    Buy, Sell = range(2)  

  

    Created, Submitted, Accepted, Partial, Completed, \  

        Canceled, Expired, Margin, Rejected = range(9)  

  

    Cancelled = Canceled  # alias  

  

    Status = [  

        'Created', 'Submitted', 'Accepted', 'Partial', 'Completed',  

        'Canceled', 'Expired', 'Margin', 'Rejected',  

    ]  

  

    refbasis = itertools.count(1)  # for a unique identifier per order  

  

    def _getplimit(self):  

        return self._plimit  

  

    def _setplimit(self, val):  

        self._plimit = val  

  

    plimit = property(_getplimit, _setplimit)  

  

    def __getattr__(self, name):  

        # Return attr from params if not found in order  

        return getattr(self.params, name)  

  

    def __setattribute__(self, name, value):  
﻿        if hasattr(self.params, name):  

            setattr(self.params, name, value)  

        else:  

            super(Order, self).__setattribute__(name, value)  

  

    def __str__(self):  

        tojoin = list()  

        tojoin.append('Ref: {}'.format(self.ref))  

        tojoin.append('OrdType: {}'.format(self.ordtype))  

        tojoin.append('OrdType: {}'.format(self.ordtypename()))  

        tojoin.append('Status: {}'.format(self.status))  

        tojoin.append('Status: {}'.format(self.getstatusname()))  

        tojoin.append('Size: {}'.format(self.size))  

        tojoin.append('Price: {}'.format(self.price))  

        tojoin.append('Price Limit: {}'.format(self.pricelimit))  

        tojoin.append('TrailAmount: {}'.format(self.trailamount))  

        tojoin.append('TrailPercent: {}'.format(self.trailpercent))  

        tojoin.append('ExecType: {}'.format(self.exectype))  

        tojoin.append('ExecType: {}'.format(self.getordername()))  

        tojoin.append('CommInfo: {}'.format(self.comminfo))  

        tojoin.append('End of Session: {}'.format(self.dteos))  

        tojoin.append('Info: {}'.format(self.info))  

        tojoin.append('Broker: {}'.format(self.broker))  

        tojoin.append('Alive: {}'.format(self.alive()))  

  

        return '\n'.join(tojoin)  

  
﻿    def __init__(self):  

        self.ref = next(self.refbasis)  

        self.broker = None  

        self.info = AutoOrderedDict()  

        self.comminfo = None  

        self.triggered = False  

  

        self._active = self.parent is None  

        self.status = Order.Created  

  

        self.plimit = self.p.pricelimit  # alias via property  

  

        if self.exectype is None:  

            self.exectype = Order.Market  

  

        if not self.isbuy():  

            self.size = -self.size  

  

        # Set a reference price if price is not set using  

        # the close price  

        pclose = self.data.close[0] if not self.p.simulated else  

self.price  

        price = pclose if not self.price and not self.pricelimit else  

self.price  

  

        dcreated = self.data.datetime[0] if not self.p.simulated else  

0.0  

        self.created = OrderData(dt=dcreated,  
﻿                                 size=self.size,  

                                 price=price,  

                                 pricelimit=self.pricelimit,  

                                 pclose=pclose,  

                                 trailamount=self.trailamount,  

                                 trailpercent=self.trailpercent)  

  

        # Adjust price in case a trailing limit is wished  

        if self.exectype in [Order.StopTrail, Order.StopTrailLimit]:  

            self._limitoffset = self.created.price -  

self.created.pricelimit  

            price = self.created.price  

            self.created.price = float('inf' * self.isbuy() or '-inf')  

            self.trailadjust(price)  

        else:  

            self._limitoffset = 0.0  

  

        self.executed = OrderData(remsize=self.size)  

        self.position = 0  

  

        if isinstance(self.valid, datetime.date):  

            # comparison will later be done against the raw  

datetime[0] value  

            self.valid = self.data.date2num(self.valid)  

        elif isinstance(self.valid, datetime.timedelta):  

            # offset with regards to now ... get utcnow + offset  

            # when reading with date2num ... it will be automatically  

localized  
﻿            if self.valid == self.DAY:  

                valid = datetime.datetime.combine(  

                    self.data.datetime.date(), datetime.time(23, 59,  

59, 9999))  

            else:  

                valid = self.data.datetime.datetime() + self.valid  

  

            self.valid = self.data.date2num(valid)  

  

        elif self.valid is not None:  

            if not self.valid:  # avoid comparing None and 0  

                valid = datetime.datetime.combine(  

                    self.data.datetime.date(), datetime.time(23, 59,  

59, 9999))  

            else:  # assume float  

                valid = self.data.datetime[0] + self.valid  

  

        if not self.p.simulated:  

            # provisional end-of-session  

            # get next session end  

            dtime = self.data.datetime.datetime(0)  

            session = self.data.p.sessionend  

            dteos = dtime.replace(hour=session.hour,  

minute=session.minute,  

                                  second=session.second,  

                                  microsecond=session.microsecond)  

  

            if dteos < dtime:  
﻿                # eos before current time ... no ... must be at least  

next day  

                dteos += datetime.timedelta(days=1)  

  

            self.dteos = self.data.date2num(dteos)  

        else:  

            self.dteos = 0.0  

  

    def clone(self):  

        # status, triggered and executed are the only moving parts in  

order  

        # status and triggered are covered by copy  

        # executed has to be replaced with an intelligent clone of  

itself  

        obj = copy(self)  

        obj.executed = self.executed.clone()  

        return obj  # status could change in next to completed  

  

    def getstatusname(self, status=None):  

        '''Returns the name for a given status or the one of the  

order'''  

        return self.Status[self.status if status is None else status]  

  

    def getordername(self, exectype=None):  

        '''Returns the name for a given exectype or the one of the  

order'''  

        return self.ExecTypes[self.exectype if exectype is None else  

exectype]  
﻿  

    @classmethod  

    def ExecType(cls, exectype):  

        return getattr(cls, exectype)  

  

    def ordtypename(self, ordtype=None):  

        '''Returns the name for a given ordtype or the one of the  

order'''  

        return self.OrdTypes[self.ordtype if ordtype is None else  

ordtype]  

  

    def active(self):  

        return self._active  

  

    def activate(self):  

        self._active = True  

  

    def alive(self):  

        '''Returns True if the order is in a status in which it can  

still be  

        executed  

        '''  

        return self.status in [Order.Created, Order.Submitted,  

                               Order.Partial, Order.Accepted]  

  

    def addcomminfo(self, comminfo):  

        '''Stores a CommInfo scheme associated with the asset'''  

        self.comminfo = comminfo  
﻿  

    def addinfo(self, **kwargs):  

        '''Add the keys, values of kwargs to the internal info  

dictionary to  

        hold custom information in the order  

        '''  

        for key, val in iteritems(kwargs):  

            self.info[key] = val  

  

    def __eq__(self, other):  

        return other is not None and self.ref == other.ref  

  

    def __ne__(self, other):  

        return self.ref != other.ref  

  

    def isbuy(self):  

        '''Returns True if the order is a Buy order'''  

        return self.ordtype == self.Buy  

  

    def issell(self):  

        '''Returns True if the order is a Sell order'''  

        return self.ordtype == self.Sell  

  

    def setposition(self, position):  

        '''Receives the current position for the asset and stotres  

it'''  

        self.position = position  
﻿  

    def submit(self, broker=None):  

        '''Marks an order as submitted and stores the broker to which  

it was  

        submitted'''  

        self.status = Order.Submitted  

        self.broker = broker  

        self.plen = len(self.data)  

  

    def accept(self, broker=None):  

        '''Marks an order as accepted'''  

        self.status = Order.Accepted  

        self.broker = broker  

  

    def brokerstatus(self):  

        '''Tries to retrieve the status from the broker in which the  

order is.  

  

        Defaults to last known status if no broker is associated'''  

        if self.broker:  

            return self.broker.orderstatus(self)  

  

        return self.status  

  

    def reject(self, broker=None):  

        '''Marks an order as rejected'''  

        if self.status == Order.Rejected:  
﻿            return False  

  

        self.status = Order.Rejected  

        self.broker = broker  

        if not self.p.simulated:  

            self.executed.dt = self.data.datetime[0]  

        return True  

  

    def cancel(self):  

        '''Marks an order as cancelled'''  

        self.status = Order.Canceled  

        if not self.p.simulated:  

            self.executed.dt = self.data.datetime[0]  

  

    def margin(self):  

        '''Marks an order as having met a margin call'''  

        self.status = Order.Margin  

        if not self.p.simulated:  

            self.executed.dt = self.data.datetime[0]  

  

    def completed(self):  

        '''Marks an order as completely filled'''  

        self.status = self.Completed  

  

    def partial(self):  

        '''Marks an order as partially filled'''  

        self.status = self.Partial  
﻿  

    def execute(self, dt, size, price,  

                closed, closedvalue, closedcomm,  

                opened, openedvalue, openedcomm,  

                margin, pnl,  

                psize, pprice):  

  

        '''Receives data execution input and stores it'''  

        if not size:  

            return  

  

        self.executed.add(dt, size, price,  

                          closed, closedvalue, closedcomm,  

                          opened, openedvalue, openedcomm,  

                          pnl, psize, pprice)  

  

        self.executed.margin = margin  

  

    def expire(self):  

        '''Marks an order as expired. Returns True if it worked'''  

        self.status = self.Expired  

        return True  

  

    def trailadjust(self, price):  

        pass  # generic interface  

  

  
﻿class Order(OrderBase):  

    '''  

    Class which holds creation/execution data and type of oder.  

  

    The order may have the following status:  

  

      - Submitted: sent to the broker and awaiting confirmation  

      - Accepted: accepted by the broker  

      - Partial: partially executed  

      - Completed: fully exexcuted  

      - Canceled/Cancelled: canceled by the user  

      - Expired: expired  

      - Margin: not enough cash to execute the order.  

      - Rejected: Rejected by the broker  

  

        This can happen during order submission (and therefore the  

order will  

        not reach the Accepted status) or before execution with each  

new bar  

        price because cash has been drawn by other sources (future- 

like  

        instruments may have reduced the cash or orders orders may  

have been  

        executed)  

  

    Member Attributes:  

  

      - ref: unique order identifier  
﻿      - created: OrderData holding creation data  

      - executed: OrderData holding execution data  

  

      - info: custom information passed over method :func:`addinfo`.  

It is kept  

        in the form of an OrderedDict which has been subclassed, so  

that keys  

        can also be specified using '.' notation  

  

    User Methods:  

  

      - isbuy(): returns bool indicating if the order buys  

      - issell(): returns bool indicating if the order sells  

      - alive(): returns bool if order is in status Partial or  

Accepted  

    '''  

  

    def execute(self, dt, size, price,  

                closed, closedvalue, closedcomm,  

                opened, openedvalue, openedcomm,  

                margin, pnl,  

                psize, pprice):  

  

        super(Order, self).execute(dt, size, price,  

                                   closed, closedvalue, closedcomm,  

                                   opened, openedvalue, openedcomm,  

                                   margin, pnl, psize, pprice)  

  
﻿        if self.executed.remsize:  

            self.status = Order.Partial  

        else:  

            self.status = Order.Completed  

  

        # self.comminfo = None  

  

    def expire(self):  

        if self.exectype == Order.Market:  

            return False  # will be executed yes or yes  

  

        if self.valid and self.data.datetime[0] > self.valid:  

            self.status = Order.Expired  

            self.executed.dt = self.data.datetime[0]  

            return True  

  

        return False  

  

    def trailadjust(self, price):  

        if self.trailamount:  

            pamount = self.trailamount  

        elif self.trailpercent:  

            pamount = price * self.trailpercent  

        else:  

            pamount = 0.0  

  

        # Stop sell is below (-), stop buy is above, move only if  
﻿needed  

        if self.isbuy():  

            price += pamount  

            if price < self.created.price:  

                self.created.price = price  

                if self.exectype == Order.StopTrailLimit:  

                    self.created.pricelimit = price -  

self._limitoffset  

        else:  

            price -= pamount  

            if price > self.created.price:  

                self.created.price = price  

                if self.exectype == Order.StopTrailLimit:  

                    # limitoffset is negative when pricelimit was  

greater  

                    # the - allows increasing the price limit if stop  

increases  

                    self.created.pricelimit = price -  

self._limitoffset  

  

  

class BuyOrder(Order):  

    ordtype = Order.Buy  

  

  

class StopBuyOrder(BuyOrder):  

    pass  

  
﻿  

class StopLimitBuyOrder(BuyOrder):  

    pass  

  

  

class SellOrder(Order):  

    ordtype = Order.Sell  

  

  

class StopSellOrder(SellOrder):  

    pass  

  

  

class StopLimitSellOrder(SellOrder):  

    pass  

  

  

  

##############################  

# 文件: position.txt  

##############################  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  
﻿# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

  

from copy import copy  

  

  

class Position(object):  

    '''  
﻿    Keeps and updates the size and price of a position. The object has  

no  

    relationship to any asset. It only keeps size and price.  

  

    Member Attributes:  

      - size (int): current size of the position  

      - price (float): current price of the position  

  

    The Position instances can be tested using len(position) to see if  

size  

    is not null  

    '''  

  

    def __str__(self):  

        items = list()  

        items.append('--- Position Begin')  

        items.append('- Size: {}'.format(self.size))  

        items.append('- Price: {}'.format(self.price))  

        items.append('- Price orig: {}'.format(self.price_orig))  

        items.append('- Closed: {}'.format(self.upclosed))  

        items.append('- Opened: {}'.format(self.upopened))  

        items.append('- Adjbase: {}'.format(self.adjbase))  

        items.append('--- Position End')  

        return '\n'.join(items)  

  

    def __init__(self, size=0, price=0.0):  

        self.size = size  
﻿        if size:  

            self.price = self.price_orig = price  

        else:  

            self.price = 0.0  

  

        self.adjbase = None  

  

        self.upopened = size  

        self.upclosed = 0  

        self.set(size, price)  

  

        self.updt = None  

  

    def fix(self, size, price):  

        oldsize = self.size  

        self.size = size  

        self.price = price  

        return self.size == oldsize  

  

    def set(self, size, price):  

        if self.size > 0:  

            if size > self.size:  

                self.upopened = size - self.size  # new 10 - old 5 ->  

5  

                self.upclosed = 0  

            else:  

                # same side min(0, 3) -> 0 / reversal min(0, -3) -> -3  
﻿                self.upopened = min(0, size)  

                # same side min(10, 10 - 5) -> 5  

                # reversal min(10, 10 - -5) -> min(10, 15) -> 10  

                self.upclosed = min(self.size, self.size - size)  

  

        elif self.size < 0:  

            if size < self.size:  

                self.upopened = size - self.size  # ex: -5 - -3 -> -2  

                self.upclosed = 0  

            else:  

                # same side max(0, -5) -> 0 / reversal max(0, 5) -> 5  

                self.upopened = max(0, size)  

                # same side max(-10, -10 - -5) -> max(-10, -5) -> -5  

                # reversal max(-10, -10 - 5) -> max(-10, -15) -> -10  

                self.upclosed = max(self.size, self.size - size)  

  

        else:  # self.size == 0  

            self.upopened = self.size  

            self.upclosed = 0  

  

        self.size = size  

        self.price_orig = self.price  

        if size:  

            self.price = price  

        else:  

            self.price = 0.0  

  
﻿        return self.size, self.price, self.upopened, self.upclosed  

  

    def __len__(self):  

        return abs(self.size)  

  

    def __bool__(self):  

        return bool(self.size != 0)  

  

    __nonzero__ = __bool__  

  

    def clone(self):  

        return Position(size=self.size, price=self.price)  

  

    def pseudoupdate(self, size, price):  

        return Position(self.size, self.price).update(size, price)  

  

    def update(self, size, price, dt=None):  

        '''  

        Updates the current position and returns the updated size,  

price and  

        units used to open/close a position  

  

        Args:  

            size (int): amount to update the position size  

                size < 0: A sell operation has taken place  

                size > 0: A buy operation has taken place  

  
﻿            price (float):  

                Must always be positive to ensure consistency  

  

        Returns:  

            A tuple (non-named) contaning  

               size - new position size  

                   Simply the sum of the existing size plus the "size"  

argument  

               price - new position price  

                   If a position is increased the new average price  

will be  

                   returned  

                   If a position is reduced the price of the remaining  

size  

                   does not change  

                   If a position is closed the price is nullified  

                   If a position is reversed the price is the price  

given as  

                   argument  

               opened - amount of contracts from argument "size" that  

were used  

                   to open/increase a position.  

                   A position can be opened from 0 or can be a  

reversal.  

                   If a reversal is performed then opened is less than  

"size",  

                   because part of "size" will have been used to close  

the  

                   existing position  
﻿               closed - amount of units from arguments "size" that  

were used to  

                   close/reduce a position  

  

            Both opened and closed carry the same sign as the "size"  

argument  

            because they refer to a part of the "size" argument  

        '''  

        self.datetime = dt  # record datetime update  

(datetime.datetime)  

  

        self.price_orig = self.price  

        oldsize = self.size  

        self.size += size  

  

        if not self.size:  

            # Update closed existing position  

            opened, closed = 0, size  

            self.price = 0.0  

        elif not oldsize:  

            # Update opened a position from 0  

            opened, closed = size, 0  

            self.price = price  

        elif oldsize > 0:  # existing "long" position updated  

  

            if size > 0:  # increased position  

                opened, closed = size, 0  

                self.price = (self.price * oldsize + size * price) /  
﻿self.size  

  

            elif self.size > 0:  # reduced position  

                opened, closed = 0, size  

                # self.price = self.price  

  

            else:  # self.size < 0 # reversed position form plus to  

minus  

                opened, closed = self.size, -oldsize  

                self.price = price  

  

        else:  # oldsize < 0 - existing short position updated  

  

            if size < 0:  # increased position  

                opened, closed = size, 0  

                self.price = (self.price * oldsize + size * price) /  

self.size  

  

            elif self.size < 0:  # reduced position  

                opened, closed = 0, size  

                # self.price = self.price  

  

            else:  # self.size > 0 - reversed position from minus to  

plus  

                opened, closed = self.size, -oldsize  

                self.price = price  

  

        self.upopened = opened  
﻿        self.upclosed = closed  

  

        return self.size, self.price, opened, closed  

  

  

  

##############################  

# 文件: resamplerfilter.txt  

##############################  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  
﻿# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

  

from datetime import datetime, date, timedelta  

  

from .dataseries import TimeFrame, _Bar  

from .utils.py3 import with_metaclass  

from . import metabase  

from .utils.date import date2num, num2date  

  

  

class DTFaker(object):  

    # This will only be used for data sources which at some point in  

time  

    # return None from _load to indicate that a check of the resampler  

and/or  

    # notification queue is needed  

    # This is meant (at least initially) for real-time feeds, because  

those are  

    # the ones in need of events like the ones described above.  

    # These data sources should also be producing ``utc`` time  
﻿directly because  

    # the real-time feed is (more often than not)  timestamped and utc  

provides  

    # a universal reference  

    # That's why below the timestamp is chosen in UTC and passed  

directly to  

    # date2num to avoid a localization. But it is extracted from  

data.num2date  

    # to ensure the returned datetime object is localized according to  

the  

    # expected output by the user (local timezone or any specified)  

  

    def __init__(self, data, forcedata=None):  

        self.data = data  

  

        # Aliases  

        self.datetime = self  

        self.p = self  

  

        if forcedata is None:  

            _dtime = datetime.utcnow() + data._timeoffset()  

            self._dt = dt = date2num(_dtime)  # utc-like time  

            self._dtime = data.num2date(dt)  # localized time  

        else:  

            self._dt = forcedata.datetime[0]  # utc-like time  

            self._dtime = forcedata.datetime.datetime()  # localized  

time  

  
﻿        self.sessionend = data.p.sessionend  

  

    def __len__(self):  

        return len(self.data)  

  

    def __call__(self, idx=0):  

        return self._dtime  # simulates data.datetime.datetime()  

  

    def datetime(self, idx=0):  

        return self._dtime  

  

    def date(self, idx=0):  

        return self._dtime.date()  

  

    def time(self, idx=0):  

        return self._dtime.time()  

  

    @property  

    def _calendar(self):  

        return self.data._calendar  

  

    def __getitem__(self, idx):  

        return self._dt if idx == 0 else float('-inf')  

  

    def num2date(self, *args, **kwargs):  

        return self.data.num2date(*args, **kwargs)  

  
﻿    def date2num(self, *args, **kwargs):  

        return self.data.date2num(*args, **kwargs)  

  

    def _getnexteos(self):  

        return self.data._getnexteos()  

  

  

class _BaseResampler(with_metaclass(metabase.MetaParams, object)):  

    params = (  

         ('bar2edge', True),  

         ('adjbartime', True),  

         ('rightedge', True),  

         ('boundoff', 0),  

  

         ('timeframe', TimeFrame.Days),  

         ('compression', 1),  

  

         ('takelate', True),  

  

         ('sessionend', True),  

    )  

  

    def __init__(self, data):  

        self.subdays = TimeFrame.Ticks < self.p.timeframe <  

TimeFrame.Days  

        self.subweeks = self.p.timeframe < TimeFrame.Weeks  

        self.componly = (not self.subdays and  
﻿                         data._timeframe == self.p.timeframe and  

                         not (self.p.compression % data._compression))  

  

        self.bar = _Bar(maxdate=True)  # bar holder  

        self.compcount = 0  # count of produced bars to control  

compression  

        self._firstbar = True  

        self.doadjusttime = (self.p.bar2edge and self.p.adjbartime and  

                             self.subweeks)  

  

        self._nexteos = None  

  

        # Modify data information according to own parameters  

        data.resampling = 1  

        data.replaying = self.replaying  

        data._timeframe = self.p.timeframe  

        data._compression = self.p.compression  

  

        self.data = data  

  

    def _latedata(self, data):  

        # new data at position 0, still untouched from stream  

        if not self.subdays:  

            return False  

  

        # Time already delivered  

        return len(data) > 1 and data.datetime[0] <= data.datetime[-1]  
﻿  

    def _checkbarover(self, data, fromcheck=False, forcedata=None):  

        chkdata = DTFaker(data, forcedata) if fromcheck else data  

  

        isover = False  

        if not self.componly and not self._barover(chkdata):  

            return isover  

  

        if self.subdays and self.p.bar2edge:  

            isover = True  

        elif not fromcheck:  # fromcheck doesn't increase compcount  

            self.compcount += 1  

            if not (self.compcount % self.p.compression):  

                # boundary crossed and enough bars for compression ...  

proceed  

                isover = True  

  

        return isover  

  

    def _barover(self, data):  

        tframe = self.p.timeframe  

  

        if tframe == TimeFrame.Ticks:  

            # Ticks is already the lowest level  

            return self.bar.isopen()  

  

        elif tframe < TimeFrame.Days:  
﻿            return self._barover_subdays(data)  

  

        elif tframe == TimeFrame.Days:  

            return self._barover_days(data)  

  

        elif tframe == TimeFrame.Weeks:  

            return self._barover_weeks(data)  

  

        elif tframe == TimeFrame.Months:  

            return self._barover_months(data)  

  

        elif tframe == TimeFrame.Years:  

            return self._barover_years(data)  

  

    def _eosset(self):  

        if self._nexteos is None:  

            self._nexteos, self._nextdteos = self.data._getnexteos()  

            return  

  

    def _eoscheck(self, data, seteos=True, exact=False):  

        if seteos:  

            self._eosset()  

  

        equal = data.datetime[0] == self._nextdteos  

        grter = data.datetime[0] > self._nextdteos  

  

        if exact:  
﻿            ret = equal  

        else:  

            # if the compared data goes over the endofsession  

            # make sure the resampled bar is open and has something  

before that  

            # end of session. It could be a weekend and nothing was  

delivered  

            # until Monday  

            if grter:  

                ret = (self.bar.isopen() and  

                       self.bar.datetime <= self._nextdteos)  

            else:  

                ret = equal  

  

        if ret:  

            self._lasteos = self._nexteos  

            self._lastdteos = self._nextdteos  

            self._nexteos = None  

            self._nextdteos = float('-inf')  

  

        return ret  

  

    def _barover_days(self, data):  

        return self._eoscheck(data)  

  

    def _barover_weeks(self, data):  

        if self.data._calendar is None:  
﻿            year, week, _ =  

data.num2date(self.bar.datetime).date().isocalendar()  

            yearweek = year * 100 + week  

  

            baryear, barweek, _ = data.datetime.date().isocalendar()  

            bar_yearweek = baryear * 100 + barweek  

  

            return bar_yearweek > yearweek  

        else:  

            return data._calendar.last_weekday(data.datetime.date())  

  

    def _barover_months(self, data):  

        dt = data.num2date(self.bar.datetime).date()  

        yearmonth = dt.year * 100 + dt.month  

  

        bardt = data.datetime.datetime()  

        bar_yearmonth = bardt.year * 100 + bardt.month  

  

        return bar_yearmonth > yearmonth  

  

    def _barover_years(self, data):  

        return (data.datetime.datetime().year >  

                data.num2date(self.bar.datetime).year)  

  

    def _gettmpoint(self, tm):  

        '''Returns the point of time intraday for a given time  

according to the  
﻿        timeframe  

  

          - Ex 1: 00:05:00 in minutes -> point = 5  

          - Ex 2: 00:05:20 in seconds -> point = 5 * 60 + 20 = 320  

        '''  

        point = tm.hour * 60 + tm.minute  

        restpoint = 0  

  

        if self.p.timeframe < TimeFrame.Minutes:  

            point = point * 60 + tm.second  

  

            if self.p.timeframe < TimeFrame.Seconds:  

                point = point * 1e6 + tm.microsecond  

            else:  

                restpoint = tm.microsecond  

        else:  

            restpoint = tm.second + tm.microsecond  

  

        point += self.p.boundoff  

  

        return point, restpoint  

  

    def _barover_subdays(self, data):  

        if self._eoscheck(data):  

            return True  

  

        if data.datetime[0] < self.bar.datetime:  
﻿            return False  

  

        # Get time objects for the comparisons - in utc-like format  

        tm = num2date(self.bar.datetime).time()  

        bartm = num2date(data.datetime[0]).time()  

  

        point, _ = self._gettmpoint(tm)  

        barpoint, _ = self._gettmpoint(bartm)  

  

        ret = False  

        if barpoint > point:  

            # The data bar has surpassed the internal bar  

            if not self.p.bar2edge:  

                # Compression done on simple bar basis (like days)  

                ret = True  

            elif self.p.compression == 1:  

                # no bar compression requested -> internal bar done  

                ret = True  

            else:  

                point_comp = point // self.p.compression  

                barpoint_comp = barpoint // self.p.compression  

  

                # Went over boundary including compression  

                if barpoint_comp > point_comp:  

                    ret = True  

  

        return ret  
﻿  

    def check(self, data, _forcedata=None):  

        '''Called to check if the current stored bar has to be  

delivered in  

        spite of the data not having moved forward. If no ticks from a  

live  

        feed come in, a 5 second resampled bar could be delivered 20  

seconds  

        later. When this method is called the wall clock (incl data  

time  

        offset) is called to check if the time has gone so far as to  

have to  

        deliver the already stored data  

        '''  

        if not self.bar.isopen():  

            return  

  

        return self(data, fromcheck=True, forcedata=_forcedata)  

  

    def _dataonedge(self, data):  

        if not self.subweeks:  

            if data._calendar is None:  

                return False, True  # nothing can be done  

  

            tframe = self.p.timeframe  

            ret = False  

            if tframe == TimeFrame.Weeks:  # Ticks is already the  

lowest  
﻿                ret =  

data._calendar.last_weekday(data.datetime.date())  

            elif tframe == TimeFrame.Months:  

                ret =  

data._calendar.last_monthday(data.datetime.date())  

            elif tframe == TimeFrame.Years:  

                ret =  

data._calendar.last_yearday(data.datetime.date())  

  

            if ret:  

                # Data must be consumed but compression may not be met  

yet  

                # Prevent barcheckover from being called because it  

could again  

                # increase compcount  

                docheckover = False  

                self.compcount += 1  

                ret = not (self.compcount % self.p.compression)  

            else:  

                docheckover = True  

  

            return ret, docheckover  

  

        if self._eoscheck(data, exact=True):  

            return True, True  

  

        if self.subdays:  

            point, prest = self._gettmpoint(data.datetime.time())  
﻿            if prest:  

                return False, True  # cannot be on boundary, subunits  

present  

  

            # Pass through compression to get boundary and rest over  

boundary  

            bound, brest = divmod(point, self.p.compression)  

  

            # if no extra and decomp bound is point  

            return (brest == 0 and point == (bound *  

self.p.compression), True)  

  

        # Code overriden by eoscheck  

        if False and self.p.sessionend:  

            # Days scenario - get datetime to compare in output  

timezone  

            # because p.sessionend is expected in output timezone  

            bdtime = data.datetime.datetime()  

            bsend = datetime.combine(bdtime.date(), data.p.sessionend)  

            return bdtime == bsend  

  

        return False, True  # subweeks, not subdays and not sessionend  

  

    def _calcadjtime(self, greater=False):  

        if self._nexteos is None:  

            # Session has been exceeded - end of session is the mark  

            return self._lastdteos  # utc-like  

  
﻿        dt = self.data.num2date(self.bar.datetime)  

  

        # Get current time  

        tm = dt.time()  

        # Get the point of the day in the time frame unit (ex: minute  

200)  

        point, _ = self._gettmpoint(tm)  

  

        # Apply compression to update the point position (comp 5 ->  

200 // 5)  

        # point = (point // self.p.compression)  

        point = point // self.p.compression  

  

        # If rightedge (end of boundary is activated) add it unless  

recursing  

        point += self.p.rightedge  

  

        # Restore point to the timeframe units by de-applying  

compression  

        point *= self.p.compression  

  

        # Get hours, minutes, seconds and microseconds  

        extradays = 0  

        if self.p.timeframe == TimeFrame.Minutes:  

            ph, pm = divmod(point, 60)  

            ps = 0  

            pus = 0  

        elif self.p.timeframe == TimeFrame.Seconds:  
﻿            ph, pm = divmod(point, 60 * 60)  

            pm, ps = divmod(pm, 60)  

            pus = 0  

        elif self.p.timeframe <= TimeFrame.MicroSeconds:  

            ph, pm = divmod(point, 60 * 60 * 1e6)  

            pm, psec = divmod(pm, 60 * 1e6)  

            ps, pus = divmod(psec, 1e6)  

        elif self.p.timeframe == TimeFrame.Days:  

            # last resort  

            eost = self._nexteos.time()  

            ph = eost.hour  

            pm = eost.minute  

            ps = eost.second  

            pus = eost.microsecond  

  

        if ph > 23:  # went over midnight:  

            extradays = ph // 24  

            ph %= 24  

  

        # Replace intraday parts with the calculated ones and update  

it  

        dt = dt.replace(hour=int(ph), minute=int(pm),  

                        second=int(ps), microsecond=int(pus))  

        if extradays:  

            dt += timedelta(days=extradays)  

        dtnum = self.data.date2num(dt)  

        return dtnum  
﻿  

    def _adjusttime(self, greater=False, forcedata=None):  

        '''  

        Adjusts the time of calculated bar (from underlying data  

source) by  

        using the timeframe to the appropriate boundary, with  

compression taken  

        into account  

  

        Depending on param ``rightedge`` uses the starting boundary or  

the  

        ending one  

        '''  

        dtnum = self._calcadjtime(greater=greater)  

        if greater and dtnum <= self.bar.datetime:  

            return False  

  

        self.bar.datetime = dtnum  

        return True  

  

  

class Resampler(_BaseResampler):  

    '''This class resamples data of a given timeframe to a larger  

timeframe.  

  

    Params  

  

      - bar2edge (default: True)  
﻿  

        resamples using time boundaries as the target. For example  

with a  

        "ticks -> 5 seconds" the resulting 5 seconds bars will be  

aligned to  

        xx:00, xx:05, xx:10 ...  

  

      - adjbartime (default: True)  

  

        Use the time at the boundary to adjust the time of the  

delivered  

        resampled bar instead of the last seen timestamp. If  

resampling to "5  

        seconds" the time of the bar will be adjusted for example to  

hh:mm:05  

        even if the last seen timestamp was hh:mm:04.33  

  

        .. note::  

  

           Time will only be adjusted if "bar2edge" is True. It  

wouldn't make  

           sense to adjust the time if the bar has not been aligned to  

a  

           boundary  

  

      - rightedge (default: True)  

  

        Use the right edge of the time boundaries to set the time.  

  
﻿        If False and compressing to 5 seconds the time of a resampled  

bar for  

        seconds between hh:mm:00 and hh:mm:04 will be hh:mm:00 (the  

starting  

        boundary  

  

        If True the used boundary for the time will be hh:mm:05 (the  

ending  

        boundary)  

    '''  

    params = (  

         ('bar2edge', True),  

         ('adjbartime', True),  

         ('rightedge', True),  

    )  

  

    replaying = False  

  

    def last(self, data):  

        '''Called when the data is no longer producing bars  

  

        Can be called multiple times. It has the chance to (for  

example)  

        produce extra bars which may still be accumulated and have to  

be  

        delivered  

        '''  

        if self.bar.isopen():  
﻿            if self.doadjusttime:  

                self._adjusttime()  

  

            data._add2stack(self.bar.lvalues())  

            self.bar.bstart(maxdate=True)  # close the bar to avoid  

dups  

            return True  

  

        return False  

  

    def __call__(self, data, fromcheck=False, forcedata=None):  

        '''Called for each set of values produced by the data  

source'''  

        consumed = False  

        onedge = False  

        docheckover = True  

        if not fromcheck:  

            if self._latedata(data):  

                if not self.p.takelate:  

                    data.backwards()  

                    return True  # get a new bar  

  

                self.bar.bupdate(data)  # update new or existing bar  

                # push time beyond reference  

                self.bar.datetime = data.datetime[-1] + 0.000001  

                data.backwards()  # remove used bar  

                return True  
﻿  

            if self.componly:  # only if not subdays  

                # Get a session ref before rewinding  

                _, self._lastdteos = self.data._getnexteos()  

                consumed = True  

  

            else:  

                onedge, docheckover = self._dataonedge(data)  # for  

subdays  

                consumed = onedge  

  

        if consumed:  

            self.bar.bupdate(data)  # update new or existing bar  

            data.backwards()  # remove used bar  

  

        # if self.bar.isopen and (onedge or (docheckover and  

checkbarover))  

        cond = self.bar.isopen()  

        if cond:  # original is and, the 2nd term must also be true  

            if not onedge:  # onedge true is sufficient  

                if docheckover:  

                    cond = self._checkbarover(data,  

fromcheck=fromcheck,  

                                              forcedata=forcedata)  

        if cond:  

            dodeliver = False  

            if forcedata is not None:  

                # check our delivery time is not larger than that of  
﻿forcedata  

                tframe = self.p.timeframe  

                if tframe == TimeFrame.Ticks:  # Ticks is already the  

lowest  

                    dodeliver = True  

                elif tframe == TimeFrame.Minutes:  

                    dtnum = self._calcadjtime(greater=True)  

                    dodeliver = dtnum <= forcedata.datetime[0]  

                elif tframe == TimeFrame.Days:  

                    dtnum = self._calcadjtime(greater=True)  

                    dodeliver = dtnum <= forcedata.datetime[0]  

            else:  

                dodeliver = True  

  

            if dodeliver:  

                if not onedge and self.doadjusttime:  

                    self._adjusttime(greater=True,  

forcedata=forcedata)  

  

                data._add2stack(self.bar.lvalues())  

                self.bar.bstart(maxdate=True)  # bar delivered ->  

restart  

  

        if not fromcheck:  

            if not consumed:  

                self.bar.bupdate(data)  # update new or existing bar  

                data.backwards()  # remove used bar  

  
﻿        return True  

  

  

class Replayer(_BaseResampler):  

    '''This class replays data of a given timeframe to a larger  

timeframe.  

  

    It simulates the action of the market by slowly building up (for  

ex.) a  

    daily bar from tick/seconds/minutes data  

  

    Only when the bar is complete will the "length" of the data be  

changed  

    effectively delivering a closed bar  

  

    Params  

  

      - bar2edge (default: True)  

  

        replays using time boundaries as the target of the closed bar.  

For  

        example with a "ticks -> 5 seconds" the resulting 5 seconds  

bars will  

        be aligned to xx:00, xx:05, xx:10 ...  

  

      - adjbartime (default: False)  

  

        Use the time at the boundary to adjust the time of the  
﻿delivered  

        resampled bar instead of the last seen timestamp. If  

resampling to "5  

        seconds" the time of the bar will be adjusted for example to  

hh:mm:05  

        even if the last seen timestamp was hh:mm:04.33  

  

        .. note::  

  

           Time will only be adjusted if "bar2edge" is True. It  

wouldn't make  

           sense to adjust the time if the bar has not been aligned to  

a  

           boundary  

  

        .. note:: if this parameter is True an extra tick with the  

*adjusted*  

                  time will be introduced at the end of the *replayed*  

bar  

  

      - rightedge (default: True)  

  

        Use the right edge of the time boundaries to set the time.  

  

        If False and compressing to 5 seconds the time of a resampled  

bar for  

        seconds between hh:mm:00 and hh:mm:04 will be hh:mm:00 (the  

starting  

        boundary  
﻿  

        If True the used boundary for the time will be hh:mm:05 (the  

ending  

        boundary)  

    '''  

    params = (  

         ('bar2edge', True),  

         ('adjbartime', False),  

         ('rightedge', True),  

    )  

  

    replaying = True  

  

    def __call__(self, data, fromcheck=False, forcedata=None):  

        consumed = False  

        onedge = False  

        takinglate = False  

        docheckover = True  

  

        if not fromcheck:  

            if self._latedata(data):  

                if not self.p.takelate:  

                    data.backwards(force=True)  

                    return True  # get a new bar  

  

                consumed = True  

                takinglate = True  
﻿  

            elif self.componly:  # only if not subdays  

                consumed = True  

  

            else:  

                onedge, docheckover = self._dataonedge(data)  # for  

subdays  

                consumed = onedge  

  

            data._tick_fill(force=True)  # update  

  

        if consumed:  

            self.bar.bupdate(data)  

            if takinglate:  

                self.bar.datetime = data.datetime[-1] + 0.000001  

  

        # if onedge or (checkbarover and self._checkbarover)  

        cond = onedge  

        if not cond:  # original is or, if true it would suffice  

            if docheckover:  

                cond = self._checkbarover(data, fromcheck=fromcheck)  

        if cond:  

            if not onedge and self.doadjusttime:  # insert tick with  

adjtime  

                adjusted = self._adjusttime(greater=True)  

                if adjusted:  

                    ago = 0 if (consumed or fromcheck) else -1  
﻿                    # Update to the point right before the new data  

                    data._updatebar(self.bar.lvalues(), forward=False,  

ago=ago)  

  

                if not fromcheck:  

                    if not consumed:  

                        # Reopen bar with real new data and save data  

to queue  

                        self.bar.bupdate(data, reopen=True)  

                        # erase is True, but the tick will not be seen  

below  

                        # and therefore no need to mark as 1st  

                        data._save2stack(erase=True, force=True)  

                    else:  

                        self.bar.bstart(maxdate=True)  

                        self._firstbar = True  # next is first  

                else:  # from check  

                    # fromcheck or consumed have  forced delivery,  

reopen  

                    self.bar.bstart(maxdate=True)  

                    self._firstbar = True  # next is first  

                    if adjusted:  

                        # after adjusting need to redeliver if this  

was a check  

                        data._save2stack(erase=True, force=True)  

  

            elif not fromcheck:  

                if not consumed:  
﻿                    # Data already "forwarded" and we replay to new  

bar  

                    # No need to go backwards. simply reopen internal  

cache  

                    self.bar.bupdate(data, reopen=True)  

                else:  

                    # compression only, used data to update bar, hence  

remove  

                    # from stream, update existing data, reopen bar  

                    if not self._firstbar:  # only discard data if not  

firstbar  

                        data.backwards(force=True)  

                    data._updatebar(self.bar.lvalues(), forward=False,  

ago=0)  

                    self.bar.bstart(maxdate=True)  

                    self._firstbar = True  # make sure next tick moves  

forward  

  

        elif not fromcheck:  

            # not over, update, remove new entry, deliver  

            if not consumed:  

                self.bar.bupdate(data)  

  

            if not self._firstbar:  # only discard data if not  

firstbar  

                data.backwards(force=True)  

  

            data._updatebar(self.bar.lvalues(), forward=False, ago=0)  

            self._firstbar = False  
﻿  

        return False  # the existing bar can be processed by the  

system  

  

  

class ResamplerTicks(Resampler):  

    params = (('timeframe', TimeFrame.Ticks),)  

  

  

class ResamplerSeconds(Resampler):  

    params = (('timeframe', TimeFrame.Seconds),)  

  

  

class ResamplerMinutes(Resampler):  

    params = (('timeframe', TimeFrame.Minutes),)  

  

  

class ResamplerDaily(Resampler):  

    params = (('timeframe', TimeFrame.Days),)  

  

  

class ResamplerWeekly(Resampler):  

    params = (('timeframe', TimeFrame.Weeks),)  

  

  

class ResamplerMonthly(Resampler):  

    params = (('timeframe', TimeFrame.Months),)  
﻿  

  

class ResamplerYearly(Resampler):  

    params = (('timeframe', TimeFrame.Years),)  

  

  

class ReplayerTicks(Replayer):  

    params = (('timeframe', TimeFrame.Ticks),)  

  

  

class ReplayerSeconds(Replayer):  

    params = (('timeframe', TimeFrame.Seconds),)  

  

  

class ReplayerMinutes(Replayer):  

    params = (('timeframe', TimeFrame.Minutes),)  

  

  

class ReplayerDaily(Replayer):  

    params = (('timeframe', TimeFrame.Days),)  

  

  

class ReplayerWeekly(Replayer):  

    params = (('timeframe', TimeFrame.Weeks),)  

  

  

class ReplayerMonthly(Replayer):  
﻿    params = (('timeframe', TimeFrame.Months),)  

  

  

  

##############################  

# 文件: signal.txt  

##############################  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  
﻿<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import backtrader as bt  

  

 (  

  

    SIGNAL_NONE,  

    SIGNAL_LONGSHORT,  

    SIGNAL_LONG,  

    SIGNAL_LONG_INV,  

    SIGNAL_LONG_ANY,  

    SIGNAL_SHORT,  

    SIGNAL_SHORT_INV,  

    SIGNAL_SHORT_ANY,  

    SIGNAL_LONGEXIT,  

    SIGNAL_LONGEXIT_INV,  

    SIGNAL_LONGEXIT_ANY,  

    SIGNAL_SHORTEXIT,  

    SIGNAL_SHORTEXIT_INV,  

    SIGNAL_SHORTEXIT_ANY,  

  

) = range(14)  
﻿  

  

SignalTypes = [  

    SIGNAL_NONE,  

    SIGNAL_LONGSHORT,  

    SIGNAL_LONG, SIGNAL_LONG_INV, SIGNAL_LONG_ANY,  

    SIGNAL_SHORT, SIGNAL_SHORT_INV, SIGNAL_SHORT_ANY,  

    SIGNAL_LONGEXIT, SIGNAL_LONGEXIT_INV, SIGNAL_LONGEXIT_ANY,  

    SIGNAL_SHORTEXIT, SIGNAL_SHORTEXIT_INV, SIGNAL_SHORTEXIT_ANY  

]  

  

  

class Signal(bt.Indicator):  

    SignalTypes = SignalTypes  

  

    lines = ('signal',)  

  

    def __init__(self):  

        self.lines.signal = self.data0.lines[0]  

        self.plotinfo.plotmaster = getattr(self.data0, '_clock',  

self.data0)  

  

  

  

##############################  

# 文件: sizer.txt  

##############################  
﻿  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

from .utils.py3 import with_metaclass  
﻿  

from .metabase import MetaParams  

  

  

class Sizer(with_metaclass(MetaParams, object)):  

    '''This is the base class for *Sizers*. Any *sizer* should  

subclass this  

    and override the ``_getsizing`` method  

  

    Member Attribs:  

  

      - ``strategy``: will be set by the strategy in which the sizer  

is working  

  

        Gives access to the entire api of the strategy, for example if  

the  

        actual data position would be needed in ``_getsizing``::  

  

           position = self.strategy.getposition(data)  

  

      - ``broker``: will be set by the strategy in which the sizer is  

working  

  

        Gives access to information some complex sizers may need like  

portfolio  

        value, ..  

    '''  

    strategy = None  
﻿    broker = None  

  

    def getsizing(self, data, isbuy):  

        comminfo = self.broker.getcommissioninfo(data)  

        return self._getsizing(comminfo, self.broker.getcash(), data,  

isbuy)  

  

    def _getsizing(self, comminfo, cash, data, isbuy):  

        '''This method has to be overriden by subclasses of Sizer to  

provide  

        the sizing functionality  

  

        Params:  

          - ``comminfo``: The CommissionInfo instance that contains  

            information about the commission for the data and allows  

            calculation of position value, operation cost, commision  

for the  

            operation  

  

          - ``cash``: current available cash in the *broker*  

  

          - ``data``: target of the operation  

  

          - ``isbuy``: will be ``True`` for *buy* operations and  

``False``  

            for *sell* operations  

  

        The method has to return the actual size (an int) to be  
﻿executed. If  

        ``0`` is returned nothing will be executed.  

  

        The absolute value of the returned value will be used  

  

        '''  

        raise NotImplementedError  

  

    def set(self, strategy, broker):  

        self.strategy = strategy  

        self.broker = broker  

  

  

SizerBase = Sizer  # alias for old naming  

  

  

  

##############################  

# 文件: store.txt  

##############################  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  
﻿#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import collections  

  

from backtrader.metabase import MetaParams  

from backtrader.utils.py3 import with_metaclass  

  

  

class MetaSingleton(MetaParams):  
﻿    '''Metaclass to make a metaclassed class a singleton'''  

    def __init__(cls, name, bases, dct):  

        super(MetaSingleton, cls).__init__(name, bases, dct)  

        cls._singleton = None  

  

    def __call__(cls, *args, **kwargs):  

        if cls._singleton is None:  

            cls._singleton = (  

                super(MetaSingleton, cls).__call__(*args, **kwargs))  

  

        return cls._singleton  

  

  

class Store(with_metaclass(MetaSingleton, object)):  

    '''Base class for all Stores'''  

  

    _started = False  

  

    params = ()  

  

    def getdata(self, *args, **kwargs):  

        '''Returns ``DataCls`` with args, kwargs'''  

        data = self.DataCls(*args, **kwargs)  

        data._store = self  

        return data  

  

    @classmethod  
﻿    def getbroker(cls, *args, **kwargs):  

        '''Returns broker with *args, **kwargs from registered  

``BrokerCls``'''  

        broker = cls.BrokerCls(*args, **kwargs)  

        broker._store = cls  

        return broker  

  

    BrokerCls = None  # broker class will autoregister  

    DataCls = None  # data class will auto register  

  

    def start(self, data=None, broker=None):  

        if not self._started:  

            self._started = True  

            self.notifs = collections.deque()  

            self.datas = list()  

            self.broker = None  

  

        if data is not None:  

            self._cerebro = self._env = data._env  

            self.datas.append(data)  

  

            if self.broker is not None:  

                if hasattr(self.broker, 'data_started'):  

                    self.broker.data_started(data)  

  

        elif broker is not None:  

            self.broker = broker  
﻿  

    def stop(self):  

        pass  

  

    def put_notification(self, msg, *args, **kwargs):  

        self.notifs.append((msg, args, kwargs))  

  

    def get_notifications(self):  

        '''Return the pending "store" notifications'''  

        self.notifs.append(None)  # put a mark / threads could still  

append  

        return [x for x in iter(self.notifs.popleft, None)]  

  

  

  

##############################  

# 文件: strategy.txt  

##############################  

  

#!/usr/bin389/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  
﻿# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import collections  

import copy  

import datetime  

import inspect  

import itertools  

import operator  

  

from .utils.py3 import (filter, keys, integer_types, iteritems,  

itervalues,  

                        map, MAXINT, string_types, with_metaclass)  
﻿  

import backtrader as bt  

from .lineiterator import LineIterator, StrategyBase  

from .lineroot import LineSingle  

from .lineseries import LineSeriesStub  

from .metabase import ItemCollection, findowner  

from .trade import Trade  

from .utils import OrderedDict, AutoOrderedDict, AutoDictList  

  

  

class MetaStrategy(StrategyBase.__class__):  

    _indcol = dict()  

  

    def __new__(meta, name, bases, dct):  

        # Hack to support original method name for notify_order  

        if 'notify' in dct:  

            # rename 'notify' to 'notify_order'  

            dct['notify_order'] = dct.pop('notify')  

        if 'notify_operation' in dct:  

            # rename 'notify' to 'notify_order'  

            dct['notify_trade'] = dct.pop('notify_operation')  

  

        return super(MetaStrategy, meta).__new__(meta, name, bases,  

dct)  

  

    def __init__(cls, name, bases, dct):  

        '''  
﻿        Class has already been created ... register subclasses  

        '''  

        # Initialize the class  

        super(MetaStrategy, cls).__init__(name, bases, dct)  

  

        if not cls.aliased and \  

           name != 'Strategy' and not name.startswith('_'):  

            cls._indcol[name] = cls  

  

    def donew(cls, *args, **kwargs):  

        _obj, args, kwargs = super(MetaStrategy, cls).donew(*args,  

**kwargs)  

  

        # Find the owner and store it  

        _obj.env = _obj.cerebro = cerebro = findowner(_obj,  

bt.Cerebro)  

        _obj._id = cerebro._next_stid()  

  

        return _obj, args, kwargs  

  

    def dopreinit(cls, _obj, *args, **kwargs):  

        _obj, args, kwargs = \  

            super(MetaStrategy, cls).dopreinit(_obj, *args, **kwargs)  

        _obj.broker = _obj.env.broker  

        _obj._sizer = bt.sizers.FixedSize()  

        _obj._orders = list()  

        _obj._orderspending = list()  
﻿        _obj._trades = collections.defaultdict(AutoDictList)  

        _obj._tradespending = list()  

  

        _obj.stats = _obj.observers = ItemCollection()  

        _obj.analyzers = ItemCollection()  

        _obj._alnames = collections.defaultdict(itertools.count)  

        _obj.writers = list()  

  

        _obj._slave_analyzers = list()  

  

        _obj._tradehistoryon = False  

  

        return _obj, args, kwargs  

  

    def dopostinit(cls, _obj, *args, **kwargs):  

        _obj, args, kwargs = \  

            super(MetaStrategy, cls).dopostinit(_obj, *args, **kwargs)  

  

        _obj._sizer.set(_obj, _obj.broker)  

  

        return _obj, args, kwargs  

  

  

class Strategy(with_metaclass(MetaStrategy, StrategyBase)):  

    '''  

    Base class to be subclassed for user defined strategies.  

    '''  
﻿  

    _ltype = LineIterator.StratType  

  

    csv = True  

    _oldsync = False  # update clock using old methodology : data 0  

  

    # keep the latest delivered data date in the line  

    lines = ('datetime',)  

  

    def qbuffer(self, savemem=0, replaying=False):  

        '''Enable the memory saving schemes. Possible values for  

``savemem``:  

  

          0: No savings. Each lines object keeps in memory all values  

  

          1: All lines objects save memory, using the strictly minimum  

needed  

  

        Negative values are meant to be used when plotting is  

required:  

  

          -1: Indicators at Strategy Level and Observers do not enable  

memory  

              savings (but anything declared below it does)  

  

          -2: Same as -1 plus activation of memory saving for any  

indicators  

              which has declared *plotinfo.plot* as False (will not be  
﻿plotted)  

        '''  

        if savemem < 0:  

            # Get any attribute which labels itself as Indicator  

            for ind in self._lineiterators[self.IndType]:  

                subsave = isinstance(ind, (LineSingle,))  

                if not subsave and savemem < -1:  

                    subsave = not ind.plotinfo.plot  

                ind.qbuffer(savemem=subsave)  

  

        elif savemem > 0:  

            for data in self.datas:  

                data.qbuffer(replaying=replaying)  

  

            for line in self.lines:  

                line.qbuffer(savemem=1)  

  

            # Save in all object types depending on the strategy  

            for itcls in self._lineiterators:  

                for it in self._lineiterators[itcls]:  

                    it.qbuffer(savemem=1)  

  

    def _periodset(self):  

        dataids = [id(data) for data in self.datas]  

  

        _dminperiods = collections.defaultdict(list)  

        for lineiter in self._lineiterators[LineIterator.IndType]:  
﻿            # if multiple datas are used and multiple timeframes the  

larger  

            # timeframe may place larger time constraints in calling  

next.  

            clk = getattr(lineiter, '_clock', None)  

            if clk is None:  

                clk = getattr(lineiter._owner, '_clock', None)  

                if clk is None:  

                    continue  

  

            while True:  

                if id(clk) in dataids:  

                    break  # already top-level clock (data feed)  

  

                # See if the current clock has higher level clocks  

                clk2 = getattr(clk, '_clock', None)  

                if clk2 is None:  

                    clk2 = getattr(clk._owner, '_clock', None)  

  

                if clk2 is None:  

                    break  # if no clock found, bail out  

  

                clk = clk2  # keep the ref and try to go up the  

hierarchy  

  

            if clk is None:  

                continue  # no clock found, go to next  

  
﻿            # LineSeriesStup wraps a line and the clock is the wrapped  

line and  

            # no the wrapper itself.  

            if isinstance(clk, LineSeriesStub):  

                clk = clk.lines[0]  

  

            _dminperiods[clk].append(lineiter._minperiod)  

  

        self._minperiods = list()  

        for data in self.datas:  

  

            # Do not only consider the data as clock but also its  

lines which  

            # may have been individually passed as clock references  

and  

            # discovered as clocks above  

  

            # Initialize with data min period if any  

            dlminperiods = _dminperiods[data]  

  

            for l in data.lines:  # search each line for min periods  

                if l in _dminperiods:  

                    dlminperiods += _dminperiods[l]  # found, add it  

  

            # keep the reference to the line if any was found  

            _dminperiods[data] = [max(dlminperiods)] if dlminperiods  

else []  

  
﻿            dminperiod = max(_dminperiods[data] or [data._minperiod])  

            self._minperiods.append(dminperiod)  

  

        # Set the minperiod  

        minperiods = \  

             [x._minperiod for x in  

self._lineiterators[LineIterator.IndType]]  

        self._minperiod = max(minperiods or [self._minperiod])  

  

    def _addwriter(self, writer):  

        '''  

        Unlike the other _addxxx functions this one receives an  

instance  

        because the writer works at cerebro level and is only passed  

to the  

        strategy to simplify the logic  

        '''  

        self.writers.append(writer)  

  

    def _addindicator(self, indcls, *indargs, **indkwargs):  

        indcls(*indargs, **indkwargs)  

  

    def _addanalyzer_slave(self, ancls, *anargs, **ankwargs):  

        '''Like _addanalyzer but meant for observers (or other  

entities) which  

        rely on the output of an analyzer for the data. These  

analyzers have  

        not been added by the user and are kept separate from the main  
﻿        analyzers  

  

        Returns the created analyzer  

        '''  

        analyzer = ancls(*anargs, **ankwargs)  

        self._slave_analyzers.append(analyzer)  

        return analyzer  

  

    def _getanalyzer_slave(self, idx):  

        return self._slave_analyzers.append[idx]  

  

    def _addanalyzer(self, ancls, *anargs, **ankwargs):  

        anname = ankwargs.pop('_name', '') or ancls.__name__.lower()  

        nsuffix = next(self._alnames[anname])  

        anname += str(nsuffix or '')  # 0 (first instance) gets no  

suffix  

        analyzer = ancls(*anargs, **ankwargs)  

        self.analyzers.append(analyzer, anname)  

  

    def _addobserver(self, multi, obscls, *obsargs, **obskwargs):  

        obsname = obskwargs.pop('obsname', '')  

        if not obsname:  

            obsname = obscls.__name__.lower()  

  

        if not multi:  

            newargs = list(itertools.chain(self.datas, obsargs))  

            obs = obscls(*newargs, **obskwargs)  
﻿            self.stats.append(obs, obsname)  

            return  

  

        setattr(self.stats, obsname, list())  

        l = getattr(self.stats, obsname)  

  

        for data in self.datas:  

            obs = obscls(data, *obsargs, **obskwargs)  

            l.append(obs)  

  

    def _getminperstatus(self):  

        # check the min period status connected to datas  

        dlens = map(operator.sub, self._minperiods, map(len,  

self.datas))  

        self._minperstatus = minperstatus = max(dlens)  

        return minperstatus  

  

    def prenext_open(self):  

        pass  

  

    def nextstart_open(self):  

        self.next_open()  

  

    def next_open(self):  

        pass  

  

    def _oncepost_open(self):  
﻿        minperstatus = self._minperstatus  

        if minperstatus < 0:  

            self.next_open()  

        elif minperstatus == 0:  

            self.nextstart_open()  # only called for the 1st value  

        else:  

            self.prenext_open()  

  

    def _oncepost(self, dt):  

        for indicator in self._lineiterators[LineIterator.IndType]:  

            if len(indicator._clock) > len(indicator):  

                indicator.advance()  

  

        if self._oldsync:  

            # Strategy has not been reset, the line is there  

            self.advance()  

        else:  

            # strategy has been reset to beginning. advance step by  

step  

            self.forward()  

  

        self.lines.datetime[0] = dt  

        self._notify()  

  

        minperstatus = self._getminperstatus()  

        if minperstatus < 0:  

            self.next()  
﻿        elif minperstatus == 0:  

            self.nextstart()  # only called for the 1st value  

        else:  

            self.prenext()  

  

        self._next_analyzers(minperstatus, once=True)  

        self._next_observers(minperstatus, once=True)  

  

        self.clear()  

  

    def _clk_update(self):  

        if self._oldsync:  

            clk_len = super(Strategy, self)._clk_update()  

            self.lines.datetime[0] = max(d.datetime[0]  

                                         for d in self.datas if  

len(d))  

            return clk_len  

  

        newdlens = [len(d) for d in self.datas]  

        if any(nl > l for l, nl in zip(self._dlens, newdlens)):  

            self.forward()  

  

        self.lines.datetime[0] = max(d.datetime[0]  

                                     for d in self.datas if len(d))  

        self._dlens = newdlens  

  

        return len(self)  
﻿  

    def _next_open(self):  

        minperstatus = self._minperstatus  

        if minperstatus < 0:  

            self.next_open()  

        elif minperstatus == 0:  

            self.nextstart_open()  # only called for the 1st value  

        else:  

            self.prenext_open()  

  

    def _next(self):  

        super(Strategy, self)._next()  

  

        minperstatus = self._getminperstatus()  

        self._next_analyzers(minperstatus)  

        self._next_observers(minperstatus)  

  

        self.clear()  

  

    def _next_observers(self, minperstatus, once=False):  

        for observer in self._lineiterators[LineIterator.ObsType]:  

            for analyzer in observer._analyzers:  

                if minperstatus < 0:  

                    analyzer._next()  

                elif minperstatus == 0:  

                    analyzer._nextstart()  # only called for the 1st  

value  
﻿                else:  

                    analyzer._prenext()  

  

            if once:  

                if len(self) > len(observer):  

                    if self._oldsync:  

                        observer.advance()  

                    else:  

                        observer.forward()  

  

                if minperstatus < 0:  

                    observer.next()  

                elif minperstatus == 0:  

                    observer.nextstart()  # only called for the 1st  

value  

                elif len(observer):  

                    observer.prenext()  

            else:  

                observer._next()  

  

    def _next_analyzers(self, minperstatus, once=False):  

        for analyzer in self.analyzers:  

            if minperstatus < 0:  

                analyzer._next()  

            elif minperstatus == 0:  

                analyzer._nextstart()  # only called for the 1st value  

            else:  
﻿                analyzer._prenext()  

  

    def _settz(self, tz):  

        self.lines.datetime._settz(tz)  

  

    def _start(self):  

        self._periodset()  

  

        for analyzer in itertools.chain(self.analyzers,  

self._slave_analyzers):  

            analyzer._start()  

  

        for obs in self.observers:  

            if not isinstance(obs, list):  

                obs = [obs]  # support of multi-data observers  

  

            for o in obs:  

                o._start()  

  

        # change operators to stage 2  

        self._stage2()  

  

        self._dlens = [len(data) for data in self.datas]  

  

        self._minperstatus = MAXINT  # start in prenext  

  

        self.start()  
﻿  

    def start(self):  

        '''Called right before the backtesting is about to be  

started.'''  

        pass  

  

    def getwriterheaders(self):  

        self.indobscsv = [self]  

  

        indobs = itertools.chain(  

            self.getindicators_lines(), self.getobservers())  

        self.indobscsv.extend(filter(lambda x: x.csv, indobs))  

  

        headers = list()  

  

        # prepare the indicators/observers data headers  

        for iocsv in self.indobscsv:  

            name = iocsv.plotinfo.plotname or iocsv.__class__.__name__  

            headers.append(name)  

            headers.append('len')  

            headers.extend(iocsv.getlinealiases())  

  

        return headers  

  

    def getwritervalues(self):  

        values = list()  

  
﻿        for iocsv in self.indobscsv:  

            name = iocsv.plotinfo.plotname or iocsv.__class__.__name__  

            values.append(name)  

            lio = len(iocsv)  

            values.append(lio)  

            if lio:  

                values.extend(map(lambda l: l[0],  

iocsv.lines.itersize()))  

            else:  

                values.extend([''] * iocsv.lines.size())  

  

        return values  

  

    def getwriterinfo(self):  

        wrinfo = AutoOrderedDict()  

  

        wrinfo['Params'] = self.p._getkwargs()  

  

        sections = [  

             ['Indicators', self.getindicators_lines()],  

             ['Observers', self.getobservers()]  

        ]  

  

        for sectname, sectitems in sections:  

            sinfo = wrinfo[sectname]  

            for item in sectitems:  

                itname = item.__class__.__name__  
﻿                sinfo[itname].Lines = item.lines.getlinealiases() or  

None  

                sinfo[itname].Params = item.p._getkwargs() or None  

  

        ainfo = wrinfo.Analyzers  

  

        # Internal Value Analyzer  

        ainfo.Value.Begin = self.broker.startingcash  

        ainfo.Value.End = self.broker.getvalue()  

  

        # no slave analyzers for writer  

        for aname, analyzer in self.analyzers.getitems():  

            ainfo[aname].Params = analyzer.p._getkwargs() or None  

            ainfo[aname].Analysis = analyzer.get_analysis()  

  

        return wrinfo  

  

    def _stop(self):  

        self.stop()  

  

        for analyzer in itertools.chain(self.analyzers,  

self._slave_analyzers):  

            analyzer._stop()  

  

        # change operators back to stage 1 - allows reuse of datas  

        self._stage1()  

  
﻿    def stop(self):  

        '''Called right before the backtesting is about to be  

stopped'''  

        pass  

  

    def set_tradehistory(self, onoff=True):  

        self._tradehistoryon = onoff  

  

    def clear(self):  

        self._orders.extend(self._orderspending)  

        self._orderspending = list()  

        self._tradespending = list()  

  

    def _addnotification(self, order, quicknotify=False):  

        if not order.p.simulated:  

            self._orderspending.append(order)  

  

        if quicknotify:  

            qorders = [order]  

            qtrades = []  

  

        if not order.executed.size:  

            if quicknotify:  

                self._notify(qorders=qorders, qtrades=qtrades)  

            return  

  

        tradedata = order.data._compensate  
﻿        if tradedata is None:  

            tradedata = order.data  

  

        datatrades = self._trades[tradedata][order.tradeid]  

        if not datatrades:  

            trade = Trade(data=tradedata, tradeid=order.tradeid,  

                          historyon=self._tradehistoryon)  

            datatrades.append(trade)  

        else:  

            trade = datatrades[-1]  

  

        for exbit in order.executed.iterpending():  

            if exbit is None:  

                break  

  

            if exbit.closed:  

                trade.update(order,  

                             exbit.closed,  

                             exbit.price,  

                             exbit.closedvalue,  

                             exbit.closedcomm,  

                             exbit.pnl,  

                             comminfo=order.comminfo)  

  

                if trade.isclosed:  

                    self._tradespending.append(copy.copy(trade))  

                    if quicknotify:  
﻿                        qtrades.append(copy.copy(trade))  

  

            # Update it if needed  

            if exbit.opened:  

                if trade.isclosed:  

                    trade = Trade(data=tradedata,  

tradeid=order.tradeid,  

                                  historyon=self._tradehistoryon)  

                    datatrades.append(trade)  

  

                trade.update(order,  

                             exbit.opened,  

                             exbit.price,  

                             exbit.openedvalue,  

                             exbit.openedcomm,  

                             exbit.pnl,  

                             comminfo=order.comminfo)  

  

                # This extra check covers the case in which different  

tradeid  

                # orders have put the position down to 0 and the next  

order  

                # "opens" a position but "closes" the trade  

                if trade.isclosed:  

                    self._tradespending.append(copy.copy(trade))  

                    if quicknotify:  

                        qtrades.append(copy.copy(trade))  

  
﻿            if trade.justopened:  

                self._tradespending.append(copy.copy(trade))  

                if quicknotify:  

                    qtrades.append(copy.copy(trade))  

  

        if quicknotify:  

            self._notify(qorders=qorders, qtrades=qtrades)  

  

    def _notify(self, qorders=[], qtrades=[]):  

        if self.cerebro.p.quicknotify:  

            # need to know if quicknotify is on, to not reprocess  

pendingorders  

            # and pendingtrades, which have to exist for things like  

observers  

            # which look into it  

            procorders = qorders  

            proctrades = qtrades  

        else:  

            procorders = self._orderspending  

            proctrades = self._tradespending  

  

        for order in procorders:  

            if order.exectype != order.Historical or order.histnotify:  

                self.notify_order(order)  

            for analyzer in itertools.chain(self.analyzers,  

                                            self._slave_analyzers):  

                analyzer._notify_order(order)  
﻿  

        for trade in proctrades:  

            self.notify_trade(trade)  

            for analyzer in itertools.chain(self.analyzers,  

                                            self._slave_analyzers):  

                analyzer._notify_trade(trade)  

  

        if qorders:  

            return  # cash is notified on a regular basis  

  

        cash = self.broker.getcash()  

        value = self.broker.getvalue()  

        fundvalue = self.broker.fundvalue  

        fundshares = self.broker.fundshares  

  

        self.notify_cashvalue(cash, value)  

        self.notify_fund(cash, value, fundvalue, fundshares)  

        for analyzer in itertools.chain(self.analyzers,  

self._slave_analyzers):  

            analyzer._notify_cashvalue(cash, value)  

            analyzer._notify_fund(cash, value, fundvalue, fundshares)  

  

    def add_timer(self, when,  

                  offset=datetime.timedelta(),  

repeat=datetime.timedelta(),  

                  weekdays=[], weekcarry=False,  

                  monthdays=[], monthcarry=True,  
﻿                  allow=None,  

                  tzdata=None, cheat=False,  

                  *args, **kwargs):  

        '''  

        **Note**: can be called during ``__init__`` or ``start``  

  

        Schedules a timer to invoke either a specified callback or the  

        ``notify_timer`` of one or more strategies.  

  

        Arguments:  

  

          - ``when``: can be  

  

            - ``datetime.time`` instance (see below ``tzdata``)  

            - ``bt.timer.SESSION_START`` to reference a session start  

            - ``bt.timer.SESSION_END`` to reference a session end  

  

         - ``offset`` which must be a ``datetime.timedelta`` instance  

  

           Used to offset the value ``when``. It has a meaningful use  

in  

           combination with ``SESSION_START`` and ``SESSION_END``, to  

indicated  

           things like a timer being called ``15 minutes`` after the  

session  

           start.  

  

          - ``repeat`` which must be a ``datetime.timedelta`` instance  
﻿  

            Indicates if after a 1st call, further calls will be  

scheduled  

            within the same session at the scheduled ``repeat`` delta  

  

            Once the timer goes over the end of the session it is  

reset to the  

            original value for ``when``  

  

          - ``weekdays``: a **sorted** iterable with integers  

indicating on  

            which days (iso codes, Monday is 1, Sunday is 7) the  

timers can  

            be actually invoked  

  

            If not specified, the timer will be active on all days  

  

          - ``weekcarry`` (default: ``False``). If ``True`` and the  

weekday was  

            not seen (ex: trading holiday), the timer will be executed  

on the  

            next day (even if in a new week)  

  

          - ``monthdays``: a **sorted** iterable with integers  

indicating on  

            which days of the month a timer has to be executed. For  

example  

            always on day *15* of the month  

  
﻿            If not specified, the timer will be active on all days  

  

          - ``monthcarry`` (default: ``True``). If the day was not  

seen  

             (weekend, trading holiday), the timer will be executed on  

the next  

            available day.  

  

          - ``allow`` (default: ``None``). A callback which receives a  

            `datetime.date`` instance and returns ``True`` if the date  

is  

            allowed for timers or else returns ``False``  

  

          - ``tzdata`` which can be either ``None`` (default), a  

``pytz``  

            instance or a ``data feed`` instance.  

  

            ``None``: ``when`` is interpreted at face value (which  

translates  

            to handling it as if it where UTC even if it's not)  

  

            ``pytz`` instance: ``when`` will be interpreted as being  

specified  

            in the local time specified by the timezone instance.  

  

            ``data feed`` instance: ``when`` will be interpreted as  

being  

            specified in the local time specified by the ``tz``  

parameter of  
﻿            the data feed instance.  

  

            **Note**: If ``when`` is either ``SESSION_START`` or  

              ``SESSION_END`` and ``tzdata`` is ``None``, the 1st  

*data feed*  

              in the system (aka ``self.data0``) will be used as the  

reference  

              to find out the session times.  

  

          - ``cheat`` (default ``False``) if ``True`` the timer will  

be called  

            before the broker has a chance to evaluate the orders.  

This opens  

            the chance to issue orders based on opening price for  

example right  

            before the session starts  

  

          - ``*args``: any extra args will be passed to  

``notify_timer``  

  

          - ``**kwargs``: any extra kwargs will be passed to  

``notify_timer``  

  

        Return Value:  

  

          - The created timer  

  

        '''  

        return self.cerebro._add_timer(  
﻿            owner=self, when=when, offset=offset, repeat=repeat,  

            weekdays=weekdays, weekcarry=weekcarry,  

            monthdays=monthdays, monthcarry=monthcarry,  

            allow=allow,  

            tzdata=tzdata, strats=False, cheat=cheat,  

            *args, **kwargs)  

  

    def notify_timer(self, timer, when, *args, **kwargs):  

        '''Receives a timer notification where ``timer`` is the timer  

which was  

        returned by ``add_timer``, and ``when`` is the calling time.  

``args``  

        and ``kwargs`` are any additional arguments passed to  

``add_timer``  

  

        The actual ``when`` time can be later, but the system may have  

not be  

        able to call the timer before. This value is the timer value  

and no the  

        system time.  

        '''  

        pass  

  

    def notify_cashvalue(self, cash, value):  

        '''  

        Receives the current fund value, value status of the  

strategy's broker  

        '''  
﻿        pass  

  

    def notify_fund(self, cash, value, fundvalue, shares):  

        '''  

        Receives the current cash, value, fundvalue and fund shares  

        '''  

        pass  

  

    def notify_order(self, order):  

        '''  

        Receives an order whenever there has been a change in one  

        '''  

        pass  

  

    def notify_trade(self, trade):  

        '''  

        Receives a trade whenever there has been a change in one  

        '''  

        pass  

  

    def notify_store(self, msg, *args, **kwargs):  

        '''Receives a notification from a store provider'''  

        pass  

  

    def notify_data(self, data, status, *args, **kwargs):  

        '''Receives a notification from data'''  

        pass  
﻿  

    def getdatanames(self):  

        '''  

        Returns a list of the existing data names  

        '''  

        return keys(self.env.datasbyname)  

  

    def getdatabyname(self, name):  

        '''  

        Returns a given data by name using the environment (cerebro)  

        '''  

        return self.env.datasbyname[name]  

  

    def cancel(self, order):  

        '''Cancels the order in the broker'''  

        self.broker.cancel(order)  

  

    def buy(self, data=None,  

            size=None, price=None, plimit=None,  

            exectype=None, valid=None, tradeid=0, oco=None,  

            trailamount=None, trailpercent=None,  

            parent=None, transmit=True,  

            **kwargs):  

        '''Create a buy (long) order and send it to the broker  

  

          - ``data`` (default: ``None``)  

  
﻿            For which data the order has to be created. If ``None``  

then the  

            first data in the system, ``self.datas[0] or self.data0``  

(aka  

            ``self.data``) will be used  

  

          - ``size`` (default: ``None``)  

  

            Size to use (positive) of units of data to use for the  

order.  

  

            If ``None`` the ``sizer`` instance retrieved via  

``getsizer`` will  

            be used to determine the size.  

  

          - ``price`` (default: ``None``)  

  

            Price to use (live brokers may place restrictions on the  

actual  

            format if it does not comply to minimum tick size  

requirements)  

  

            ``None`` is valid for ``Market`` and ``Close`` orders (the  

market  

            determines the price)  

  

            For ``Limit``, ``Stop`` and ``StopLimit`` orders this  

value  

            determines the trigger point (in the case of ``Limit`` the  
﻿trigger  

            is obviously at which price the order should be matched)  

  

          - ``plimit`` (default: ``None``)  

  

            Only applicable to ``StopLimit`` orders. This is the price  

at which  

            to set the implicit *Limit* order, once the *Stop* has  

been  

            triggered (for which ``price`` has been used)  

  

          - ``trailamount`` (default: ``None``)  

  

            If the order type is StopTrail or StopTrailLimit, this is  

an  

            absolute amount which determines the distance to the price  

(below  

            for a Sell order and above for a buy order) to keep the  

trailing  

            stop  

  

          - ``trailpercent`` (default: ``None``)  

  

            If the order type is StopTrail or StopTrailLimit, this is  

a  

            percentage amount which determines the distance to the  

price (below  

            for a Sell order and above for a buy order) to keep the  

trailing  
﻿            stop (if ``trailamount`` is also specified it will be  

used)  

  

          - ``exectype`` (default: ``None``)  

  

            Possible values:  

  

            - ``Order.Market`` or ``None``. A market order will be  

executed  

              with the next available price. In backtesting it will be  

the  

              opening price of the next bar  

  

            - ``Order.Limit``. An order which can only be executed at  

the given  

              ``price`` or better  

  

            - ``Order.Stop``. An order which is triggered at ``price``  

and  

              executed like an ``Order.Market`` order  

  

            - ``Order.StopLimit``. An order which is triggered at  

``price`` and  

              executed as an implicit *Limit* order with price given  

by  

              ``pricelimit``  

  

            - ``Order.Close``. An order which can only be executed  

with the  
﻿              closing price of the session (usually during a closing  

auction)  

  

            - ``Order.StopTrail``. An order which is triggered at  

``price``  

              minus ``trailamount`` (or ``trailpercent``) and which is  

updated  

              if the price moves away from the stop  

  

            - ``Order.StopTrailLimit``. An order which is triggered at  

              ``price`` minus ``trailamount`` (or ``trailpercent``)  

and which  

              is updated if the price moves away from the stop  

  

          - ``valid`` (default: ``None``)  

  

            Possible values:  

  

              - ``None``: this generates an order that will not expire  

(aka  

                *Good till cancel*) and remain in the market until  

matched or  

                canceled. In reality brokers tend to impose a temporal  

limit,  

                but this is usually so far away in time to consider it  

as not  

                expiring  

  

              - ``datetime.datetime`` or ``datetime.date`` instance:  
﻿the date  

                will be used to generate an order valid until the  

given  

                datetime (aka *good till date*)  

  

              - ``Order.DAY`` or ``0`` or ``timedelta()``: a day valid  

until  

                the *End of the Session* (aka *day* order) will be  

generated  

  

              - ``numeric value``: This is assumed to be a value  

corresponding  

                to a datetime in ``matplotlib`` coding (the one used  

by  

                ``backtrader``) and will used to generate an order  

valid until  

                that time (*good till date*)  

  

          - ``tradeid`` (default: ``0``)  

  

            This is an internal value applied by ``backtrader`` to  

keep track  

            of overlapping trades on the same asset. This ``tradeid``  

is sent  

            back to the *strategy* when notifying changes to the  

status of the  

            orders.  

  

          - ``oco`` (default: ``None``)  
﻿  

            Another ``order`` instance. This order will become part of  

an OCO  

             (Order Cancel Others) group. The execution of one of the  

orders,  

            immediately cancels all others in the same group  

  

          - ``parent`` (default: ``None``)  

  

            Controls the relationship of a group of orders, for  

example a buy  

            which is bracketed by a high-side limit sell and a low  

side stop  

            sell. The high/low side orders remain inactive until the  

parent  

            order has been either executed (they become active) or is  

            canceled/expires (the children are also canceled) bracket  

orders  

            have the same size  

  

          - ``transmit`` (default: ``True``)  

  

            Indicates if the order has to be **transmitted**, ie: not  

only  

            placed in the broker but also issued. This is meant for  

example to  

            control bracket orders, in which one disables the  

transmission for  

            the parent and 1st set of children and activates it for  

the last  
﻿            children, which triggers the full placement of all bracket  

orders.  

  

          - ``**kwargs``: additional broker implementations may  

support extra  

            parameters. ``backtrader`` will pass the *kwargs* down to  

the  

            created order objects  

  

            Example: if the 4 order execution types directly supported  

by  

            ``backtrader`` are not enough, in the case of for example  

            *Interactive Brokers* the following could be passed as  

*kwargs*::  

  

              orderType='LIT', lmtPrice=10.0, auxPrice=9.8  

  

            This would override the settings created by ``backtrader``  

and  

            generate a ``LIMIT IF TOUCHED`` order with a *touched*  

price of 9.8  

            and a *limit* price of 10.0.  

  

        Returns:  

          - the submitted order  

  

        '''  

        if isinstance(data, string_types):  

            data = self.getdatabyname(data)  
﻿  

        data = data if data is not None else self.datas[0]  

        size = size if size is not None else self.getsizing(data,  

isbuy=True)  

  

        if size:  

            return self.broker.buy(  

                self, data,  

                size=abs(size), price=price, plimit=plimit,  

                exectype=exectype, valid=valid, tradeid=tradeid,  

oco=oco,  

                trailamount=trailamount, trailpercent=trailpercent,  

                parent=parent, transmit=transmit,  

                **kwargs)  

  

        return None  

  

    def sell(self, data=None,  

             size=None, price=None, plimit=None,  

             exectype=None, valid=None, tradeid=0, oco=None,  

             trailamount=None, trailpercent=None,  

             parent=None, transmit=True,  

             **kwargs):  

        '''  

        To create a selll (short) order and send it to the broker  

  

        See the documentation for ``buy`` for an explanation of the  

parameters  
﻿  

        Returns: the submitted order  

        '''  

        if isinstance(data, string_types):  

            data = self.getdatabyname(data)  

  

        data = data if data is not None else self.datas[0]  

        size = size if size is not None else self.getsizing(data,  

isbuy=False)  

  

        if size:  

            return self.broker.sell(  

                self, data,  

                size=abs(size), price=price, plimit=plimit,  

                exectype=exectype, valid=valid, tradeid=tradeid,  

oco=oco,  

                trailamount=trailamount, trailpercent=trailpercent,  

                parent=parent, transmit=transmit,  

                **kwargs)  

  

        return None  

  

    def close(self, data=None, size=None, **kwargs):  

        '''  

        Counters a long/short position closing it  

  

        See the documentation for ``buy`` for an explanation of the  

parameters  
﻿  

        Note:  

  

          - ``size``: automatically calculated from the existing  

position if  

            not provided (default: ``None``) by the caller  

  

        Returns: the submitted order  

        '''  

        if isinstance(data, string_types):  

            data = self.getdatabyname(data)  

        elif data is None:  

            data = self.data  

  

        possize = self.getposition(data, self.broker).size  

        size = abs(size if size is not None else possize)  

  

        if possize > 0:  

            return self.sell(data=data, size=size, **kwargs)  

        elif possize < 0:  

            return self.buy(data=data, size=size, **kwargs)  

  

        return None  

  

    def buy_bracket(self, data=None, size=None, price=None,  

plimit=None,  

                    exectype=bt.Order.Limit, valid=None, tradeid=0,  
﻿                    trailamount=None, trailpercent=None, oargs={},  

                    stopprice=None, stopexec=bt.Order.Stop,  

stopargs={},  

                    limitprice=None, limitexec=bt.Order.Limit,  

limitargs={},  

                    **kwargs):  

        '''  

        Create a bracket order group (low side - buy order - high  

side). The  

        default behavior is as follows:  

  

          - Issue a **buy** order with execution ``Limit``  

  

          - Issue a *low side* bracket **sell** order with execution  

``Stop``  

  

          - Issue a *high side* bracket **sell** order with execution  

            ``Limit``.  

  

        See below for the different parameters  

  

          - ``data`` (default: ``None``)  

  

            For which data the order has to be created. If ``None``  

then the  

            first data in the system, ``self.datas[0] or self.data0``  

(aka  

            ``self.data``) will be used  
﻿  

          - ``size`` (default: ``None``)  

  

            Size to use (positive) of units of data to use for the  

order.  

  

            If ``None`` the ``sizer`` instance retrieved via  

``getsizer`` will  

            be used to determine the size.  

  

            **Note**: The same size is applied to all 3 orders of the  

bracket  

  

          - ``price`` (default: ``None``)  

  

            Price to use (live brokers may place restrictions on the  

actual  

            format if it does not comply to minimum tick size  

requirements)  

  

            ``None`` is valid for ``Market`` and ``Close`` orders (the  

market  

            determines the price)  

  

            For ``Limit``, ``Stop`` and ``StopLimit`` orders this  

value  

            determines the trigger point (in the case of ``Limit`` the  

trigger  

            is obviously at which price the order should be matched)  
﻿  

          - ``plimit`` (default: ``None``)  

  

            Only applicable to ``StopLimit`` orders. This is the price  

at which  

            to set the implicit *Limit* order, once the *Stop* has  

been  

            triggered (for which ``price`` has been used)  

  

          - ``trailamount`` (default: ``None``)  

  

            If the order type is StopTrail or StopTrailLimit, this is  

an  

            absolute amount which determines the distance to the price  

(below  

            for a Sell order and above for a buy order) to keep the  

trailing  

            stop  

  

          - ``trailpercent`` (default: ``None``)  

  

            If the order type is StopTrail or StopTrailLimit, this is  

a  

            percentage amount which determines the distance to the  

price (below  

            for a Sell order and above for a buy order) to keep the  

trailing  

            stop (if ``trailamount`` is also specified it will be  

used)  
﻿  

          - ``exectype`` (default: ``bt.Order.Limit``)  

  

            Possible values: (see the documentation for the method  

``buy``  

  

          - ``valid`` (default: ``None``)  

  

            Possible values: (see the documentation for the method  

``buy``  

  

          - ``tradeid`` (default: ``0``)  

  

            Possible values: (see the documentation for the method  

``buy``  

  

          - ``oargs`` (default: ``{}``)  

  

            Specific keyword arguments (in a ``dict``) to pass to the  

main side  

            order. Arguments from the default ``**kwargs`` will be  

applied on  

            top of this.  

  

          - ``**kwargs``: additional broker implementations may  

support extra  

            parameters. ``backtrader`` will pass the *kwargs* down to  

the  

            created order objects  
﻿  

            Possible values: (see the documentation for the method  

``buy``  

  

            **Note**: this ``kwargs`` will be applied to the 3 orders  

of a  

            bracket. See below for specific keyword arguments for the  

low and  

            high side orders  

  

          - ``stopprice`` (default: ``None``)  

  

            Specific price for the *low side* stop order  

  

          - ``stopexec`` (default: ``bt.Order.Stop``)  

  

            Specific execution type for the *low side* order  

  

          - ``stopargs`` (default: ``{}``)  

  

            Specific keyword arguments (in a ``dict``) to pass to the  

low side  

            order. Arguments from the default ``**kwargs`` will be  

applied on  

            top of this.  

  

          - ``limitprice`` (default: ``None``)  

  
﻿            Specific price for the *high side* stop order  

  

          - ``stopexec`` (default: ``bt.Order.Limit``)  

  

            Specific execution type for the *high side* order  

  

          - ``limitargs`` (default: ``{}``)  

  

            Specific keyword arguments (in a ``dict``) to pass to the  

high side  

            order. Arguments from the default ``**kwargs`` will be  

applied on  

            top of this.  

  

        High/Low Side orders can be suppressed by using:  

  

          - ``limitexec=None`` to suppress the *high side*  

  

          - ``stopexec=None`` to suppress the *low side*  

  

        Returns:  

  

          - A list containing the 3 orders [order, stop side, limit  

side]  

  

          - If high/low orders have been suppressed the return value  

will still  

            contain 3 orders, but those suppressed will have a value  
﻿of  

            ``None``  

        '''  

  

        kargs = dict(size=size,  

                     data=data, price=price, plimit=plimit,  

exectype=exectype,  

                     valid=valid, tradeid=tradeid,  

                     trailamount=trailamount,  

trailpercent=trailpercent)  

        kargs.update(oargs)  

        kargs.update(kwargs)  

        kargs['transmit'] = limitexec is None and stopexec is None  

        o = self.buy(**kargs)  

  

        if stopexec is not None:  

            # low side / stop  

            kargs = dict(data=data, price=stopprice,  

exectype=stopexec,  

                         valid=valid, tradeid=tradeid)  

            kargs.update(stopargs)  

            kargs.update(kwargs)  

            kargs['parent'] = o  

            kargs['transmit'] = limitexec is None  

            kargs['size'] = o.size  

            ostop = self.sell(**kargs)  

        else:  

            ostop = None  
﻿  

        if limitexec is not None:  

            # high side / limit  

            kargs = dict(data=data, price=limitprice,  

exectype=limitexec,  

                         valid=valid, tradeid=tradeid)  

            kargs.update(limitargs)  

            kargs.update(kwargs)  

            kargs['parent'] = o  

            kargs['transmit'] = True  

            kargs['size'] = o.size  

            olimit = self.sell(**kargs)  

        else:  

            olimit = None  

  

        return [o, ostop, olimit]  

  

    def sell_bracket(self, data=None,  

                     size=None, price=None, plimit=None,  

                     exectype=bt.Order.Limit, valid=None, tradeid=0,  

                     trailamount=None, trailpercent=None,  

                     oargs={},  

                     stopprice=None, stopexec=bt.Order.Stop,  

stopargs={},  

                     limitprice=None, limitexec=bt.Order.Limit,  

limitargs={},  

                     **kwargs):  

        '''  
﻿        Create a bracket order group (low side - buy order - high  

side). The  

        default behavior is as follows:  

  

          - Issue a **sell** order with execution ``Limit``  

  

          - Issue a *high side* bracket **buy** order with execution  

``Stop``  

  

          - Issue a *low side* bracket **buy** order with execution  

``Limit``.  

  

        See ``bracket_buy`` for the meaning of the parameters  

  

        High/Low Side orders can be suppressed by using:  

  

          - ``stopexec=None`` to suppress the *high side*  

  

          - ``limitexec=None`` to suppress the *low side*  

  

        Returns:  

  

          - A list containing the 3 orders [order, stop side, limit  

side]  

  

          - If high/low orders have been suppressed the return value  

will still  

            contain 3 orders, but those suppressed will have a value  
﻿of  

            ``None``  

        '''  

  

        kargs = dict(size=size,  

                     data=data, price=price, plimit=plimit,  

exectype=exectype,  

                     valid=valid, tradeid=tradeid,  

                     trailamount=trailamount,  

trailpercent=trailpercent)  

        kargs.update(oargs)  

        kargs.update(kwargs)  

        kargs['transmit'] = limitexec is None and stopexec is None  

        o = self.sell(**kargs)  

  

        if stopexec is not None:  

            # high side / stop  

            kargs = dict(data=data, price=stopprice,  

exectype=stopexec,  

                         valid=valid, tradeid=tradeid)  

            kargs.update(stopargs)  

            kargs.update(kwargs)  

            kargs['parent'] = o  

            kargs['transmit'] = limitexec is None  # transmit if last  

            kargs['size'] = o.size  

            ostop = self.buy(**kargs)  

        else:  

            ostop = None  
﻿  

        if limitexec is not None:  

            # low side / limit  

            kargs = dict(data=data, price=limitprice,  

exectype=limitexec,  

                         valid=valid, tradeid=tradeid)  

            kargs.update(limitargs)  

            kargs.update(kwargs)  

            kargs['parent'] = o  

            kargs['transmit'] = True  

            kargs['size'] = o.size  

            olimit = self.buy(**kargs)  

        else:  

            olimit = None  

  

        return [o, ostop, olimit]  

  

    def order_target_size(self, data=None, target=0, **kwargs):  

        '''  

        Place an order to rebalance a position to have final size of  

``target``  

  

        The current ``position`` size is taken into account as the  

start point  

        to achieve ``target``  

  

          - If ``target`` > ``pos.size`` -> buy ``target - pos.size``  

  
﻿          - If ``target`` < ``pos.size`` -> sell ``pos.size - target``  

  

        It returns either:  

  

          - The generated order  

  

          or  

  

          - ``None`` if no order has been issued (``target ==  

position.size``)  

        '''  

        if isinstance(data, string_types):  

            data = self.getdatabyname(data)  

        elif data is None:  

            data = self.data  

  

        possize = self.getposition(data, self.broker).size  

        if not target and possize:  

            return self.close(data=data, size=possize, **kwargs)  

  

        elif target > possize:  

            return self.buy(data=data, size=target - possize,  

**kwargs)  

  

        elif target < possize:  

            return self.sell(data=data, size=possize - target,  

**kwargs)  

  
﻿        return None  # no execution target == possize  

  

    def order_target_value(self, data=None, target=0.0, price=None,  

**kwargs):  

        '''  

        Place an order to rebalance a position to have final value of  

        ``target``  

  

        The current ``value`` is taken into account as the start point  

to  

        achieve ``target``  

  

          - If no ``target`` then close postion on data  

          - If ``target`` > ``value`` then buy on data  

          - If ``target`` < ``value`` then sell on data  

  

        It returns either:  

  

          - The generated order  

  

          or  

  

          - ``None`` if no order has been issued  

        '''  

  

        if isinstance(data, string_types):  

            data = self.getdatabyname(data)  
﻿        elif data is None:  

            data = self.data  

  

        possize = self.getposition(data, self.broker).size  

        if not target and possize:  # closing a position  

            return self.close(data=data, size=possize, price=price,  

**kwargs)  

  

        else:  

            value = self.broker.getvalue(datas=[data])  

            comminfo = self.broker.getcommissioninfo(data)  

  

            # Make sure a price is there  

            price = price if price is not None else data.close[0]  

  

            if target > value:  

                size = comminfo.getsize(price, target - value)  

                return self.buy(data=data, size=size, price=price,  

**kwargs)  

  

            elif target < value:  

                size = comminfo.getsize(price, value - target)  

                return self.sell(data=data, size=size, price=price,  

**kwargs)  

  

        return None  # no execution size == possize  

  

    def order_target_percent(self, data=None, target=0.0, **kwargs):  
﻿        '''  

        Place an order to rebalance a position to have final value of  

        ``target`` percentage of current portfolio ``value``  

  

        ``target`` is expressed in decimal: ``0.05`` -> ``5%``  

  

        It uses ``order_target_value`` to execute the order.  

  

        Example:  

          - ``target=0.05`` and portfolio value is ``100``  

  

          - The ``value`` to be reached is ``0.05 * 100 = 5``  

  

          - ``5`` is passed as the ``target`` value to  

``order_target_value``  

  

        The current ``value`` is taken into account as the start point  

to  

        achieve ``target``  

  

        The ``position.size`` is used to determine if a position is  

``long`` /  

        ``short``  

  

          - If ``target`` > ``value``  

            - buy if ``pos.size >= 0`` (Increase a long position)  

            - sell if ``pos.size < 0`` (Increase a short position)  

  
﻿          - If ``target`` < ``value``  

            - sell if ``pos.size >= 0`` (Decrease a long position)  

            - buy if ``pos.size < 0`` (Decrease a short position)  

  

        It returns either:  

  

          - The generated order  

  

          or  

  

          - ``None`` if no order has been issued (``target ==  

position.size``)  

        '''  

        if isinstance(data, string_types):  

            data = self.getdatabyname(data)  

        elif data is None:  

            data = self.data  

  

        possize = self.getposition(data, self.broker).size  

        target *= self.broker.getvalue()  

  

        return self.order_target_value(data=data, target=target,  

**kwargs)  

  

    def getposition(self, data=None, broker=None):  

        '''  

        Returns the current position for a given data in a given  

broker.  
﻿  

        If both are None, the main data and the default broker will be  

used  

  

        A property ``position`` is also available  

        '''  

        data = data if data is not None else self.datas[0]  

        broker = broker or self.broker  

        return broker.getposition(data)  

  

    position = property(getposition)  

  

    def getpositionbyname(self, name=None, broker=None):  

        '''  

        Returns the current position for a given name in a given  

broker.  

  

        If both are None, the main data and the default broker will be  

used  

  

        A property ``positionbyname`` is also available  

        '''  

        data = self.datas[0] if not name else self.getdatabyname(name)  

        broker = broker or self.broker  

        return broker.getposition(data)  

  

    positionbyname = property(getpositionbyname)  

  
﻿    def getpositions(self, broker=None):  

        '''  

        Returns the current by data positions directly from the broker  

  

        If the given ``broker`` is None, the default broker will be  

used  

  

        A property ``positions`` is also available  

        '''  

        broker = broker or self.broker  

        return broker.positions  

  

    positions = property(getpositions)  

  

    def getpositionsbyname(self, broker=None):  

        '''  

        Returns the current by name positions directly from the broker  

  

        If the given ``broker`` is None, the default broker will be  

used  

  

        A property ``positionsbyname`` is also available  

        '''  

        broker = broker or self.broker  

        positions = broker.positions  

  

        posbyname = collections.OrderedDict()  
﻿        for name, data in iteritems(self.env.datasbyname):  

            posbyname[name] = positions[data]  

  

        return posbyname  

  

    positionsbyname = property(getpositionsbyname)  

  

    def _addsizer(self, sizer, *args, **kwargs):  

        if sizer is None:  

            self.setsizer(bt.sizers.FixedSize())  

        else:  

            self.setsizer(sizer(*args, **kwargs))  

  

    def setsizer(self, sizer):  

        '''  

        Replace the default (fixed stake) sizer  

        '''  

        self._sizer = sizer  

        sizer.set(self, self.broker)  

        return sizer  

  

    def getsizer(self):  

        '''  

        Returns the sizer which is in used if automatic statke  

calculation is  

        used  

  
﻿        Also available as ``sizer``  

        '''  

        return self._sizer  

  

    sizer = property(getsizer, setsizer)  

  

    def getsizing(self, data=None, isbuy=True):  

        '''  

        Return the stake calculated by the sizer instance for the  

current  

        situation  

        '''  

        data = data if data is not None else self.datas[0]  

        return self._sizer.getsizing(data, isbuy=isbuy)  

  

  

class MetaSigStrategy(Strategy.__class__):  

  

    def __new__(meta, name, bases, dct):  

        # map user defined next to custom to be able to call own  

method before  

        if 'next' in dct:  

            dct['_next_custom'] = dct.pop('next')  

  

        cls = super(MetaSigStrategy, meta).__new__(meta, name, bases,  

dct)  

  

        # after class creation remap _next_catch to be next  
﻿        cls.next = cls._next_catch  

        return cls  

  

    def dopreinit(cls, _obj, *args, **kwargs):  

        _obj, args, kwargs = \  

            super(MetaSigStrategy, cls).dopreinit(_obj, *args,  

**kwargs)  

  

        _obj._signals = collections.defaultdict(list)  

  

        _data = _obj.p._data  

        if _data is None:  

            _obj._dtarget = _obj.data0  

        elif isinstance(_data, integer_types):  

            _obj._dtarget = _obj.datas[_data]  

        elif isinstance(_data, string_types):  

            _obj._dtarget = _obj.getdatabyname(_data)  

        elif isinstance(_data, bt.LineRoot):  

            _obj._dtarget = _data  

        else:  

            _obj._dtarget = _obj.data0  

  

        return _obj, args, kwargs  

  

    def dopostinit(cls, _obj, *args, **kwargs):  

        _obj, args, kwargs = \  

            super(MetaSigStrategy, cls).dopostinit(_obj, *args,  
﻿**kwargs)  

  

        for sigtype, sigcls, sigargs, sigkwargs in _obj.p.signals:  

            _obj._signals[sigtype].append(sigcls(*sigargs,  

**sigkwargs))  

  

        # Record types of signals  

        _obj._longshort = bool(_obj._signals[bt.SIGNAL_LONGSHORT])  

  

        _obj._long = bool(_obj._signals[bt.SIGNAL_LONG])  

        _obj._short = bool(_obj._signals[bt.SIGNAL_SHORT])  

  

        _obj._longexit = bool(_obj._signals[bt.SIGNAL_LONGEXIT])  

        _obj._shortexit = bool(_obj._signals[bt.SIGNAL_SHORTEXIT])  

  

        return _obj, args, kwargs  

  

  

class SignalStrategy(with_metaclass(MetaSigStrategy, Strategy)):  

    '''This subclass of ``Strategy`` is meant to to auto-operate using  

    **signals**.  

  

    *Signals* are usually indicators and the expected output values:  

  

      - ``> 0`` is a ``long`` indication  

  

      - ``< 0`` is a ``short`` indication  
﻿  

    There are 5 types of *Signals*, broken in 2 groups.  

  

    **Main Group**:  

  

      - ``LONGSHORT``: both ``long`` and ``short`` indications from  

this signal  

        are taken  

  

      - ``LONG``:  

        - ``long`` indications are taken to go long  

        - ``short`` indications are taken to *close* the long  

position. But:  

  

          - If a ``LONGEXIT`` (see below) signal is in the system it  

will be  

            used to exit the long  

  

          - If a ``SHORT`` signal is available and no ``LONGEXIT`` is  

available  

            , it will be used to close a ``long`` before opening a  

``short``  

  

      - ``SHORT``:  

        - ``short`` indications are taken to go short  

        - ``long`` indications are taken to *close* the short  

position. But:  

  
﻿          - If a ``SHORTEXIT`` (see below) signal is in the system it  

will be  

            used to exit the short  

  

          - If a ``LONG`` signal is available and no ``SHORTEXIT`` is  

available  

            , it will be used to close a ``short`` before opening a  

``long``  

  

    **Exit Group**:  

  

      This 2 signals are meant to override others and provide criteria  

for  

      exitins a ``long``/``short`` position  

  

      - ``LONGEXIT``: ``short`` indications are taken to exit ``long``  

        positions  

  

      - ``SHORTEXIT``: ``long`` indications are taken to exit  

``short``  

        positions  

  

    **Order Issuing**  

  

      Orders execution type is ``Market`` and validity is ``None``  

(*Good until  

      Canceled*)  

  
﻿    Params:  

  

      - ``signals`` (default: ``[]``): a list/tuple of lists/tuples  

that allows  

        the instantiation of the signals and allocation to the right  

type  

  

        This parameter is expected to be managed through  

``cerebro.add_signal``  

  

      - ``_accumulate`` (default: ``False``): allow to enter the  

market  

         (long/short) even if already in the market  

  

      - ``_concurrent`` (default: ``False``): allow orders to be  

issued even if  

        orders are already pending execution  

  

      - ``_data`` (default: ``None``): if multiple datas are present  

in the  

        system which is the target for orders. This can be  

  

        - ``None``: The first data in the system will be used  

  

        - An ``int``: indicating the data that was inserted at that  

position  

  

        - An ``str``: name given to the data when creating it  

(parameter  
﻿          ``name``) or when adding it cerebro with  

``cerebro.adddata(...,  

          name=)``  

  

        - A ``data`` instance  

  

    '''  

  

    params = (  

         ('signals', []),  

         ('_accumulate', False),  

         ('_concurrent', False),  

         ('_data', None),  

    )  

  

    def _start(self):  

        self._sentinel = None  # sentinel for order concurrency  

        super(SignalStrategy, self)._start()  

  

    def signal_add(self, sigtype, signal):  

        self._signals[sigtype].append(signal)  

  

    def _notify(self, qorders=[], qtrades=[]):  

        # Nullify the sentinel if done  

        procorders = qorders or self._orderspending  

        if self._sentinel is not None:  

            for order in procorders:  
﻿                if order == self._sentinel and not order.alive():  

                    self._sentinel = None  

                    break  

  

        super(SignalStrategy, self)._notify(qorders=qorders,  

qtrades=qtrades)  

  

    def _next_catch(self):  

        self._next_signal()  

        if hasattr(self, '_next_custom'):  

            self._next_custom()  

  

    def _next_signal(self):  

        if self._sentinel is not None and not self.p._concurrent:  

            return  # order active and more than 1 not allowed  

  

        sigs = self._signals  

        nosig = [[0.0]]  

  

        # Calculate current status of the signals  

        ls_long = all(x[0] > 0.0 for x in sigs[bt.SIGNAL_LONGSHORT] or  

nosig)  

        ls_short = all(x[0] < 0.0 for x in sigs[bt.SIGNAL_LONGSHORT]  

or nosig)  

  

        l_enter0 = all(x[0] > 0.0 for x in sigs[bt.SIGNAL_LONG] or  

nosig)  

        l_enter1 = all(x[0] < 0.0 for x in sigs[bt.SIGNAL_LONG_INV] or  
﻿nosig)  

        l_enter2 = all(x[0] for x in sigs[bt.SIGNAL_LONG_ANY] or  

nosig)  

        l_enter = l_enter0 or l_enter1 or l_enter2  

  

        s_enter0 = all(x[0] < 0.0 for x in sigs[bt.SIGNAL_SHORT] or  

nosig)  

        s_enter1 = all(x[0] > 0.0 for x in sigs[bt.SIGNAL_SHORT_INV]  

or nosig)  

        s_enter2 = all(x[0] for x in sigs[bt.SIGNAL_SHORT_ANY] or  

nosig)  

        s_enter = s_enter0 or s_enter1 or s_enter2  

  

        l_ex0 = all(x[0] < 0.0 for x in sigs[bt.SIGNAL_LONGEXIT] or  

nosig)  

        l_ex1 = all(x[0] > 0.0 for x in sigs[bt.SIGNAL_LONGEXIT_INV]  

or nosig)  

        l_ex2 = all(x[0] for x in sigs[bt.SIGNAL_LONGEXIT_ANY] or  

nosig)  

        l_exit = l_ex0 or l_ex1 or l_ex2  

  

        s_ex0 = all(x[0] > 0.0 for x in sigs[bt.SIGNAL_SHORTEXIT] or  

nosig)  

        s_ex1 = all(x[0] < 0.0 for x in sigs[bt.SIGNAL_SHORTEXIT_INV]  

or nosig)  

        s_ex2 = all(x[0] for x in sigs[bt.SIGNAL_SHORTEXIT_ANY] or  

nosig)  

        s_exit = s_ex0 or s_ex1 or s_ex2  

  

        # Use oppossite signales to start reversal (by closing)  
﻿        # but only if no "xxxExit" exists  

        l_rev = not self._longexit and s_enter  

        s_rev = not self._shortexit and l_enter  

  

        # Opposite of individual long and short  

        l_leav0 = all(x[0] < 0.0 for x in sigs[bt.SIGNAL_LONG] or  

nosig)  

        l_leav1 = all(x[0] > 0.0 for x in sigs[bt.SIGNAL_LONG_INV] or  

nosig)  

        l_leav2 = all(x[0] for x in sigs[bt.SIGNAL_LONG_ANY] or nosig)  

        l_leave = l_leav0 or l_leav1 or l_leav2  

  

        s_leav0 = all(x[0] > 0.0 for x in sigs[bt.SIGNAL_SHORT] or  

nosig)  

        s_leav1 = all(x[0] < 0.0 for x in sigs[bt.SIGNAL_SHORT_INV] or  

nosig)  

        s_leav2 = all(x[0] for x in sigs[bt.SIGNAL_SHORT_ANY] or  

nosig)  

        s_leave = s_leav0 or s_leav1 or s_leav2  

  

        # Invalidate long leave if longexit signals are available  

        l_leave = not self._longexit and l_leave  

        # Invalidate short leave if shortexit signals are available  

        s_leave = not self._shortexit and s_leave  

  

        # Take size and start logic  

        size = self.getposition(self._dtarget).size  

        if not size:  
﻿            if ls_long or l_enter:  

                self._sentinel = self.buy(self._dtarget)  

  

            elif ls_short or s_enter:  

                self._sentinel = self.sell(self._dtarget)  

  

        elif size > 0:  # current long position  

            if ls_short or l_exit or l_rev or l_leave:  

                # closing position - not relevant for concurrency  

                self.close(self._dtarget)  

  

            if ls_short or l_rev:  

                self._sentinel = self.sell(self._dtarget)  

  

            if ls_long or l_enter:  

                if self.p._accumulate:  

                    self._sentinel = self.buy(self._dtarget)  

  

        elif size < 0:  # current short position  

            if ls_long or s_exit or s_rev or s_leave:  

                # closing position - not relevant for concurrency  

                self.close(self._dtarget)  

  

            if ls_long or s_rev:  

                self._sentinel = self.buy(self._dtarget)  

  

            if ls_short or s_enter:  
﻿                if self.p._accumulate:  

                    self._sentinel = self.sell(self._dtarget)  

  

  

  

##############################  

# 文件: talib.txt  

##############################  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  
﻿# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

# The modules below should/must define __all__ with the objects wishes  

# or prepend an "_" (underscore) to private classes/variables  

  

import sys  

  

import backtrader as bt  

from backtrader.utils.py3 import with_metaclass  

  

  

try:  

    import talib  

except ImportError:  

    __all__ = []  # talib is not available  

else:  

    import numpy as np  # talib dependency  

    import talib.abstract  

  

    MA_Type = talib.MA_Type  

  
﻿    # Reverse TA_FUNC_FLAGS dict  

    R_TA_FUNC_FLAGS = dict(  

        zip(talib.abstract.TA_FUNC_FLAGS.values(),  

            talib.abstract.TA_FUNC_FLAGS.keys()))  

  

    FUNC_FLAGS_SAMESCALE = 16777216  

    FUNC_FLAGS_UNSTABLE = 134217728  

    FUNC_FLAGS_CANDLESTICK = 268435456  

  

    R_TA_OUTPUT_FLAGS = dict(  

        zip(talib.abstract.TA_OUTPUT_FLAGS.values(),  

            talib.abstract.TA_OUTPUT_FLAGS.keys()))  

  

    OUT_FLAGS_LINE = 1  

    OUT_FLAGS_DOTTED = 2  

    OUT_FLAGS_DASH = 4  

    OUT_FLAGS_HISTO = 16  

    OUT_FLAGS_UPPER = 2048  

    OUT_FLAGS_LOWER = 4096  

  

    # Generate all indicators as subclasses  

  

    class _MetaTALibIndicator(bt.Indicator.__class__):  

        _refname = '_taindcol'  

        _taindcol = dict()  

  

        _KNOWN_UNSTABLE = ['SAR']  
﻿  

        def dopostinit(cls, _obj, *args, **kwargs):  

            # Go to parent  

            res = super(_MetaTALibIndicator, cls).dopostinit(_obj,  

                                                             *args,  

**kwargs)  

            _obj, args, kwargs = res  

  

            # Get the minimum period by using the abstract interface  

and params  

            _obj._tabstract.set_function_args(**_obj.p._getkwargs())  

            _obj._lookback = lookback = _obj._tabstract.lookback + 1  

            _obj.updateminperiod(lookback)  

            if _obj._unstable:  

                _obj._lookback = 0  

  

            elif cls.__name__ in cls._KNOWN_UNSTABLE:  

                _obj._lookback = 0  

  

            cerebro = bt.metabase.findowner(_obj, bt.Cerebro)  

            tafuncinfo = _obj._tabstract.info  

            _obj._tafunc = getattr(talib, tafuncinfo['name'], None)  

            return _obj, args, kwargs  # return the object and args  

  

    class _TALibIndicator(with_metaclass(_MetaTALibIndicator,  

bt.Indicator)):  

        CANDLEOVER = 1.02  # 2% over  

        CANDLEREF = 1  # Open, High, Low, Close (0, 1, 2, 3)  
﻿  

        @classmethod  

        def _subclass(cls, name):  

            # Module where the class has to end (namely this one)  

            clsmodule = sys.modules[cls.__module__]  

  

            # Create an abstract interface to get lines names  

            _tabstract = talib.abstract.Function(name)  

  

            # Variables about the the info learnt from func_flags  

            iscandle = False  

            unstable = False  

  

            # Prepare plotinfo  

            plotinfo = dict()  

            fflags = _tabstract.function_flags or []  

            for fflag in fflags:  

                rfflag = R_TA_FUNC_FLAGS[fflag]  

                if rfflag == FUNC_FLAGS_SAMESCALE:  

                    plotinfo['subplot'] = False  

                elif rfflag == FUNC_FLAGS_UNSTABLE:  

                    unstable = True  

                elif rfflag == FUNC_FLAGS_CANDLESTICK:  

                    plotinfo['subplot'] = False  

                    plotinfo['plotlinelabels'] = True  

                    iscandle = True  

  
﻿            # Prepare plotlines  

            lines = _tabstract.output_names  

            output_flags = _tabstract.output_flags  

            plotlines = dict()  

            samecolor = False  

            for lname in lines:  

                oflags = output_flags.get(lname, None)  

                pline = dict()  

                for oflag in oflags or []:  

                    orflag = R_TA_OUTPUT_FLAGS[oflag]  

                    if orflag & OUT_FLAGS_LINE:  

                        if not iscandle:  

                            pline['ls'] = '-'  

                        else:  

                            pline['_plotskip'] = True  # do not plot  

candles  

  

                    elif orflag & OUT_FLAGS_DASH:  

                        pline['ls'] = '--'  

                    elif orflag & OUT_FLAGS_DOTTED:  

                        pline['ls'] = ':'  

                    elif orflag & OUT_FLAGS_HISTO:  

                        pline['_method'] = 'bar'  

  

                    if samecolor:  

                        pline['_samecolor'] = True  

  
﻿                    if orflag & OUT_FLAGS_LOWER:  

                        samecolor = False  

  

                    elif orflag & OUT_FLAGS_UPPER:  

                        samecolor = True  # last: other values in loop  

are seen  

  

                if pline:  # the dict has something  

                    plotlines[lname] = pline  

  

            if iscandle:  

                # This is the line that will be plotted when the  

output of the  

                # indicator is a candle. The values of a candle (100)  

will be  

                # used to plot a sign above the maximum of the bar  

which  

                # produces the candle  

                pline = dict()  

                pline['_name'] = name  # plotted name  

                lname = '_candleplot'  # change name  

                lines.append(lname)  

                pline['ls'] = ''  

                pline['marker'] = 'd'  

                pline['markersize'] = '7.0'  

                pline['fillstyle'] = 'full'  

                plotlines[lname] = pline  

  
﻿            # Prepare dictionary for subclassing  

            clsdict = {  

                '__module__': cls.__module__,  

                '__doc__': str(_tabstract),  

                '_tabstract': _tabstract,  # keep ref for lookback  

calcs  

                '_iscandle': iscandle,  

                '_unstable': unstable,  

                'params': _tabstract.get_parameters(),  

                'lines': tuple(lines),  

                'plotinfo': plotinfo,  

                'plotlines': plotlines,  

            }  

            newcls = type(str(name), (cls,), clsdict)  # subclass  

            setattr(clsmodule, str(name), newcls)  # add to module  

  

        def oncestart(self, start, end):  

            pass  # if not ... a call with a single value to once will  

happen  

  

        def once(self, start, end):  

            import array  

  

            # prepare the data arrays - single shot  

            narrays = [np.array(x.lines[0].array) for x in self.datas]  

            # Execute  

            output = self._tafunc(*narrays, **self.p._getkwargs())  
﻿  

            fsize = self.size()  

            lsize = fsize - self._iscandle  

            if lsize == 1:  # only 1 output, no tuple returned  

                self.lines[0].array = array.array(str('d'), output)  

  

                if fsize > lsize:  # candle is present  

                    candleref = narrays[self.CANDLEREF] *  

self.CANDLEOVER  

                    output2 = candleref * (output / 100.0)  

                    self.lines[1].array = array.array(str('d'),  

output2)  

  

            else:  

                for i, o in enumerate(output):  

                    self.lines[i].array = array.array(str('d'), o)  

  

        def next(self):  

            # prepare the data arrays - single shot  

            size = self._lookback or len(self)  

            narrays = [np.array(x.lines[0].get(size=size)) for x in  

self.datas]  

  

            out = self._tafunc(*narrays, **self.p._getkwargs())  

  

            fsize = self.size()  

            lsize = fsize - self._iscandle  

            if lsize == 1:  # only 1 output, no tuple returned  
﻿                self.lines[0][0] = o = out[-1]  

  

                if fsize > lsize:  # candle is present  

                    candleref = narrays[self.CANDLEREF][-1] *  

self.CANDLEOVER  

                    o2 = candleref * (o / 100.0)  

                    self.lines[1][0] = o2  

  

            else:  

                for i, o in enumerate(out):  

                    self.lines[i][0] = o[-1]  

  

    # When importing the module do an automatic declaration of thed  

    tafunctions = talib.get_functions()  

    for tafunc in tafunctions:  

        _TALibIndicator._subclass(tafunc)  

  

    __all__ = tafunctions + ['MA_Type', '_TALibIndicator']  

  

  

  

##############################  

# 文件: timer.txt  

##############################  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  
﻿###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

  

import bisect  

import collections  

from datetime import date, datetime, timedelta  
﻿from itertools import islice  

  

from .feed import AbstractDataBase  

from .metabase import MetaParams  

from .utils import date2num, num2date  

from .utils.py3 import integer_types, range, with_metaclass  

from .utils import TIME_MAX  

  

  

__all__ = ['SESSION_TIME', 'SESSION_START', 'SESSION_END', 'Timer']  

  

SESSION_TIME, SESSION_START, SESSION_END = range(3)  

  

  

class Timer(with_metaclass(MetaParams, object)):  

    params = (  

         ('tid', None),  

         ('owner', None),  

         ('strats', False),  

         ('when', None),  

         ('offset', timedelta()),  

         ('repeat', timedelta()),  

         ('weekdays', []),  

         ('weekcarry', False),  

         ('monthdays', []),  

         ('monthcarry', True),  

         ('allow', None),  # callable that allows a timer to take place  
﻿         ('tzdata', None),  

         ('cheat', False),  

    )  

  

    SESSION_TIME, SESSION_START, SESSION_END = range(3)  

  

    def __init__(self, *args, **kwargs):  

        self.args = args  

        self.kwargs = kwargs  

  

    def start(self, data):  

        # write down the 'reset when' value  

        if not isinstance(self.p.when, integer_types):  # expect  

time/datetime  

            self._rstwhen = self.p.when  

            self._tzdata = self.p.tzdata  

        else:  

            self._tzdata = data if self.p.tzdata is None else  

self.p.tzdata  

  

            if self.p.when == SESSION_START:  

                self._rstwhen = self._tzdata.p.sessionstart  

            elif self.p.when == SESSION_END:  

                self._rstwhen = self._tzdata.p.sessionend  

  

        self._isdata = isinstance(self._tzdata, AbstractDataBase)  

        self._reset_when()  
﻿  

        self._nexteos = datetime.min  

        self._curdate = date.min  

  

        self._curmonth = -1  # non-existent month  

        self._monthmask = collections.deque()  

  

        self._curweek = -1  # non-existent week  

        self._weekmask = collections.deque()  

  

    def _reset_when(self, ddate=datetime.min):  

        self._when = self._rstwhen  

        self._dtwhen = self._dwhen = None  

  

        self._lastcall = ddate  

  

    def _check_month(self, ddate):  

        if not self.p.monthdays:  

            return True  

  

        mask = self._monthmask  

        daycarry = False  

        dmonth = ddate.month  

        if dmonth != self._curmonth:  

            self._curmonth = dmonth  # write down new month  

            daycarry = self.p.monthcarry and bool(mask)  

            self._monthmask = mask =  
﻿collections.deque(self.p.monthdays)  

  

        dday = ddate.day  

        dc = bisect.bisect_left(mask, dday)  # "left" for days before  

dday  

        daycarry = daycarry or (self.p.monthcarry and dc > 0)  

        if dc < len(mask):  

            curday = bisect.bisect_right(mask, dday, lo=dc) > 0  #  

check dday  

            dc += curday  

        else:  

            curday = False  

  

        while dc:  

            mask.popleft()  

            dc -= 1  

  

        return daycarry or curday  

  

    def _check_week(self, ddate=date.min):  

        if not self.p.weekdays:  

            return True  

  

        _, dweek, dwkday = ddate.isocalendar()  

  

        mask = self._weekmask  

        daycarry = False  
﻿        if dweek != self._curweek:  

            self._curweek = dweek  # write down new month  

            daycarry = self.p.weekcarry and bool(mask)  

            self._weekmask = mask = collections.deque(self.p.weekdays)  

  

        dc = bisect.bisect_left(mask, dwkday)  # "left" for days  

before dday  

        daycarry = daycarry or (self.p.weekcarry and dc > 0)  

        if dc < len(mask):  

            curday = bisect.bisect_right(mask, dwkday, lo=dc) > 0  #  

check dday  

            dc += curday  

        else:  

            curday = False  

  

        while dc:  

            mask.popleft()  

            dc -= 1  

  

        return daycarry or curday  

  

    def check(self, dt):  

        d = num2date(dt)  

        ddate = d.date()  

        if self._lastcall == ddate:  # not repeating, awaiting date  

change  

            return False  

  
﻿        if d > self._nexteos:  

            if self._isdata:  # eos provided by data  

                nexteos, _ = self._tzdata._getnexteos()  

            else:  # generic eos  

                nexteos = datetime.combine(ddate, TIME_MAX)  

            self._nexteos = nexteos  

            self._reset_when()  

  

        if ddate > self._curdate:  # day change  

            self._curdate = ddate  

            ret = self._check_month(ddate)  

            if ret:  

                ret = self._check_week(ddate)  

            if ret and self.p.allow is not None:  

                ret = self.p.allow(ddate)  

  

            if not ret:  

                self._reset_when(ddate)  # this day won't make it  

                return False  # timer target not met  

  

        # no day change or passed month, week and allow filters on  

date change  

        dwhen = self._dwhen  

        dtwhen = self._dtwhen  

        if dtwhen is None:  

            dwhen = datetime.combine(ddate, self._when)  

            if self.p.offset:  
﻿                dwhen += self.p.offset  

  

            self._dwhen = dwhen  

  

            if self._isdata:  

                self._dtwhen = dtwhen = self._tzdata.date2num(dwhen)  

            else:  

                self._dtwhen = dtwhen = date2num(dwhen,  

tz=self._tzdata)  

  

        if dt < dtwhen:  

            return False  # timer target not met  

  

        self.lastwhen = dwhen  # record when the last timer "when"  

happened  

  

        if not self.p.repeat:  # cannot repeat  

            self._reset_when(ddate)  # reset and mark as called on  

ddate  

        else:  

            if d > self._nexteos:  

                if self._isdata:  # eos provided by data  

                    nexteos, _ = self._tzdata._getnexteos()  

                else:  # generic eos  

                    nexteos = datetime.combine(ddate, TIME_MAX)  

  

                self._nexteos = nexteos  

            else:  
﻿                nexteos = self._nexteos  

  

            while True:  

                dwhen += self.p.repeat  

                if dwhen > nexteos:  # new schedule is beyone session  

                    self._reset_when(ddate)  # reset to original point  

                    break  

  

                if dwhen > d:  # gone over current datetime  

                    self._dtwhen = dtwhen = date2num(dwhen)  # float  

timestamp  

                    # Get the localized expected next time  

                    if self._isdata:  

                        self._dwhen = self._tzdata.num2date(dtwhen)  

                    else:  # assume pytz compatible or None  

                        self._dwhen = num2date(dtwhen,  

tz=self._tzdata)  

  

                    break  

  

        return True  # timer target was met  

  

  

  

##############################  

# 文件: trade.txt  

##############################  
﻿  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import itertools  
﻿  

from .utils import AutoOrderedDict  

from .utils.date import num2date  

from .utils.py3 import range  

  

  

class TradeHistory(AutoOrderedDict):  

    '''Represents the status and update event for each update a Trade  

has  

  

    This object is a dictionary which allows '.' notation  

  

    Attributes:  

      - ``status`` (``dict`` with '.' notation): Holds the resulting  

status of  

        an update event and has the following sub-attributes  

  

        - ``status`` (``int``): Trade status  

        - ``dt`` (``float``): float coded datetime  

        - ``barlen`` (``int``): number of bars the trade has been  

active  

        - ``size`` (``int``): current size of the Trade  

        - ``price`` (``float``): current price of the Trade  

        - ``value`` (``float``): current monetary value of the Trade  

        - ``pnl`` (``float``): current profit and loss of the Trade  

        - ``pnlcomm`` (``float``): current profit and loss minus  

commission  

  
﻿      - ``event`` (``dict`` with '.' notation): Holds the event update  

        - parameters  

  

        - ``order`` (``object``): the order which initiated  

the``update``  

        - ``size`` (``int``): size of the update  

        - ``price`` (``float``):price of the update  

        - ``commission`` (``float``): price of the update  

    '''  

  

    def __init__(self,  

                 status, dt, barlen, size, price, value, pnl, pnlcomm,  

tz, event=None):  

        '''Initializes the object to the current status of the  

Trade'''  

        super(TradeHistory, self).__init__()  

        self.status.status = status  

        self.status.dt = dt  

        self.status.barlen = barlen  

        self.status.size = size  

        self.status.price = price  

        self.status.value = value  

        self.status.pnl = pnl  

        self.status.pnlcomm = pnlcomm  

        self.status.tz = tz  

        if event is not None:  

            self.event = event  

  
﻿    def __reduce__(self):  

        return (self.__class__, (self.status.status, self.status.dt,  

self.status.barlen, self.status.size,  

                                 self.status.price, self.status.value,  

self.status.pnl, self.status.pnlcomm,  

                                 self.status.tz, self.event, ))  

  

    def doupdate(self, order, size, price, commission):  

        '''Used to fill the ``update`` part of the history entry'''  

        self.event.order = order  

        self.event.size = size  

        self.event.price = price  

        self.event.commission = commission  

  

        # Do not allow updates (avoids typing errors)  

        self._close()  

  

    def datetime(self, tz=None, naive=True):  

        '''Returns a datetime for the time the update event  

happened'''  

        return num2date(self.status.dt, tz or self.status.tz, naive)  

  

  

class Trade(object):  

    '''Keeps track of the life of an trade: size, price,  

    commission (and value?)  

  

    An trade starts at 0 can be increased and reduced and can  
﻿    be considered closed if it goes back to 0.  

  

    The trade can be long (positive size) or short (negative size)  

  

    An trade is not meant to be reversed (no support in the logic for  

it)  

  

    Member Attributes:  

  

      - ``ref``: unique trade identifier  

      - ``status`` (``int``): one of Created, Open, Closed  

      - ``tradeid``: grouping tradeid passed to orders during creation  

        The default in orders is 0  

      - ``size`` (``int``): current size of the trade  

      - ``price`` (``float``): current price of the trade  

      - ``value`` (``float``): current value of the trade  

      - ``commission`` (``float``): current accumulated commission  

      - ``pnl`` (``float``): current profit and loss of the trade  

(gross pnl)  

      - ``pnlcomm`` (``float``): current profit and loss of the trade  

minus  

        commission (net pnl)  

      - ``isclosed`` (``bool``): records if the last update closed  

(set size to  

        null the trade  

      - ``isopen`` (``bool``): records if any update has opened the  

trade  

      - ``justopened`` (``bool``): if the trade was just opened  
﻿      - ``baropen`` (``int``): bar in which this trade was opened  

  

      - ``dtopen`` (``float``): float coded datetime in which the  

trade was  

        opened  

  

        - Use method ``open_datetime`` to get a Python  

datetime.datetime  

          or use the platform provided ``num2date`` method  

  

      - ``barclose`` (``int``): bar in which this trade was closed  

  

      - ``dtclose`` (``float``): float coded datetime in which the  

trade was  

        closed  

  

        - Use method ``close_datetime`` to get a Python  

datetime.datetime  

          or use the platform provided ``num2date`` method  

  

      - ``barlen`` (``int``): number of bars this trade was open  

      - ``historyon`` (``bool``): whether history has to be recorded  

      - ``history`` (``list``): holds a list updated with each  

"update" event  

        containing the resulting status and parameters used in the  

update  

  

        The first entry in the history is the Opening Event  
﻿        The last entry in the history is the Closing Event  

  

    '''  

    refbasis = itertools.count(1)  

  

    status_names = ['Created', 'Open', 'Closed']  

    Created, Open, Closed = range(3)  

  

    def __str__(self):  

        toprint = (  

            'ref', 'data', 'tradeid',  

            'size', 'price', 'value', 'commission', 'pnl', 'pnlcomm',  

            'justopened', 'isopen', 'isclosed',  

            'baropen', 'dtopen', 'barclose', 'dtclose', 'barlen',  

            'historyon', 'history',  

            'status')  

  

        return '\n'.join(  

             (':'.join((x, str(getattr(self, x)))) for x in toprint)  

        )  

  

    def __init__(self, data=None, tradeid=0, historyon=False,  

                 size=0, price=0.0, value=0.0, commission=0.0):  

  

        self.ref = next(self.refbasis)  

        self.data = data  

        self.tradeid = tradeid  
﻿        self.size = size  

        self.price = price  

        self.value = value  

        self.commission = commission  

  

        self.pnl = 0.0  

        self.pnlcomm = 0.0  

  

        self.justopened = False  

        self.isopen = False  

        self.isclosed = False  

  

        self.baropen = 0  

        self.dtopen = 0.0  

        self.barclose = 0  

        self.dtclose = 0.0  

        self.barlen = 0  

  

        self.historyon = historyon  

        self.history = list()  

  

        self.status = self.Created  

  

    def __len__(self):  

        '''Absolute size of the trade'''  

        return abs(self.size)  

  
﻿    def __bool__(self):  

        '''Trade size is not 0'''  

        return self.size != 0  

  

    __nonzero__ = __bool__  

  

    def getdataname(self):  

        '''Shortcut to retrieve the name of the data this trade  

references'''  

        return self.data._name  

  

    def open_datetime(self, tz=None, naive=True):  

        '''Returns a datetime.datetime object with the datetime in  

which  

        the trade was opened  

        '''  

        return self.data.num2date(self.dtopen, tz=tz, naive=naive)  

  

    def close_datetime(self, tz=None, naive=True):  

        '''Returns a datetime.datetime object with the datetime in  

which  

        the trade was closed  

        '''  

        return self.data.num2date(self.dtclose, tz=tz, naive=naive)  

  

    def update(self, order, size, price, value, commission, pnl,  

               comminfo):  

        '''  
﻿        Updates the current trade. The logic does not check if the  

        trade is reversed, which is not conceptually supported by the  

        object.  

  

        If an update sets the size attribute to 0, "closed" will be  

        set to true  

  

        Updates may be received twice for each order, once for the  

existing  

        size which has been closed (sell undoing a buy) and a second  

time for  

        the the opening part (sell reversing a buy)  

  

        Args:  

            order: the order object which has (completely or  

partially)  

                generated this update  

            size (int): amount to update the order  

                if size has the same sign as the current trade a  

                position increase will happen  

                if size has the opposite sign as current op size a  

                reduction/close will happen  

  

            price (float): always be positive to ensure consistency  

            value (float): (unused) cost incurred in new size/price op  

                           Not used because the value is calculated  

for the  

                           trade  
﻿            commission (float): incurred commission in the new  

size/price op  

            pnl (float): (unused) generated by the executed part  

                         Not used because the trade has an independent  

pnl  

        '''  

        if not size:  

            return  # empty update, skip all other calculations  

  

        # Commission can only increase  

        self.commission += commission  

  

        # Update size and keep a reference for logic an calculations  

        oldsize = self.size  

        self.size += size  # size will carry the opposite sign if  

reducing  

  

        # Check if it has been currently opened  

        self.justopened = bool(not oldsize and size)  

  

        if self.justopened:  

            self.baropen = len(self.data)  

            self.dtopen = 0.0 if order.p.simulated else  

self.data.datetime[0]  

            self.long = self.size > 0  

  

        # Any size means the trade was opened  

        self.isopen = bool(self.size)  
﻿  

        # Update current trade length  

        self.barlen = len(self.data) - self.baropen  

  

        # record if the position was closed (set to null)  

        self.isclosed = bool(oldsize and not self.size)  

  

        # record last bar for the trade  

        if self.isclosed:  

            self.isopen = False  

            self.barclose = len(self.data)  

            self.dtclose = self.data.datetime[0]  

  

            self.status = self.Closed  

        elif self.isopen:  

            self.status = self.Open  

  

        if abs(self.size) > abs(oldsize):  

            # position increased (be it positive or negative)  

            # update the average price  

            self.price = (oldsize * self.price + size * price) /  

self.size  

            pnl = 0.0  

  

        else:  # abs(self.size) < abs(oldsize)  

            # position reduced/closed  

            pnl = comminfo.profitandloss(-size, self.price, price)  
﻿  

        self.pnl += pnl  

        self.pnlcomm = self.pnl - self.commission  

  

        self.value = comminfo.getvaluesize(self.size, self.price)  

  

        # Update the history if needed  

        if self.historyon:  

            dt0 = self.data.datetime[0] if not order.p.simulated else  

0.0  

            histentry = TradeHistory(  

                self.status, dt0, self.barlen,  

                self.size, self.price, self.value,  

                self.pnl, self.pnlcomm, self.data._tz)  

            histentry.doupdate(order, size, price, commission)  

            self.history.append(histentry)  

  

  

  

##############################  

# 文件: tradingcal.txt  

##############################  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  
﻿#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

  

from datetime import datetime, timedelta, time  

  

from .metabase import MetaParams  

from backtrader.utils.py3 import string_types, with_metaclass  
﻿from backtrader.utils import UTC  

  

__all__ = ['TradingCalendarBase', 'TradingCalendar',  

'PandasMarketCalendar']  

  

# Imprecission in the full time conversion to float would wrap over to  

next day  

# if microseconds is 999999 as defined in time.max  

_time_max = time(hour=23, minute=59, second=59, microsecond=999990)  

  

  

MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY =  

range(7)  

(ISONODAY, ISOMONDAY, ISOTUESDAY, ISOWEDNESDAY, ISOTHURSDAY,  

ISOFRIDAY,  

 ISOSATURDAY, ISOSUNDAY) = range(8)  

  

WEEKEND = [SATURDAY, SUNDAY]  

ISOWEEKEND = [ISOSATURDAY, ISOSUNDAY]  

ONEDAY = timedelta(days=1)  

  

  

class TradingCalendarBase(with_metaclass(MetaParams, object)):  

    def _nextday(self, day):  

        '''  

        Returns the next trading day (datetime/date instance) after  

``day``  

         (datetime/date instance) and the isocalendar components  
﻿  

        The return value is a tuple with 2 components: (nextday, (y,  

w, d))  

        '''  

        raise NotImplementedError  

  

    def schedule(self, day):  

        '''  

        Returns a tuple with the opening and closing times  

(``datetime.time``)  

        for the given ``date`` (``datetime/date`` instance)  

        '''  

        raise NotImplementedError  

  

    def nextday(self, day):  

        '''  

        Returns the next trading day (datetime/date instance) after  

``day``  

         (datetime/date instance)  

        '''  

        return self._nextday(day)[0]  # 1st ret elem is next day  

  

    def nextday_week(self, day):  

        '''  

        Returns the iso week number of the next trading day, given a  

``day``  

         (datetime/date) instance  

        '''  
﻿        self._nextday(day)[1][1]  # 2 elem is isocal / 0 - y, 1 - wk,  

2 - day  

  

    def last_weekday(self, day):  

        '''  

        Returns ``True`` if the given ``day`` (datetime/date) instance  

is the  

        last trading day of this week  

        '''  

        # Next day must be greater than day. If the week changes is  

enough for  

        # a week change even if the number is smaller (year change)  

        return day.isocalendar()[1] != self._nextday(day)[1][1]  

  

    def last_monthday(self, day):  

        '''  

        Returns ``True`` if the given ``day`` (datetime/date) instance  

is the  

        last trading day of this month  

        '''  

        # Next day must be greater than day. If the week changes is  

enough for  

        # a week change even if the number is smaller (year change)  

        return day.month != self._nextday(day)[0].month  

  

    def last_yearday(self, day):  

        '''  

        Returns ``True`` if the given ``day`` (datetime/date) instance  
﻿is the  

        last trading day of this month  

        '''  

        # Next day must be greater than day. If the week changes is  

enough for  

        # a week change even if the number is smaller (year change)  

        return day.year != self._nextday(day)[0].year  

  

  

class TradingCalendar(TradingCalendarBase):  

    '''  

    Wrapper of ``pandas_market_calendars`` for a trading calendar. The  

package  

    ``pandas_market_calendar`` must be installed  

  

    Params:  

  

      - ``open`` (default ``time.min``)  

  

        Regular start of the session  

  

      - ``close`` (default ``time.max``)  

  

        Regular end of the session  

  

      - ``holidays`` (default ``[]``)  

  
﻿        List of non-trading days (``datetime.datetime`` instances)  

  

      - ``earlydays`` (default ``[]``)  

  

        List of tuples determining the date and opening/closing times  

of days  

        which do not conform to the regular trading hours where each  

tuple has  

         (``datetime.datetime``, ``datetime.time``, ``datetime.time`` )  

  

      - ``offdays`` (default ``ISOWEEKEND``)  

  

        A list of weekdays in ISO format (Monday: 1 -> Sunday: 7) in  

which the  

        market doesn't trade. This is usually Saturday and Sunday and  

hence the  

        default  

  

    '''  

    params = (  

         ('open', time.min),  

         ('close', _time_max),  

         ('holidays', []),  # list of non trading days (date)  

         ('earlydays', []),  # list of tuples (date, opentime,  

closetime)  

         ('offdays', ISOWEEKEND),  # list of non trading (isoweekdays)  

    )  

  
﻿    def __init__(self):  

        self._earlydays = [x[0] for x in self.p.earlydays]  # speed up  

searches  

  

    def _nextday(self, day):  

        '''  

        Returns the next trading day (datetime/date instance) after  

``day``  

         (datetime/date instance) and the isocalendar components  

  

        The return value is a tuple with 2 components: (nextday, (y,  

w, d))  

        '''  

        while True:  

            day += ONEDAY  

            isocal = day.isocalendar()  

            if isocal[2] in self.p.offdays or day in self.p.holidays:  

                continue  

  

            return day, isocal  

  

    def schedule(self, day, tz=None):  

        '''  

        Returns the opening and closing times for the given ``day``.  

If the  

        method is called, the assumption is that ``day`` is an actual  

trading  

        day  
﻿  

        The return value is a tuple with 2 components: opentime,  

closetime  

        '''  

        while True:  

            dt = day.date()  

            try:  

                i = self._earlydays.index(dt)  

                o, c = self.p.earlydays[i][1:]  

            except ValueError:  # not found  

                o, c = self.p.open, self.p.close  

  

            closing = datetime.combine(dt, c)  

            if tz is not None:  

                closing = tz.localize(closing).astimezone(UTC)  

                closing = closing.replace(tzinfo=None)  

  

            if day > closing:  # current time over eos  

                day += ONEDAY  

                continue  

  

            opening = datetime.combine(dt, o)  

            if tz is not None:  

                opening = tz.localize(opening).astimezone(UTC)  

                opening = opening.replace(tzinfo=None)  

  

            return opening, closing  
﻿  

  

class PandasMarketCalendar(TradingCalendarBase):  

    '''  

    Wrapper of ``pandas_market_calendars`` for a trading calendar. The  

package  

    ``pandas_market_calendar`` must be installed  

  

    Params:  

  

      - ``calendar`` (default ``None``)  

  

        The param ``calendar`` accepts the following:  

  

        - string: the name of one of the calendars supported, for  

example  

          `NYSE`. The wrapper will attempt to get a calendar instance  

  

        - calendar instance: as returned by ``get_calendar('NYSE')``  

  

      - ``cachesize`` (default ``365``)  

  

        Number of days to cache in advance for lookup  

  

    See also:  

  

      - https://github.com/rsheftel/pandas_market_calendars  
﻿  

      - http://pandas-market-calendars.readthedocs.io/  

  

    '''  

    params = (  

         ('calendar', None),  # A pandas_market_calendars instance or  

exch name  

         ('cachesize', 365),  # Number of days to cache in advance  

    )  

  

    def __init__(self):  

        self._calendar = self.p.calendar  

  

        if isinstance(self._calendar, string_types):  # use passed mkt  

name  

            import pandas_market_calendars as mcal  

            self._calendar = mcal.get_calendar(self._calendar)  

  

        import pandas as pd  # guaranteed because of  

pandas_market_calendars  

        self.dcache = pd.DatetimeIndex([0.0])  

        self.idcache = pd.DataFrame(index=pd.DatetimeIndex([0.0]))  

        self.csize = timedelta(days=self.p.cachesize)  

  

    def _nextday(self, day):  

        '''  

        Returns the next trading day (datetime/date instance) after  

``day``  
﻿         (datetime/date instance) and the isocalendar components  

  

        The return value is a tuple with 2 components: (nextday, (y,  

w, d))  

        '''  

        day += ONEDAY  

        while True:  

            i = self.dcache.searchsorted(day)  

            if i == len(self.dcache):  

                # keep a cache of 1 year to speed up searching  

                self.dcache = self._calendar.valid_days(day, day +  

self.csize)  

                continue  

  

            d = self.dcache[i].to_pydatetime()  

            return d, d.isocalendar()  

  

    def schedule(self, day, tz=None):  

        '''  

        Returns the opening and closing times for the given ``day``.  

If the  

        method is called, the assumption is that ``day`` is an actual  

trading  

        day  

  

        The return value is a tuple with 2 components: opentime,  

closetime  

        '''  
﻿        while True:  

            i = self.idcache.index.searchsorted(day.date())  

            if i == len(self.idcache):  

                # keep a cache of 1 year to speed up searching  

                self.idcache = self._calendar.schedule(day, day +  

self.csize)  

                continue  

  

            st = (x.tz_localize(None) for x in self.idcache.iloc[i,  

0:2])  

            opening, closing = st  # Get utc naive times  

            if day > closing:  # passed time is over the sessionend  

                day += ONEDAY  # wrap over to next day  

                continue  

  

            return opening.to_pydatetime(), closing.to_pydatetime()  

  

  

  

##############################  

# 文件: version.txt  

##############################  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  
﻿# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

  

__version__ = '1.9.78.123'  

  

__btversion__ = tuple(int(x) for x in __version__.split('.'))  

  

  
﻿  

##############################  

# 文件: writer.txt  

##############################  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  
﻿from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import collections  

import io  

import itertools  

import sys  

  

try:  # For new Python versions  

    collectionsAbc = collections.abc  # collections.Iterable ->  

collections.abc.Iterable  

except AttributeError:  # For old Python versions  

    collectionsAbc = collections  # Используем  

collections.Iterable  

  

import backtrader as bt  

from backtrader.utils.py3 import (map, with_metaclass, string_types,  

                                  integer_types)  

  

  

class WriterBase(with_metaclass(bt.MetaParams, object)):  

    pass  

  

  

class WriterFile(WriterBase):  

    '''The system wide writer class.  

  
﻿    It can be parametrized with:  

  

      - ``out`` (default: ``sys.stdout``): output stream to write to  

  

        If a string is passed a filename with the content of the  

parameter will  

        be used.  

  

        If you wish to run with ``sys.stdout`` while doing  

multiprocess optimization, leave it as ``None``, which will  

        automatically initiate ``sys.stdout`` on the child processes.  

  

      - ``close_out``  (default: ``False``)  

  

        If ``out`` is a stream whether it has to be explicitly closed  

by the  

        writer  

  

      - ``csv`` (default: ``False``)  

  

        If a csv stream of the data feeds, strategies, observers and  

indicators  

        has to be written to the stream during execution  

  

        Which objects actually go into the csv stream can be  

controlled with  

        the ``csv`` attribute of each object (defaults to ``True`` for  

``data  
﻿        feeds`` and ``observers`` / False for ``indicators``)  

  

      - ``csv_filternan`` (default: ``True``) whether ``nan`` values  

have to be  

        purged out of the csv stream (replaced by an empty field)  

  

      - ``csv_counter`` (default: ``True``) if the writer shall keep  

and print  

        out a counter of the lines actually output  

  

      - ``indent`` (default: ``2``) indentation spaces for each level  

  

      - ``separators`` (default: ``['=', '-', '+', '*', '.', '~', '"',  

'^',  

        '#']``)  

  

        Characters used for line separators across  

section/sub(sub)sections  

  

      - ``seplen`` (default: ``79``)  

  

        total length of a line separator including indentation  

  

      - ``rounding`` (default: ``None``)  

  

        Number of decimal places to round floats down to. With  

``None`` no  

        rounding is performed  
﻿  

    '''  

    params = (  

         ('out', None),  

         ('close_out', False),  

  

         ('csv', False),  

         ('csvsep', ','),  

         ('csv_filternan', True),  

         ('csv_counter', True),  

  

         ('indent', 2),  

         ('separators', ['=', '-', '+', '*', '.', '~', '"', '^', '#']),  

         ('seplen', 79),  

         ('rounding', None),  

    )  

  

    def __init__(self):  

        self._len = itertools.count(1)  

        self.headers = list()  

        self.values = list()  

  

    def _start_output(self):  

        # open file if needed  

        if not hasattr(self, 'out') or not self.out:  

            if self.p.out is None:  

                self.out = sys.stdout  
﻿                self.close_out = False  

            elif isinstance(self.p.out, string_types):  

                self.out = open(self.p.out, 'w')  

                self.close_out = True  

            else:  

                self.out = self.p.out  

                self.close_out = self.p.close_out  

  

    def start(self):  

        self._start_output()  

  

        if self.p.csv:  

            self.writelineseparator()  

            self.writeiterable(self.headers, counter='Id')  

  

    def stop(self):  

        if self.close_out:  

            self.out.close()  

  

    def next(self):  

        if self.p.csv:  

            self.writeiterable(self.values, func=str,  

counter=next(self._len))  

            self.values = list()  

  

    def addheaders(self, headers):  

        if self.p.csv:  
﻿            self.headers.extend(headers)  

  

    def addvalues(self, values):  

        if self.p.csv:  

            if self.p.csv_filternan:  

                values = map(lambda x: x if x == x else '', values)  

            self.values.extend(values)  

  

    def writeiterable(self, iterable, func=None, counter=''):  

        if self.p.csv_counter:  

            iterable = itertools.chain([counter], iterable)  

  

        if func is not None:  

            iterable = map(lambda x: func(x), iterable)  

  

        line = self.p.csvsep.join(iterable)  

        self.writeline(line)  

  

    def writeline(self, line):  

        self.out.write(line + '\n')  

  

    def writelines(self, lines):  

        for l in lines:  

            self.out.write(l + '\n')  

  

    def writelineseparator(self, level=0):  

        sepnum = level % len(self.p.separators)  
﻿        separator = self.p.separators[sepnum]  

  

        line = ' ' * (level * self.p.indent)  

        line += separator * (self.p.seplen -  (level * self.p.indent))  

        self.writeline(line)  

  

    def writedict(self, dct, level=0, recurse=False):  

        if not recurse:  

            self.writelineseparator(level)  

  

        indent0 = level * self.p.indent  

        for key, val in dct.items():  

            kline = ' ' * indent0  

            if recurse:  

                kline += '- '  

  

            kline += str(key) + ':'  

  

            try:  

                sclass = issubclass(val, bt.LineSeries)  

            except TypeError:  

                sclass = False  

  

            if sclass:  

                kline += ' ' + val.__name__  

                self.writeline(kline)  

            elif isinstance(val, string_types):  
﻿                kline += ' ' + val  

                self.writeline(kline)  

            elif isinstance(val, integer_types):  

                kline += ' ' + str(val)  

                self.writeline(kline)  

            elif isinstance(val, float):  

                if self.p.rounding is not None:  

                    val = round(val, self.p.rounding)  

                kline += ' ' + str(val)  

                self.writeline(kline)  

            elif isinstance(val, dict):  

                if recurse:  

                    self.writelineseparator(level=level)  

                self.writeline(kline)  

                self.writedict(val, level=level + 1, recurse=True)  

            elif isinstance(val, (list, tuple,  

collectionsAbc.Iterable)):  # Для разных версий Python  

 будут вызываться разные функции  

                line = ', '.join(map(str, val))  

                self.writeline(kline + ' ' + line)  

            else:  

                kline += ' ' + str(val)  

                self.writeline(kline)  

  

  

class WriterStringIO(WriterFile):  

    params = (('out', io.StringIO),)  
﻿  

    def __init__(self):  

        super(WriterStringIO, self).__init__()  

  

    def _start_output(self):  

        super(WriterStringIO, self)._start_output()  

        self.out = self.out()  

  

    def stop(self):  

        super(WriterStringIO, self).stop()  

        # Leave the file positioned at the beginning  

        self.out.seek(0)  

  

  
