# 合并的 TXT 文件 - 创建于 2025-03-31 22:15:23  

# 源目录: D:\BT2025\bt_samples_py_txt  

  

  

====================================================================== 

==========  

# 文件: analyzer-annualreturn\analyzer-annualreturn.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  
﻿# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

  

# The above could be sent to an independent module  

import backtrader as bt  

import backtrader.feeds as btfeeds  

import backtrader.indicators as btind  

from backtrader.analyzers import (SQN, AnnualReturn, TimeReturn,  

SharpeRatio,  

                                  TradeAnalyzer)  

  

  

class LongShortStrategy(bt.Strategy):  

    '''This strategy buys/sells upong the close price crossing  

    upwards/downwards a Simple Moving Average.  

  

    It can be a long-only strategy by setting the param "onlylong" to  

True  

    '''  

    params = dict(  
﻿        period=15,  

        stake=1,  

        printout=False,  

        onlylong=False,  

        csvcross=False,  

    )  

  

    def start(self):  

        pass  

  

    def stop(self):  

        pass  

  

    def log(self, txt, dt=None):  

        if self.p.printout:  

            dt = dt or self.data.datetime[0]  

            dt = bt.num2date(dt)  

            print('%s, %s' % (dt.isoformat(), txt))  

  

    def __init__(self):  

        # To control operation entries  

        self.orderid = None  

  

        # Create SMA on 2nd data  

        sma = btind.MovAv.SMA(self.data, period=self.p.period)  

        # Create a CrossOver Signal from close an moving average  

        self.signal = btind.CrossOver(self.data.close, sma)  
﻿        self.signal.csv = self.p.csvcross  

  

    def next(self):  

        if self.orderid:  

            return  # if an order is active, no new orders are allowed  

  

        if self.signal > 0.0:  # cross upwards  

            if self.position:  

                self.log('CLOSE SHORT , %.2f' % self.data.close[0])  

                self.close()  

  

            self.log('BUY CREATE , %.2f' % self.data.close[0])  

            self.buy(size=self.p.stake)  

  

        elif self.signal < 0.0:  

            if self.position:  

                self.log('CLOSE LONG , %.2f' % self.data.close[0])  

                self.close()  

  

            if not self.p.onlylong:  

                self.log('SELL CREATE , %.2f' % self.data.close[0])  

                self.sell(size=self.p.stake)  

  

    def notify_order(self, order):  

        if order.status in [bt.Order.Submitted, bt.Order.Accepted]:  

            return  # Await further notifications  

  
﻿        if order.status == order.Completed:  

            if order.isbuy():  

                buytxt = 'BUY COMPLETE, %.2f' % order.executed.price  

                self.log(buytxt, order.executed.dt)  

            else:  

                selltxt = 'SELL COMPLETE, %.2f' % order.executed.price  

                self.log(selltxt, order.executed.dt)  

  

        elif order.status in [order.Expired, order.Canceled,  

order.Margin]:  

            self.log('%s ,' % order.Status[order.status])  

            pass  # Simply log  

  

        # Allow new orders  

        self.orderid = None  

  

    def notify_trade(self, trade):  

        if trade.isclosed:  

            self.log('TRADE PROFIT, GROSS %.2f, NET %.2f' %  

                      (trade.pnl, trade.pnlcomm))  

  

        elif trade.justopened:  

            self.log('TRADE OPENED, SIZE %2d' % trade.size)  

  

  

def runstrategy():  

    args = parse_args()  
﻿  

    # Create a cerebro  

    cerebro = bt.Cerebro()  

  

    # Get the dates from the args  

    fromdate = datetime.datetime.strptime(args.fromdate, '%Y-%m-%d')  

    todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

  

    # Create the 1st data  

    data = btfeeds.BacktraderCSVData(  

        dataname=args.data,  

        fromdate=fromdate,  

        todate=todate)  

  

    # Add the 1st data to cerebro  

    cerebro.adddata(data)  

  

    # Add the strategy  

    cerebro.addstrategy(LongShortStrategy,  

                        period=args.period,  

                        onlylong=args.onlylong,  

                        csvcross=args.csvcross,  

                        stake=args.stake)  

  

    # Add the commission - only stocks like a for each operation  

    cerebro.broker.setcash(args.cash)  

  
﻿    # Add the commission - only stocks like a for each operation  

    cerebro.broker.setcommission(commission=args.comm,  

                                 mult=args.mult,  

                                 margin=args.margin)  

  

    tframes = dict(  

        days=bt.TimeFrame.Days,  

        weeks=bt.TimeFrame.Weeks,  

        months=bt.TimeFrame.Months,  

        years=bt.TimeFrame.Years)  

  

    # Add the Analyzers  

    cerebro.addanalyzer(SQN)  

    if args.legacyannual:  

        cerebro.addanalyzer(AnnualReturn)  

        cerebro.addanalyzer(SharpeRatio, legacyannual=True)  

    else:  

        cerebro.addanalyzer(TimeReturn,  

timeframe=tframes[args.tframe])  

        cerebro.addanalyzer(SharpeRatio,  

timeframe=tframes[args.tframe])  

  

    cerebro.addanalyzer(TradeAnalyzer)  

  

    cerebro.addwriter(bt.WriterFile, csv=args.writercsv, rounding=4)  

  

    # And run it  
﻿    cerebro.run()  

  

    # Plot if requested  

    if args.plot:  

        cerebro.plot(numfigs=args.numfigs, volume=False, zdown=False)  

  

  

def parse_args():  

    parser = argparse.ArgumentParser(description='TimeReturn')  

  

    parser.add_argument('--data', '-d',  

                        default='../../datas/2005-2006-day-001.txt',  

                        help='data to add to the system')  

  

    parser.add_argument('--fromdate', '-f',  

                        default='2005-01-01',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', '-t',  

                        default='2006-12-31',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--period', default=15, type=int,  

                        help='Period to apply to the Simple Moving  

Average')  

  

    parser.add_argument('--onlylong', '-ol', action='store_true',  
﻿                        help='Do only long operations')  

  

    parser.add_argument('--writercsv', '-wcsv', action='store_true',  

                        help='Tell the writer to produce a csv  

stream')  

  

    parser.add_argument('--csvcross', action='store_true',  

                        help='Output the CrossOver signals to CSV')  

  

    group = parser.add_mutually_exclusive_group()  

    group.add_argument('--tframe', default='years', required=False,  

                       choices=['days', 'weeks', 'months', 'years'],  

                       help='TimeFrame for the returns/Sharpe  

calculations')  

  

    group.add_argument('--legacyannual', action='store_true',  

                       help='Use legacy annual return analyzer')  

  

    parser.add_argument('--cash', default=100000, type=int,  

                        help='Starting Cash')  

  

    parser.add_argument('--comm', default=2, type=float,  

                        help='Commission for operation')  

  

    parser.add_argument('--mult', default=10, type=int,  

                        help='Multiplier for futures')  

  
﻿    parser.add_argument('--margin', default=2000.0, type=float,  

                        help='Margin for each future')  

  

    parser.add_argument('--stake', default=1, type=int,  

                        help='Stake to apply in each operation')  

  

    parser.add_argument('--plot', '-p', action='store_true',  

                        help='Plot the read data')  

  

    parser.add_argument('--numfigs', '-n', default=1,  

                        help='Plot using numfigs figures')  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrategy()  

  

====================================================================== 

==========  

# 文件: bidask-to-ohlc\bidask-to-ohlc.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  
﻿#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,)  

#                        unicode_literals)  

  

import argparse  

import datetime  

  

import backtrader as bt  

import backtrader.feeds as btfeeds  
﻿  

  

class St(bt.Strategy):  

    def next(self):  

        print(','.join(str(x) for x in [  

            self.data.datetime.datetime(),  

            self.data.open[0], self.data.high[0],  

            self.data.high[0], self.data.close[0],  

            self.data.volume[0]]))  

  

  

def runstrat():  

    args = parse_args()  

  

    cerebro = bt.Cerebro()  

  

    data = btfeeds.GenericCSVData(  

        dataname=args.data,  

        dtformat='%d/%m/%y',  

        # tmformat='%H%M%S',  # already the default value  

        # datetime=0,  # position at default  

        time=1,  # position of time  

        open=5,  # position of open  

        high=5,  

        low=5,  

        close=5,  

        volume=7,  
﻿        openinterest=-1,  # -1 for not present  

        timeframe=bt.TimeFrame.Ticks)  

  

    cerebro.resampledata(data,  

                         timeframe=bt.TimeFrame.Ticks,  

                         compression=args.compression)  

  

    cerebro.addstrategy(St)  

  

    cerebro.run()  

    if args.plot:  

        cerebro.plot(style='bar')  

  

  

def parse_args():  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='BidAsk to OHLC')  

  

    parser.add_argument('--data', required=False,  

                        default='../../datas/bidask2.csv',  

                        help='Data file to be read in')  

  

    parser.add_argument('--compression', required=False, default=2,  

type=int,  

                        help='How much to compress the bars')  

  
﻿    parser.add_argument('--plot', required=False, action='store_true',  

                        help='Plot the vars')  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: bracket\bracket.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  
﻿# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

  

import argparse  

import datetime  

  

import backtrader as bt  

  

  

class St(bt.Strategy):  

    params = dict(  

        ma=bt.ind.SMA,  

        p1=5,  

        p2=15,  

        limit=0.005,  

        limdays=3,  
﻿        limdays2=1000,  

        hold=10,  

        usebracket=False,  # use order_target_size  

        switchp1p2=False,  # switch prices of order1 and order2  

    )  

  

    def notify_order(self, order):  

        print('{}: Order ref: {} / Type {} / Status {}'.format(  

            self.data.datetime.date(0),  

            order.ref, 'Buy' * order.isbuy() or 'Sell',  

            order.getstatusname()))  

  

        if order.status == order.Completed:  

            self.holdstart = len(self)  

  

        if not order.alive() and order.ref in self.orefs:  

            self.orefs.remove(order.ref)  

  

    def __init__(self):  

        ma1, ma2 = self.p.ma(period=self.p.p1),  

self.p.ma(period=self.p.p2)  

        self.cross = bt.ind.CrossOver(ma1, ma2)  

  

        self.orefs = list()  

  

        if self.p.usebracket:  

            print('-' * 5, 'Using buy_bracket')  
﻿  

    def next(self):  

        if self.orefs:  

            return  # pending orders do nothing  

  

        if not self.position:  

            if self.cross > 0.0:  # crossing up  

  

                close = self.data.close[0]  

                p1 = close * (1.0 - self.p.limit)  

                p2 = p1 - 0.02 * close  

                p3 = p1 + 0.02 * close  

  

                valid1 = datetime.timedelta(self.p.limdays)  

                valid2 = valid3 = datetime.timedelta(self.p.limdays2)  

  

                if self.p.switchp1p2:  

                    p1, p2 = p2, p1  

                    valid1, valid2 = valid2, valid1  

  

                if not self.p.usebracket:  

                    o1 = self.buy(exectype=bt.Order.Limit,  

                                  price=p1,  

                                  valid=valid1,  

                                  transmit=False)  

  

                    print('{}: Oref {} / Buy at {}'.format(  
﻿                        self.datetime.date(), o1.ref, p1))  

  

                    o2 = self.sell(exectype=bt.Order.Stop,  

                                   price=p2,  

                                   valid=valid2,  

                                   parent=o1,  

                                   transmit=False)  

  

                    print('{}: Oref {} / Sell Stop at {}'.format(  

                        self.datetime.date(), o2.ref, p2))  

  

                    o3 = self.sell(exectype=bt.Order.Limit,  

                                   price=p3,  

                                   valid=valid3,  

                                   parent=o1,  

                                   transmit=True)  

  

                    print('{}: Oref {} / Sell Limit at {}'.format(  

                        self.datetime.date(), o3.ref, p3))  

  

                    self.orefs = [o1.ref, o2.ref, o3.ref]  

  

                else:  

                    os = self.buy_bracket(  

                        price=p1, valid=valid1,  

                        stopprice=p2, stopargs=dict(valid=valid2),  

                        limitprice=p3, limitargs=dict(valid=valid3),)  
﻿  

                    self.orefs = [o.ref for o in os]  

  

        else:  # in the market  

            if (len(self) - self.holdstart) >= self.p.hold:  

                pass  # do nothing in this case  

  

  

def runstrat(args=None):  

    args = parse_args(args)  

  

    cerebro = bt.Cerebro()  

  

    # Data feed kwargs  

    kwargs = dict()  

  

    # Parse from/to-date  

    dtfmt, tmfmt = '%Y-%m-%d', 'T%H:%M:%S'  

    for a, d in ((getattr(args, x), x) for x in ['fromdate',  

'todate']):  

        if a:  

            strpfmt = dtfmt + tmfmt * ('T' in a)  

            kwargs[d] = datetime.datetime.strptime(a, strpfmt)  

  

    # Data feed  

    data0 = bt.feeds.BacktraderCSVData(dataname=args.data0, **kwargs)  

    cerebro.adddata(data0)  
﻿  

    # Broker  

    cerebro.broker = bt.brokers.BackBroker(**eval('dict(' +  

args.broker + ')'))  

  

    # Sizer  

    cerebro.addsizer(bt.sizers.FixedSize, **eval('dict(' + args.sizer  

+ ')'))  

  

    # Strategy  

    cerebro.addstrategy(St, **eval('dict(' + args.strat + ')'))  

  

    # Execute  

    cerebro.run(**eval('dict(' + args.cerebro + ')'))  

  

    if args.plot:  # Plot if requested to  

        cerebro.plot(**eval('dict(' + args.plot + ')'))  

  

  

def parse_args(pargs=None):  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description=(  

            'Sample Skeleton'  

        )  

    )  

  
﻿    parser.add_argument('--data0', default='../../datas/2005-2006-day- 

001.txt',  

                        required=False, help='Data to read in')  

  

    # Defaults for dates  

    parser.add_argument('--fromdate', required=False, default='',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--todate', required=False, default='',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--cerebro', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--broker', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--sizer', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--strat', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  
﻿    parser.add_argument('--plot', required=False, default='',  

                        nargs='?', const='{}',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    return parser.parse_args(pargs)  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: btfd\btfd.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  
﻿#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

# References:  

#  -  

https://www.reddit.com/r/algotrading/comments/5jez2b/can_anyone_replic 

ate_this_strategy/  

#  - http://dark-bid.com/BTFD-only-strategy-that-matters.html  

  

import argparse  

import datetime  

  

import backtrader as bt  

  

  

class ValueUnlever(bt.observers.Value):  
﻿    '''Extension of regular Value observer to add leveraged view'''  

    lines = ('value_lever', 'asset')  

    params = (('assetstart', 100000.0), ('lever', True),)  

  

    def next(self):  

        super(ValueUnlever, self).next()  

        if self.p.lever:  

            self.lines.value_lever[0] = self._owner.broker._valuelever  

  

        if len(self) == 1:  

            self.lines.asset[0] = self.p.assetstart  

        else:  

            change = self.data[0] / self.data[-1]  

            self.lines.asset[0] = change * self.lines.asset[-1]  

  

  

class St(bt.Strategy):  

    params = (  

         ('fall', -0.01),  

         ('hold', 2),  

         ('approach', 'highlow'),  

         ('target', 1.0),  

         ('prorder', False),  

         ('prtrade', False),  

         ('prdata', False),  

    )  

  
﻿    def __init__(self):  

        if self.p.approach == 'closeclose':  

            self.pctdown = self.data.close / self.data.close(-1) - 1.0  

        elif self.p.approach == 'openclose':  

            self.pctdown = self.data.close / self.data.open - 1.0  

        elif self.p.approach == 'highclose':  

            self.pctdown = self.data.close / self.data.high - 1.0  

        elif self.p.approach == 'highlow':  

            self.pctdown = self.data.low / self.data.high - 1.0  

  

    def next(self):  

        if self.position:  

            if len(self) == self.barexit:  

                self.close()  

                if self.p.prdata:  

                    print(','.join(str(x) for x in  

                                    ['DATA', 'CLOSE',  

                                     

self.data.datetime.date().isoformat(),  

                                    self.data.close[0],  

                                    float('NaN')]))  

        else:  

            if self.pctdown <= self.p.fall:  

                self.order_target_percent(target=self.p.target)  

                self.barexit = len(self) + self.p.hold  

  

                if self.p.prdata:  
﻿                    print(','.join(str(x) for x in  

                                    ['DATA', 'OPEN',  

                                     

self.data.datetime.date().isoformat(),  

                                    self.data.close[0],  

                                    self.pctdown[0]]))  

  

    def start(self):  

        if self.p.prtrade:  

            print(','.join(  

                 ['TRADE', 'Status', 'Date', 'Value', 'PnL',  

'Commission']))  

        if self.p.prorder:  

            print(','.join(  

                 ['ORDER', 'Type', 'Date', 'Price', 'Size',  

'Commission']))  

        if self.p.prdata:  

            print(','.join(['DATA', 'Action', 'Date', 'Price',  

'PctDown']))  

  

    def notify_order(self, order):  

        if order.status in [order.Margin, order.Rejected,  

order.Canceled]:  

            print('ORDER FAILED with status:', order.getstatusname())  

        elif order.status == order.Completed:  

            if self.p.prorder:  

                print(','.join(map(str, [  

                    'ORDER', 'BUY' * order.isbuy() or 'SELL',  
﻿                     

self.data.num2date(order.executed.dt).date().isoformat(),  

                    order.executed.price,  

                    order.executed.size,  

                    order.executed.comm,  

                ]  

                )))  

  

    def notify_trade(self, trade):  

        if not self.p.prtrade:  

            return  

  

        if trade.isclosed:  

            print(','.join(map(str, [  

                'TRADE', 'CLOSE',  

                self.data.num2date(trade.dtclose).date().isoformat(),  

                trade.value,  

                trade.pnl,  

                trade.commission,  

            ]  

            )))  

        elif trade.justopened:  

            print(','.join(map(str, [  

                'TRADE', 'OPEN',  

                self.data.num2date(trade.dtopen).date().isoformat(),  

                trade.value,  

                trade.pnl,  
﻿                trade.commission,  

            ]  

            )))  

  

  

def runstrat(args=None):  

    args = parse_args(args)  

  

    cerebro = bt.Cerebro()  

  

    # Data feed kwargs  

    kwargs = dict()  

  

    # Parse from/to-date  

    dtfmt, tmfmt = '%Y-%m-%d', 'T%H:%M:%S'  

    for a, d in ((getattr(args, x), x) for x in ['fromdate',  

'todate']):  

        kwargs[d] = datetime.datetime.strptime(a, dtfmt + tmfmt * ('T'  

in a))  

  

    if not args.offline:  

        YahooData = bt.feeds.YahooFinanceData  

    else:  

        YahooData = bt.feeds.YahooFinanceCSVData  

  

    # Data feed - no plot - observer will do the job  

    data = YahooData(dataname=args.data, plot=False, **kwargs)  
﻿    cerebro.adddata(data)  

  

    # Broker  

    cerebro.broker = bt.brokers.BackBroker(**eval('dict(' +  

args.broker + ')'))  

  

    # Add a commission  

    cerebro.broker.setcommission(**eval('dict(' + args.comminfo +  

')'))  

  

    # Strategy  

    cerebro.addstrategy(St, **eval('dict(' + args.strat + ')'))  

  

    # Add specific observer  

    cerebro.addobserver(ValueUnlever, **eval('dict(' +  

args.valobserver + ')'))  

  

    # Execute  

    cerebro.run(**eval('dict(' + args.cerebro + ')'))  

  

    if args.plot:  # Plot if requested to  

        cerebro.plot(**eval('dict(' + args.plot + ')'))  

  

  

def parse_args(pargs=None):  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description=(' - '.join([  
﻿            'BTFD',  

            'http://dark-bid.com/BTFD-only-strategy-that- 

matters.html',  

             ('https://www.reddit.com/r/algotrading/comments/5jez2b/'  

             'can_anyone_replicate_this_strategy/')]))  

        )  

  

    parser.add_argument('--offline', required=False,  

action='store_true',  

                        help='Use offline file with ticker name')  

  

    parser.add_argument('--data', required=False, default='^GSPC',  

                        metavar='TICKER', help='Yahoo ticker to  

download')  

  

    parser.add_argument('--fromdate', required=False, default='1990- 

01-01',  

                        metavar='YYYY-MM-DD[THH:MM:SS]',  

                        help='Starting date[time]')  

  

    parser.add_argument('--todate', required=False, default='2016-10- 

01',  

                        metavar='YYYY-MM-DD[THH:MM:SS]',  

                        help='Ending date[time]')  

  

    parser.add_argument('--cerebro', required=False,  

default='stdstats=False',  

                        metavar='kwargs', help='kwargs in key=value  

format')  
﻿  

    parser.add_argument('--broker', required=False,  

                        default='cash=100000.0, coc=True',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--valobserver', required=False,  

                        default='assetstart=100000.0',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--strat', required=False,  

                        default='approach="highlow"',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--comminfo', required=False,  

default='leverage=2.0',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--plot', required=False, default='',  

                        nargs='?', const='volume=False',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    return parser.parse_args(pargs)  

  
﻿  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: calendar-days\calendar-days.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  
﻿# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

  

import backtrader as bt  

import backtrader.indicators as btind  

import backtrader.feeds as btfeeds  

import backtrader.filters as btfilters  

  

  

def runstrat():  

    args = parse_args()  

  

    # Create a cerebro entity  

    cerebro = bt.Cerebro(stdstats=False)  

  

    # Add a strategy  

    cerebro.addstrategy(bt.Strategy)  

  

    # Get the dates from the args  
﻿    fromdate = datetime.datetime.strptime(args.fromdate, '%Y-%m-%d')  

    todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

  

    data = btfeeds.BacktraderCSVData(  

        dataname=args.data,  

        fromdate=fromdate,  

        todate=todate)  

  

    if args.calendar:  

        if args.fprice is not None:  

            args.fprice = float(args.fprice)  

  

        data.addfilter(  

            btfilters.CalendarDays,  

            fill_price=args.fprice,  

            fill_vol=args.fvol)  

  

    # Add the resample data instead of the original  

    cerebro.adddata(data)  

  

    # Add a simple moving average if requirested  

    if args.sma:  

        cerebro.addindicator(btind.SMA, period=args.period)  

  

    # Add a writer with CSV  

    if args.writer:  

        cerebro.addwriter(bt.WriterFile, csv=args.wrcsv)  
﻿  

    # Run over everything  

    cerebro.run()  

  

    # Plot if requested  

    if args.plot:  

        cerebro.plot(style='bar', numfigs=args.numfigs, volume=False)  

  

  

def parse_args():  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='Calendar Days Filter Sample')  

  

    parser.add_argument('--data', '-d',  

                        default='../../datas/2006-day-001.txt',  

                        help='data to add to the system')  

  

    parser.add_argument('--fromdate', '-f',  

                        default='2006-01-01',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', '-t',  

                        default='2006-12-31',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--calendar', '-cal', required=False,  
﻿                        action='store_true',  

                        help='Add a CalendarDays filter')  

  

    parser.add_argument('--fprice', required=False, default=None,  

                        help='Use as fill for price (None for previous  

close)')  

  

    parser.add_argument('--fvol', required=False, default=0.0,  

                        type=float,  

                        help='Use as fill volume for missing bar (def:  

0.0)')  

  

    parser.add_argument('--sma', required=False,  

                        action='store_true',  

                        help='Add a Simple Moving Average')  

  

    parser.add_argument('--period', default=15, type=int,  

                        help='Period to apply to the Simple Moving  

Average')  

  

    parser.add_argument('--writer', '-w', action='store_true',  

                        help='Add a writer to cerebro')  

  

    parser.add_argument('--wrcsv', '-wc', action='store_true',  

                        help='Enable CSV Output in the writer')  

  

    parser.add_argument('--plot', '-p', action='store_true',  

                        help='Plot the read data')  
﻿  

    parser.add_argument('--numfigs', '-n', default=1,  

                        help='Plot using numfigs figures')  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: calmar\calmar-test.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  
﻿# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

  

import argparse  

import datetime  

  

import backtrader as bt  

  

  

class St(bt.SignalStrategy):  

    params = (  

    )  

  

    def __init__(self):  

        ma1, ma2, = bt.ind.SMA(period=15), bt.ind.SMA(period=50)  
﻿        self.signal_add(bt.signal.SIGNAL_LONG, bt.ind.CrossOver(ma1,  

ma2))  

  

    def next2(self):  

        pass  

  

  

def runstrat(args=None):  

    args = parse_args(args)  

  

    cerebro = bt.Cerebro()  

  

    # Data feed kwargs  

    kwargs = dict()  

  

    # Parse from/to-date  

    dtfmt, tmfmt = '%Y-%m-%d', 'T%H:%M:%S'  

    for a, d in ((getattr(args, x), x) for x in ['fromdate',  

'todate']):  

        if a:  

            strpfmt = dtfmt + tmfmt * ('T' in a)  

            kwargs[d] = datetime.datetime.strptime(a, strpfmt)  

  

    # Data feed  

    data0 = bt.feeds.YahooFinanceCSVData(dataname=args.data0,  

**kwargs)  

    cerebro.adddata(data0)  

  
﻿    # Broker  

    cerebro.broker = bt.brokers.BackBroker(**eval('dict(' +  

args.broker + ')'))  

  

    cerebro.addanalyzer(bt.analyzers.Calmar)  

    # Sizer  

    cerebro.addsizer(bt.sizers.FixedSize, **eval('dict(' + args.sizer  

+ ')'))  

  

    # Strategy  

    cerebro.addstrategy(St, **eval('dict(' + args.strat + ')'))  

  

    # Execute  

    st0 = cerebro.run(**eval('dict(' + args.cerebro + ')'))[0]  

    i = 1  

    for k, v in st0.analyzers.calmar.get_analysis().items():  

        print(i, ': '.join((str(k), str(v))))  

        i += 1  

  

    if args.plot:  # Plot if requested to  

        cerebro.plot(**eval('dict(' + args.plot + ')'))  

  

  

def parse_args(pargs=None):  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description=(  
﻿            'Sample Skeleton'  

        )  

    )  

  

    parser.add_argument('--data0', default='../../datas/orcl-1995- 

2014.txt',  

                        required=False, help='Data to read in')  

  

    # Defaults for dates  

    parser.add_argument('--fromdate', required=False, default='',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--todate', required=False, default='',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--cerebro', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--broker', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--sizer', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  
﻿  

    parser.add_argument('--strat', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--plot', required=False, default='',  

                        nargs='?', const='{}',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    return parser.parse_args(pargs)  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: cheat-on-open\cheat-on-open.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  
﻿#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

  

import backtrader as bt  

  

  

class St(bt.Strategy):  
﻿    params = dict(  

        periods=[10, 30],  

        matype=bt.ind.SMA,  

    )  

  

    def __init__(self):  

        self.cheating = self.cerebro.p.cheat_on_open  

        mas = [self.p.matype(period=x) for x in self.p.periods]  

        self.signal = bt.ind.CrossOver(*mas)  

        self.order = None  

  

    def notify_order(self, order):  

        if order.status != order.Completed:  

            return  

  

        self.order = None  

        print('{} {} Executed at price {}'.format(  

            bt.num2date(order.executed.dt).date(),  

            'Buy' * order.isbuy() or 'Sell', order.executed.price)  

        )  

  

    def operate(self, fromopen):  

        if self.order is not None:  

            return  

        if self.position:  

            if self.signal < 0:  

                self.order = self.close()  
﻿        elif self.signal > 0:  

            print('{} Send Buy, fromopen {}, close {}'.format(  

                self.data.datetime.date(),  

                fromopen, self.data.close[0])  

            )  

            self.order = self.buy()  

  

    def next(self):  

        print('{} next, open {} close {}'.format(  

            self.data.datetime.date(),  

            self.data.open[0], self.data.close[0])  

        )  

  

        if self.cheating:  

            return  

        self.operate(fromopen=False)  

  

    def next_open(self):  

        if not self.cheating:  

            return  

        self.operate(fromopen=True)  

  

  

def runstrat(args=None):  

    args = parse_args(args)  

  

    cerebro = bt.Cerebro()  
﻿  

    # Data feed kwargs  

    kwargs = dict()  

  

    # Parse from/to-date  

    dtfmt, tmfmt = '%Y-%m-%d', 'T%H:%M:%S'  

    for a, d in ((getattr(args, x), x) for x in ['fromdate',  

'todate']):  

        if a:  

            strpfmt = dtfmt + tmfmt * ('T' in a)  

            kwargs[d] = datetime.datetime.strptime(a, strpfmt)  

  

    # Data feed  

    data0 = bt.feeds.BacktraderCSVData(dataname=args.data0, **kwargs)  

    cerebro.adddata(data0)  

  

    # Broker  

    cerebro.broker = bt.brokers.BackBroker(**eval('dict(' +  

args.broker + ')'))  

  

    # Sizer  

    cerebro.addsizer(bt.sizers.FixedSize, **eval('dict(' + args.sizer  

+ ')'))  

  

    # Strategy  

    cerebro.addstrategy(St, **eval('dict(' + args.strat + ')'))  

  

    # Execute  
﻿    cerebro.run(**eval('dict(' + args.cerebro + ')'))  

  

    if args.plot:  # Plot if requested to  

        cerebro.plot(**eval('dict(' + args.plot + ')'))  

  

  

def parse_args(pargs=None):  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description=(  

            'Cheat-On-Open Sample'  

        )  

    )  

  

    parser.add_argument('--data0', default='../../datas/2005-2006-day- 

001.txt',  

                        required=False, help='Data to read in')  

  

    # Defaults for dates  

    parser.add_argument('--fromdate', required=False, default='',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--todate', required=False, default='',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--cerebro', required=False, default='',  
﻿                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--broker', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--sizer', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--strat', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--plot', required=False, default='',  

                        nargs='?', const='{}',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    return parser.parse_args(pargs)  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  
﻿# 文件: commission-schemes\commission-schemes.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  
﻿                        unicode_literals)  

  

import argparse  

import datetime  

  

import backtrader as bt  

import backtrader.feeds as btfeeds  

import backtrader.indicators as btind  

  

  

class SMACrossOver(bt.Strategy):  

    params = (  

         ('stake', 1),  

         ('period', 30),  

    )  

  

    def log(self, txt, dt=None):  

        ''' Logging function fot this strategy'''  

        dt = dt or self.datas[0].datetime.date(0)  

        print('%s, %s' % (dt.isoformat(), txt))  

  

    def notify_order(self, order):  

        if order.status in [order.Submitted, order.Accepted]:  

            # Buy/Sell order submitted/accepted to/by broker - Nothing  

to do  

            return  

  
﻿        # Check if an order has been completed  

        # Attention: broker could reject order if not enougth cash  

        if order.status in [order.Completed, order.Canceled,  

order.Margin]:  

            if order.isbuy():  

                self.log(  

                    'BUY EXECUTED, Price: %.2f, Cost: %.2f,  

Comm %.2f' %  

                     (order.executed.price,  

                     order.executed.value,  

                     order.executed.comm))  

            else:  # Sell  

                self.log('SELL EXECUTED, Price: %.2f, Cost: %.2f,  

Comm %.2f' %  

                          (order.executed.price,  

                          order.executed.value,  

                          order.executed.comm))  

  

    def notify_trade(self, trade):  

        if trade.isclosed:  

            self.log('TRADE PROFIT, GROSS %.2f, NET %.2f' %  

                      (trade.pnl, trade.pnlcomm))  

  

    def __init__(self):  

        sma = btind.SMA(self.data, period=self.p.period)  

        # > 0 crossing up / < 0 crossing down  

        self.buysell_sig = btind.CrossOver(self.data, sma)  

  
﻿    def next(self):  

        if self.buysell_sig > 0:  

            self.log('BUY CREATE, %.2f' % self.data.close[0])  

            self.buy(size=self.p.stake)  # keep order ref to avoid 2nd  

orders  

  

        elif self.position and self.buysell_sig < 0:  

            self.log('SELL CREATE, %.2f' % self.data.close[0])  

            self.sell(size=self.p.stake)  

  

  

def runstrategy():  

    args = parse_args()  

  

    # Create a cerebro  

    cerebro = bt.Cerebro()  

  

    # Get the dates from the args  

    fromdate = datetime.datetime.strptime(args.fromdate, '%Y-%m-%d')  

    todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

  

    # Create the 1st data  

    data = btfeeds.BacktraderCSVData(  

        dataname=args.data,  

        fromdate=fromdate,  

        todate=todate)  

  
﻿    # Add the 1st data to cerebro  

    cerebro.adddata(data)  

  

    # Add a strategy  

    cerebro.addstrategy(SMACrossOver, period=args.period,  

stake=args.stake)  

  

    # Add the commission - only stocks like a for each operation  

    cerebro.broker.setcash(args.cash)  

  

    commtypes = dict(  

        none=None,  

        perc=bt.CommInfoBase.COMM_PERC,  

        fixed=bt.CommInfoBase.COMM_FIXED)  

  

    # Add the commission - only stocks like a for each operation  

    cerebro.broker.setcommission(commission=args.comm,  

                                 mult=args.mult,  

                                 margin=args.margin,  

                                 percabs=not args.percrel,  

                                 commtype=commtypes[args.commtype],  

                                 stocklike=args.stocklike)  

  

    # And run it  

    cerebro.run()  

  

    # Plot if requested  
﻿    if args.plot:  

        cerebro.plot(numfigs=args.numfigs, volume=False)  

  

  

def parse_args():  

    parser = argparse.ArgumentParser(  

        description='Commission schemes',  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,)  

  

    parser.add_argument('--data', '-d',  

                        default='../../datas/2006-day-001.txt',  

                        help='data to add to the system')  

  

    parser.add_argument('--fromdate', '-f',  

                        default='2006-01-01',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', '-t',  

                        default='2006-12-31',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--stake', default=1, type=int,  

                        help='Stake to apply in each operation')  

  

    parser.add_argument('--period', default=30, type=int,  

                        help='Period to apply to the Simple Moving  

Average')  
﻿  

    parser.add_argument('--cash', default=10000.0, type=float,  

                        help='Starting Cash')  

  

    parser.add_argument('--comm', default=2.0, type=float,  

                        help=('Commission factor for operation, either  

a'  

                              'percentage or a per stake unit absolute  

value'))  

  

    parser.add_argument('--mult', default=10, type=int,  

                        help='Multiplier for operations calculation')  

  

    parser.add_argument('--margin', default=2000.0, type=float,  

                        help='Margin for futures-like operations')  

  

    parser.add_argument('--commtype', required=False, default='none',  

                        choices=['none', 'perc', 'fixed'],  

                        help=('Commission - choose none for the old'  

                              ' CommissionInfo behavior'))  

  

    parser.add_argument('--stocklike', required=False,  

action='store_true',  

                        help=('If the operation is for stock-like  

assets or'  

                              'future-like assets'))  

  

    parser.add_argument('--percrel', required=False,  
﻿action='store_true',  

                        help=('If perc is expressed in relative xx%  

rather'  

                              'than absolute value 0.xx'))  

  

    parser.add_argument('--plot', '-p', action='store_true',  

                        help='Plot the read data')  

  

    parser.add_argument('--numfigs', '-n', default=1,  

                        help='Plot using numfigs figures')  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrategy()  

  

====================================================================== 

==========  

# 文件: credit-interest\credit-interest.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  
﻿# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import collections  

import datetime  

import itertools  

  

import backtrader as bt  
﻿  

  

class SMACrossOver(bt.Signal):  

    params = (('p1', 10), ('p2', 30),)  

  

    def __init__(self):  

        sma1 = bt.indicators.SMA(period=self.p.p1)  

        sma2 = bt.indicators.SMA(period=self.p.p2)  

        self.lines.signal = bt.indicators.CrossOver(sma1, sma2)  

  

  

class NoExit(bt.Signal):  

    def next(self):  

        self.lines.signal[0] = 0.0  

  

  

class St(bt.SignalStrategy):  

    opcounter = itertools.count(1)  

  

    def notify_order(self, order):  

        if order.status == bt.Order.Completed:  

            t = ''  

            t += '{:02d}'.format(next(self.opcounter))  

            t += ' {}'.format(order.data.datetime.datetime())  

            t += ' BUY ' * order.isbuy() or ' SELL'  

            t += ' Size: {:+d} / Price: {:.2f}'  

            print(t.format(order.executed.size, order.executed.price))  
﻿  

    def notify_trade(self, trade):  

        if trade.isclosed:  

            print('Trade closed with P&L: Gross {} Net {}'.format(  

                trade.pnl, trade.pnlcomm))  

  

  

def runstrat(args=None):  

    args = parse_args(args)  

  

    cerebro = bt.Cerebro()  

    cerebro.broker.set_cash(args.cash)  

    cerebro.broker.set_int2pnl(args.no_int2pnl)  

  

    dkwargs = dict()  

    if args.fromdate is not None:  

        fromdate = datetime.datetime.strptime(args.fromdate,  

'%Y-%m-%d')  

        dkwargs['fromdate'] = fromdate  

  

    if args.todate is not None:  

        todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

        dkwargs['todate'] = todate  

  

    # if dataset is None, args.data has been given  

    data = bt.feeds.BacktraderCSVData(dataname=args.data, **dkwargs)  

    cerebro.adddata(data)  
﻿  

    cerebro.signal_strategy(St)  

    cerebro.addsizer(bt.sizers.FixedSize, stake=args.stake)  

  

    sigtype = bt.signal.SIGNAL_LONGSHORT  

    if args.long:  

        sigtype = bt.signal.SIGNAL_LONG  

    elif args.short:  

        sigtype = bt.signal.SIGNAL_SHORT  

  

    cerebro.add_signal(sigtype,  

                       SMACrossOver, p1=args.period1, p2=args.period2)  

  

    if args.no_exit:  

        if args.long:  

            cerebro.add_signal(bt.signal.SIGNAL_LONGEXIT, NoExit)  

        elif args.short:  

            cerebro.add_signal(bt.signal.SIGNAL_SHORTEXIT, NoExit)  

  

    comminfo = bt.CommissionInfo(  

        mult=args.mult,  

        margin=args.margin,  

        stocklike=args.stocklike,  

        interest=args.interest,  

        interest_long=args.interest_long)  

  

    cerebro.broker.addcommissioninfo(comminfo)  
﻿  

    cerebro.run()  

    if args.plot:  

        pkwargs = dict(style='bar')  

        if args.plot is not True:  # evals to True but is not True  

            npkwargs = eval('dict(' + args.plot + ')')  # args were  

passed  

            pkwargs.update(npkwargs)  

  

        cerebro.plot(**pkwargs)  

  

  

def parse_args(pargs=None):  

  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='Sample for Slippage')  

  

    parser.add_argument('--data', required=False,  

                        default='../../datas/2005-2006-day-001.txt',  

                        help='Specific data to be read in')  

  

    parser.add_argument('--fromdate', required=False, default=None,  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', required=False, default=None,  

                        help='Ending date in YYYY-MM-DD format')  
﻿  

    parser.add_argument('--cash', required=False, action='store',  

                        type=float, default=50000,  

                        help=('Cash to start with'))  

  

    parser.add_argument('--period1', required=False, action='store',  

                        type=int, default=10,  

                        help=('Fast moving average period'))  

  

    parser.add_argument('--period2', required=False, action='store',  

                        type=int, default=30,  

                        help=('Slow moving average period'))  

  

    parser.add_argument('--interest', required=False, action='store',  

                        default=0.0, type=float,  

                        help=('Activate credit interest rate'))  

  

    parser.add_argument('--no-int2pnl', required=False,  

action='store_false',  

                        help=('Do not assign interest to pnl'))  

  

    parser.add_argument('--interest_long', required=False,  

action='store_true',  

                        help=('Credit interest rate for long  

positions'))  

  

    pgroup = parser.add_mutually_exclusive_group()  

    pgroup.add_argument('--long', required=False, action='store_true',  
﻿                        help=('Do a long only strategy'))  

  

    pgroup.add_argument('--short', required=False,  

action='store_true',  

                        help=('Do a long only strategy'))  

  

    parser.add_argument('--no-exit', required=False,  

action='store_true',  

                        help=('The 1st taken position will not be  

exited'))  

  

    parser.add_argument('--stocklike', required=False,  

action='store_true',  

                        help=('Consider the asset to be stocklike'))  

  

    parser.add_argument('--margin', required=False, action='store',  

                        default=0.0, type=float,  

                        help=('Margin for future like instruments'))  

  

    parser.add_argument('--mult', required=False, action='store',  

                        default=1.0, type=float,  

                        help=('Multiplier for future like  

instruments'))  

  

    parser.add_argument('--stake', required=False, action='store',  

                        default=10, type=int,  

                        help=('Stake to apply'))  

  
﻿    # Plot options  

    parser.add_argument('--plot', '-p', nargs='?', required=False,  

                        metavar='kwargs', const=True,  

                        help=('Plot the read data applying any kwargs  

passed\n'  

                              '\n'  

                              'For example:\n'  

                              '\n'  

                              '  --plot style="candle" (to plot  

candles)\n'))  

  

    if pargs is not None:  

        return parser.parse_args(pargs)  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: data-bid-ask\bidask.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  
﻿###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

  

import backtrader as bt  

import backtrader.feeds as btfeeds  
﻿import backtrader.indicators as btind  

  

  

class BidAskCSV(btfeeds.GenericCSVData):  

    linesoverride = True  # discard usual OHLC structure  

    # datetime must be present and last  

    lines = ('bid', 'ask', 'datetime')  

    # datetime (always 1st) and then the desired order for  

    params = (  

        # (datetime, 0), # inherited from parent class  

         ('bid', 1),  # default field pos 1  

         ('ask', 2),  # default field pos 2  

    )  

  

  

class St(bt.Strategy):  

    params = (('sma', False), ('period', 3))  

  

    def __init__(self):  

        if self.p.sma:  

            self.sma = btind.SMA(self.data, period=self.p.period)  

  

    def next(self):  

        dtstr = self.data.datetime.datetime().isoformat()  

        txt = '%4d: %s - Bid %.4f - %.4f Ask' % (  

             (len(self), dtstr, self.data.bid[0], self.data.ask[0]))  

  
﻿        if self.p.sma:  

            txt += ' - SMA: %.4f' % self.sma[0]  

        print(txt)  

  

  

def parse_args():  

    parser = argparse.ArgumentParser(  

        description='Bid/Ask Line Hierarchy',  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

    )  

  

    parser.add_argument('--data', '-d', action='store',  

                        required=False,  

default='../../datas/bidask.csv',  

                        help='data to add to the system')  

  

    parser.add_argument('--dtformat', '-dt',  

                        required=False, default='%m/%d/%Y %H:%M:%S',  

                        help='Format of datetime in input')  

  

    parser.add_argument('--sma', '-s', action='store_true',  

                        required=False,  

                        help='Add an SMA to the mix')  

  

    parser.add_argument('--period', '-p', action='store',  

                        required=False, default=5, type=int,  

                        help='Period for the sma')  
﻿  

    return parser.parse_args()  

  

  

def runstrategy():  

    args = parse_args()  

  

    cerebro = bt.Cerebro()  # Create a cerebro  

  

    data = BidAskCSV(dataname=args.data, dtformat=args.dtformat)  

    cerebro.adddata(data)  # Add the 1st data to cerebro  

    # Add the strategy to cerebro  

    cerebro.addstrategy(St, sma=args.sma, period=args.period)  

    cerebro.run()  

  

  

if __name__ == '__main__':  

    runstrategy()  

  

====================================================================== 

==========  

# 文件: data-filler\data-filler.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  
﻿###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

import math  

  
﻿# The above could be sent to an independent module  

import backtrader as bt  

import backtrader.feeds as btfeeds  

import backtrader.utils.flushfile  

import backtrader.filters as btfilters  

  

from relativevolume import RelativeVolume  

  

  

def runstrategy():  

    args = parse_args()  

  

    # Create a cerebro  

    cerebro = bt.Cerebro()  

  

    # Get the dates from the args  

    fromdate = datetime.datetime.strptime(args.fromdate, '%Y-%m-%d')  

    todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

  

    # Get the session times to pass them to the indicator  

    # datetime.time has no strptime ...  

    dtstart = datetime.datetime.strptime(args.tstart, '%H:%M')  

    dtend = datetime.datetime.strptime(args.tend, '%H:%M')  

  

    # Create the 1st data  

    data = btfeeds.BacktraderCSVData(  

        dataname=args.data,  
﻿        fromdate=fromdate,  

        todate=todate,  

        timeframe=bt.TimeFrame.Minutes,  

        compression=1,  

        sessionstart=dtstart,  # internally just the "time" part will  

be used  

        sessionend=dtend,  # internally just the "time" part will be  

used  

    )  

  

    if args.filter:  

        data.addfilter(btfilters.SessionFilter)  

  

    if args.filler:  

        data.addfilter(btfilters.SessionFiller, fill_vol=args.fvol)  

  

    # Add the data to cerebro  

    cerebro.adddata(data)  

  

    if args.relvol:  

        # Calculate backward period - tend tstart are in same day  

        # + 1 to include last moment of the interval dstart <-> dtend  

        td = ((dtend - dtstart).seconds // 60) + 1  

        cerebro.addindicator(RelativeVolume,  

                             period=td,  

                             volisnan=math.isnan(args.fvol))  

  
﻿    # Add an empty strategy  

    cerebro.addstrategy(bt.Strategy)  

  

    # Add a writer with CSV  

    if args.writer:  

        cerebro.addwriter(bt.WriterFile, csv=args.wrcsv)  

  

    # And run it - no trading - disable stdstats  

    cerebro.run(stdstats=False)  

  

    # Plot if requested  

    if args.plot:  

        cerebro.plot(numfigs=args.numfigs, volume=True)  

  

  

def parse_args():  

    parser = argparse.ArgumentParser(  

        description='DataFilter/DataFiller Sample')  

  

    parser.add_argument('--data', '-d',  

                        default='../../datas/2006-01-02-volume-min- 

001.txt',  

                        help='data to add to the system')  

  

    parser.add_argument('--filter', '-ft', action='store_true',  

                        help='Filter using session start/end times')  

  
﻿    parser.add_argument('--filler', '-fl', action='store_true',  

                        help='Fill missing bars inside start/end  

times')  

  

    parser.add_argument('--fvol', required=False, default=0.0,  

                        type=float,  

                        help='Use as fill volume for missing bar (def:  

0.0)')  

  

    parser.add_argument('--tstart', '-ts',  

                        # default='09:14:59',  

                        # help='Start time for the Session Filter  

(%H:%M:%S)')  

                        default='09:15',  

                        help='Start time for the Session Filter  

(HH:MM)')  

  

    parser.add_argument('--tend', '-te',  

                        # default='17:15:59',  

                        # help='End time for the Session Filter  

(%H:%M:%S)')  

                        default='17:15',  

                        help='End time for the Session Filter  

(HH:MM)')  

  

    parser.add_argument('--relvol', '-rv', action='store_true',  

                        help='Add relative volume indicator')  

  
﻿    parser.add_argument('--fromdate', '-f',  

                        default='2006-01-01',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', '-t',  

                        default='2006-12-31',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--writer', '-w', action='store_true',  

                        help='Add a writer to cerebro')  

  

    parser.add_argument('--wrcsv', '-wc', action='store_true',  

                        help='Enable CSV Output in the writer')  

  

    parser.add_argument('--plot', '-p', action='store_true',  

                        help='Plot the read data')  

  

    parser.add_argument('--numfigs', '-n', default=1,  

                        help='Plot using numfigs figures')  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrategy()  

  

====================================================================== 
﻿==========  

# 文件: data-filler\relativevolume.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  
﻿from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

  

import backtrader as bt  

import backtrader.indicators as btind  

  

  

class RelativeVolume(bt.Indicator):  

    csv = True  # show up in csv output (default for indicators is  

False)  

  

    lines = ('relvol',)  

    params = (  

         ('period', 20),  

         ('volisnan', True),  

    )  

  

    def __init__(self):  

        if self.p.volisnan:  

            # if missing volume will be NaN, do a simple division  

            # the end result for missing volumes will also be NaN  

            relvol = self.data.volume(-self.p.period) /  

self.data.volume  

        else:  

            # Else do a controlled Div with a built-in function  

            relvol = bt.DivByZero(  
﻿                self.data.volume(-self.p.period),  

                self.data.volume,  

                zero=0.0)  

  

        self.lines.relvol = relvol  

  

====================================================================== 

==========  

# 文件: data-multitimeframe\data-multitimeframe.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  
﻿#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

  

import backtrader as bt  

import backtrader.feeds as btfeeds  

import backtrader.indicators as btind  

from backtrader import ResamplerDaily, ResamplerWeekly,  

ResamplerMonthly  

from backtrader import ReplayerDaily, ReplayerWeekly, ReplayerMonthly  

from backtrader.utils import flushfile  

  

  

class SMAStrategy(bt.Strategy):  

    params = (  

         ('period', 10),  

         ('onlydaily', False),  

    )  

  

    def __init__(self):  
﻿        self.sma_small_tf = btind.SMA(self.data, period=self.p.period)  

        bt.indicators.MACD(self.data0)  

  

        if not self.p.onlydaily:  

            self.sma_large_tf = btind.SMA(self.data1,  

period=self.p.period)  

            bt.indicators.MACD(self.data1)  

  

    def prenext(self):  

        self.next()  

  

    def nextstart(self):  

        print('--------------------------------------------------')  

        print('nextstart called with len', len(self))  

        print('--------------------------------------------------')  

  

        super(SMAStrategy, self).nextstart()  

  

    def next(self):  

        print('Strategy:', len(self))  

  

        txt = list()  

        txt.append('Data0')  

        txt.append('%04d' % len(self.data0))  

        dtfmt = '%Y-%m-%dT%H:%M:%S.%f'  

        txt.append('{:f}'.format(self.data.datetime[0]))  

        txt.append('%s' %  
﻿self.data.datetime.datetime(0).strftime(dtfmt))  

        # txt.append('{:f}'.format(self.data.open[0]))  

        # txt.append('{:f}'.format(self.data.high[0]))  

        # txt.append('{:f}'.format(self.data.low[0]))  

        txt.append('{:f}'.format(self.data.close[0]))  

        # txt.append('{:6d}'.format(int(self.data.volume[0])))  

        # txt.append('{:d}'.format(int(self.data.openinterest[0])))  

        # txt.append('{:f}'.format(self.sma_small[0]))  

        print(', '.join(txt))  

  

        if len(self.datas) > 1 and len(self.data1):  

            txt = list()  

            txt.append('Data1')  

            txt.append('%04d' % len(self.data1))  

            dtfmt = '%Y-%m-%dT%H:%M:%S.%f'  

            txt.append('{:f}'.format(self.data1.datetime[0]))  

            txt.append('%s' %  

self.data1.datetime.datetime(0).strftime(dtfmt))  

            # txt.append('{}'.format(self.data1.open[0]))  

            # txt.append('{}'.format(self.data1.high[0]))  

            # txt.append('{}'.format(self.data1.low[0]))  

            txt.append('{}'.format(self.data1.close[0]))  

            # txt.append('{}'.format(self.data1.volume[0]))  

            # txt.append('{}'.format(self.data1.openinterest[0]))  

            # txt.append('{}'.format(float('NaN')))  

            print(', '.join(txt))  

  
﻿  

def runstrat():  

    args = parse_args()  

  

    # Create a cerebro entity  

    cerebro = bt.Cerebro()  

  

    # Add a strategy  

    if not args.indicators:  

        cerebro.addstrategy(bt.Strategy)  

    else:  

        cerebro.addstrategy(  

            SMAStrategy,  

  

            # args for the strategy  

            period=args.period,  

            onlydaily=args.onlydaily,  

        )  

  

    # Load the Data  

    datapath = args.dataname or '../../datas/2006-day-001.txt'  

    data = btfeeds.BacktraderCSVData(  

        dataname=datapath)  

  

    tframes = dict(  

        daily=bt.TimeFrame.Days,  

        weekly=bt.TimeFrame.Weeks,  
﻿        monthly=bt.TimeFrame.Months)  

  

    # Handy dictionary for the argument timeframe conversion  

    # Resample the data  

    if args.noresample:  

        datapath = args.dataname2 or '../../datas/2006-week-001.txt'  

        data2 = btfeeds.BacktraderCSVData(  

            dataname=datapath)  

    else:  

        if args.oldrs:  

            if args.replay:  

                data2 = bt.DataReplayer(  

                    dataname=data,  

                    timeframe=tframes[args.timeframe],  

                    compression=args.compression)  

            else:  

                data2 = bt.DataResampler(  

                    dataname=data,  

                    timeframe=tframes[args.timeframe],  

                    compression=args.compression)  

  

        else:  

            data2 = bt.DataClone(dataname=data)  

            if args.replay:  

                if args.timeframe == 'daily':  

                    data2.addfilter(ReplayerDaily)  

                elif args.timeframe == 'weekly':  
﻿                    data2.addfilter(ReplayerWeekly)  

                elif args.timeframe == 'monthly':  

                    data2.addfilter(ReplayerMonthly)  

            else:  

                if args.timeframe == 'daily':  

                    data2.addfilter(ResamplerDaily)  

                elif args.timeframe == 'weekly':  

                    data2.addfilter(ResamplerWeekly)  

                elif args.timeframe == 'monthly':  

                    data2.addfilter(ResamplerMonthly)  

  

    # First add the original data - smaller timeframe  

    cerebro.adddata(data)  

  

    # And then the large timeframe  

    cerebro.adddata(data2)  

  

    # Run over everything  

    cerebro.run(runonce=not args.runnext,  

                preload=not args.nopreload,  

                oldsync=args.oldsync,  

                stdstats=False)  

  

    # Plot the result  

    if args.plot:  

        cerebro.plot(style='bar')  

  
﻿  

def parse_args():  

    parser = argparse.ArgumentParser(  

        description='Pandas test script')  

  

    parser.add_argument('--dataname', default='', required=False,  

                        help='File Data to Load')  

  

    parser.add_argument('--dataname2', default='', required=False,  

                        help='Larger timeframe file to load')  

  

    parser.add_argument('--runnext', action='store_true',  

                        help='Use next by next instead of runonce')  

  

    parser.add_argument('--nopreload', action='store_true',  

                        help='Do not preload the data')  

  

    parser.add_argument('--oldsync', action='store_true',  

                        help='Use old data synchronization method')  

  

    parser.add_argument('--oldrs', action='store_true',  

                        help='Use old resampler')  

  

    parser.add_argument('--replay', action='store_true',  

                        help='Replay instead of resample')  

  

    parser.add_argument('--noresample', action='store_true',  
﻿                        help='Do not resample, rather load larger  

timeframe')  

  

    parser.add_argument('--timeframe', default='weekly',  

required=False,  

                        choices=['daily', 'weekly', 'monthly'],  

                        help='Timeframe to resample to')  

  

    parser.add_argument('--compression', default=1, required=False,  

type=int,  

                        help='Compress n bars into 1')  

  

    parser.add_argument('--indicators', action='store_true',  

                        help='Wether to apply Strategy with  

indicators')  

  

    parser.add_argument('--onlydaily', action='store_true',  

                        help='Indicator only to be applied to daily  

timeframe')  

  

    parser.add_argument('--period', default=10, required=False,  

type=int,  

                        help='Period to apply to indicator')  

  

    parser.add_argument('--plot', required=False, action='store_true',  

                        help='Plot the chart')  

  

    return parser.parse_args()  
﻿  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: data-pandas\data-pandas-optix.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  
﻿# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

  

import backtrader as bt  

import backtrader.feeds as btfeeds  

  

import pandas  

  

  

class PandasDataOptix(btfeeds.PandasData):  

  

    lines = ('optix_close', 'optix_pess', 'optix_opt',)  

    params = (('optix_close', -1),  

               ('optix_pess', -1),  

               ('optix_opt', -1))  

  

    if False:  

        # No longer needed with version 1.9.62.122  

        datafields = btfeeds.PandasData.datafields + (  
﻿             ['optix_close', 'optix_pess', 'optix_opt'])  

  

  

class StrategyOptix(bt.Strategy):  

  

    def next(self):  

        print('%03d %f %f, %f' % (  

            len(self),  

            self.data.optix_close[0],  

            self.data.lines.optix_pess[0],  

            self.data.optix_opt[0],))  

  

  

def runstrat():  

    args = parse_args()  

  

    # Create a cerebro entity  

    cerebro = bt.Cerebro(stdstats=False)  

  

    # Add a strategy  

    cerebro.addstrategy(StrategyOptix)  

  

    # Get a pandas dataframe  

    datapath = ('../../datas/2006-day-001-optix.txt')  

  

    # Simulate the header row isn't there if noheaders requested  

    skiprows = 1 if args.noheaders else 0  
﻿    header = None if args.noheaders else 0  

  

    dataframe = pandas.read_csv(datapath,  

                                skiprows=skiprows,  

                                header=header,  

                                parse_dates=True,  

                                index_col=0)  

  

    if not args.noprint:  

        print('--------------------------------------------------')  

        print(dataframe)  

        print('--------------------------------------------------')  

  

    # Pass it to the backtrader datafeed and add it to the cerebro  

    data = PandasDataOptix(dataname=dataframe)  

  

    cerebro.adddata(data)  

  

    # Run over everything  

    cerebro.run()  

  

    # Plot the result  

    if not args.noplot:  

        cerebro.plot(style='bar')  

  

  

def parse_args():  
﻿    parser = argparse.ArgumentParser(  

        description='Pandas test script')  

  

    parser.add_argument('--noheaders', action='store_true',  

default=False,  

                        required=False,  

                        help='Do not use header rows')  

  

    parser.add_argument('--noprint', action='store_true',  

default=False,  

                        help='Print the dataframe')  

  

    parser.add_argument('--noplot', action='store_true',  

default=False,  

                        help='Do not plot the chart')  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: data-pandas\data-pandas.txt  

====================================================================== 

==========  

  
﻿#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

  
﻿import backtrader as bt  

import backtrader.feeds as btfeeds  

  

import pandas  

  

  

def runstrat():  

    args = parse_args()  

  

    # Create a cerebro entity  

    cerebro = bt.Cerebro(stdstats=False)  

  

    # Add a strategy  

    cerebro.addstrategy(bt.Strategy)  

  

    # Get a pandas dataframe  

    datapath = ('../../datas/2006-day-001.txt')  

  

    # Simulate the header row isn't there if noheaders requested  

    skiprows = 1 if args.noheaders else 0  

    header = None if args.noheaders else 0  

  

    dataframe = pandas.read_csv(  

        datapath,  

        skiprows=skiprows,  

        header=header,  

        # parse_dates=[0],  
﻿        parse_dates=True,  

        index_col=0,  

    )  

  

    if not args.noprint:  

        print('--------------------------------------------------')  

        print(dataframe)  

        print('--------------------------------------------------')  

  

    # Pass it to the backtrader datafeed and add it to the cerebro  

    data = bt.feeds.PandasData(dataname=dataframe,  

                               # datetime='Date',  

                               nocase=True,  

                               )  

  

    cerebro.adddata(data)  

  

    # Run over everything  

    cerebro.run()  

  

    # Plot the result  

    cerebro.plot(style='bar')  

  

  

def parse_args():  

    parser = argparse.ArgumentParser(  

        description='Pandas test script')  
﻿  

    parser.add_argument('--noheaders', action='store_true',  

default=False,  

                        required=False,  

                        help='Do not use header rows')  

  

    parser.add_argument('--noprint', action='store_true',  

default=False,  

                        help='Print the dataframe')  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: data-replay\data-replay.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  
﻿#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

  

import backtrader as bt  

import backtrader.feeds as btfeeds  

import backtrader.indicators as btind  

  

  
﻿class SMAStrategy(bt.Strategy):  

    params = (  

         ('period', 10),  

         ('onlydaily', False),  

    )  

  

    def __init__(self):  

        self.sma = btind.SMA(self.data, period=self.p.period)  

  

    def start(self):  

        self.counter = 0  

  

    def prenext(self):  

        self.counter += 1  

        print('prenext len %d - counter %d' % (len(self),  

self.counter))  

  

    def next(self):  

        self.counter += 1  

        print('---next len %d - counter %d' % (len(self),  

self.counter))  

  

  

def runstrat():  

    args = parse_args()  

  

    # Create a cerebro entity  
﻿    cerebro = bt.Cerebro(stdstats=False)  

  

    cerebro.addstrategy(  

        SMAStrategy,  

        # args for the strategy  

        period=args.period,  

    )  

  

    # Load the Data  

    datapath = args.dataname or '../../datas//2006-day-001.txt'  

    data = btfeeds.BacktraderCSVData(  

        dataname=datapath)  

  

    tframes = dict(  

        daily=bt.TimeFrame.Days,  

        weekly=bt.TimeFrame.Weeks,  

        monthly=bt.TimeFrame.Months)  

  

    # Handy dictionary for the argument timeframe conversion  

    # Resample the data  

    if args.oldrp:  

        data = bt.DataReplayer(  

            dataname=data,  

            timeframe=tframes[args.timeframe],  

            compression=args.compression)  

    else:  

        data.replay(  
﻿            timeframe=tframes[args.timeframe],  

            compression=args.compression)  

  

    # First add the original data - smaller timeframe  

    cerebro.adddata(data)  

  

    # Run over everything  

    cerebro.run(preload=False)  

  

    # Plot the result  

    cerebro.plot(style='bar')  

  

  

def parse_args():  

    parser = argparse.ArgumentParser(  

        description='Pandas test script')  

  

    parser.add_argument('--dataname', default='', required=False,  

                        help='File Data to Load')  

  

    parser.add_argument('--oldrp', required=False,  

action='store_true',  

                        help='Use deprecated DataReplayer')  

  

    parser.add_argument('--timeframe', default='weekly',  

required=False,  

                        choices=['daily', 'weekly', 'monthly'],  
﻿                        help='Timeframe to resample to')  

  

    parser.add_argument('--compression', default=1, required=False,  

type=int,  

                        help='Compress n bars into 1')  

  

    parser.add_argument('--period', default=10, required=False,  

type=int,  

                        help='Period to apply to indicator')  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: data-resample\data-resample.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  
﻿#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

  

import backtrader as bt  

import backtrader.feeds as btfeeds  

  

  

def runstrat():  
﻿    args = parse_args()  

  

    # Create a cerebro entity  

    cerebro = bt.Cerebro(stdstats=False)  

  

    # Add a strategy  

    cerebro.addstrategy(bt.Strategy)  

  

    # Load the Data  

    datapath = args.dataname or '../../datas/2006-day-001.txt'  

    data = btfeeds.BacktraderCSVData(  

        dataname=datapath)  

  

    # Handy dictionary for the argument timeframe conversion  

    tframes = dict(  

        daily=bt.TimeFrame.Days,  

        weekly=bt.TimeFrame.Weeks,  

        monthly=bt.TimeFrame.Months)  

  

    # Resample the data  

    if args.oldrs:  

        # Old resampler, fully deprecated  

        data = bt.DataResampler(  

            dataname=data,  

            timeframe=tframes[args.timeframe],  

            compression=args.compression)  

  
﻿        # Add the resample data instead of the original  

        cerebro.adddata(data)  

    else:  

        # New resampler  

        cerebro.resampledata(  

            data,  

            timeframe=tframes[args.timeframe],  

            compression=args.compression)  

  

    # Run over everything  

    cerebro.run()  

  

    # Plot the result  

    cerebro.plot(style='bar')  

  

  

def parse_args():  

    parser = argparse.ArgumentParser(  

        description='Resample down to minutes')  

  

    parser.add_argument('--dataname', default='', required=False,  

                        help='File Data to Load')  

  

    parser.add_argument('--oldrs', required=False,  

action='store_true',  

                        help='Use deprecated DataResampler')  

  
﻿    parser.add_argument('--timeframe', default='weekly',  

required=False,  

                        choices=['daily', 'weekly', 'monthly'],  

                        help='Timeframe to resample to')  

  

    parser.add_argument('--compression', default=1, required=False,  

type=int,  

                        help='Compress n bars into 1')  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: daysteps\daysteps.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  
﻿# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

  

import backtrader as bt  

  

  

class St(bt.Strategy):  

    params = ()  

  
﻿    def __init__(self):  

        pass  

  

    def start(self):  

        self.callcounter = 0  

        txtfields = list()  

        txtfields.append('Calls')  

        txtfields.append('Len Strat')  

        txtfields.append('Len Data')  

        txtfields.append('Datetime')  

        txtfields.append('Open')  

        txtfields.append('High')  

        txtfields.append('Low')  

        txtfields.append('Close')  

        txtfields.append('Volume')  

        txtfields.append('OpenInterest')  

        print(','.join(txtfields))  

  

        self.lcontrol = 0  

  

    def next(self):  

        self.callcounter += 1  

  

        txtfields = list()  

        txtfields.append('%04d' % self.callcounter)  

        txtfields.append('%04d' % len(self))  

        txtfields.append('%04d' % len(self.data0))  
﻿        txtfields.append(self.data.datetime.datetime(0).isoformat())  

        txtfields.append('%.2f' % self.data0.open[0])  

        txtfields.append('%.2f' % self.data0.high[0])  

        txtfields.append('%.2f' % self.data0.low[0])  

        txtfields.append('%.2f' % self.data0.close[0])  

        txtfields.append('%.2f' % self.data0.volume[0])  

        txtfields.append('%.2f' % self.data0.openinterest[0])  

        print(','.join(txtfields))  

  

        if len(self.data) > self.lcontrol:  

            print('- I could issue a buy order during the Opening')  

  

        self.lcontrol = len(self.data)  

  

  

def runstrat():  

    args = parse_args()  

  

    cerebro = bt.Cerebro()  

    data = bt.feeds.BacktraderCSVData(dataname=args.data)  

  

    data.addfilter(bt.filters.DayStepsFilter)  

    cerebro.adddata(data)  

  

    cerebro.addstrategy(St)  

  

    cerebro._doreplay = True  
﻿    cerebro.run(**(eval('dict(' + args.cerebro + ')')))  

    if args.plot:  

        cerebro.plot(**(eval('dict(' + args.plot + ')')))  

  

  

def parse_args(pargs=None):  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='Sample for pivot point and cross plotting')  

  

    parser.add_argument('--data', required=False,  

                        default='../../datas/2005-2006-day-001.txt',  

                        help='Data to be read in')  

  

    parser.add_argument('--cerebro', required=False, action='store',  

                        default='', help=('Arguments for cerebro'))  

  

    parser.add_argument('--plot', '-p', nargs='?', required=False,  

                        metavar='kwargs', const='{}',  

                        help=('Plot (with additional args if passed'))  

  

    return parser.parse_args(pargs)  

  

  

if __name__ == '__main__':  

    runstrat()  

  
﻿====================================================================== 

==========  

# 文件: future-spot\future-spot.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 
﻿#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import random  

import backtrader as bt  

  

  

# The filter which changes the close price  

def close_changer(data, *args, **kwargs):  

    data.close[0] += 50.0 * random.randint(-1, 1)  

    return False  # length of stream is unchanged  

  

  

# override the standard markers  

class BuySellArrows(bt.observers.BuySell):  

    plotlines = dict(buy=dict(marker='$\u21E7$', markersize=12.0),  

                     sell=dict(marker='$\u21E9$', markersize=12.0))  

  

  

class St(bt.Strategy):  

    def __init__(self):  

        bt.obs.BuySell(self.data0, barplot=True)  # done here for  

        BuySellArrows(self.data1, barplot=True)  # different markers  

per data  

  
﻿    def next(self):  

        if not self.position:  

            if random.randint(0, 1):  

                self.buy(data=self.data0)  

                self.entered = len(self)  

  

        else:  # in the market  

            if (len(self) - self.entered) >= 10:  

                self.sell(data=self.data1)  

  

  

def runstrat(args=None):  

    args = parse_args(args)  

    cerebro = bt.Cerebro()  

  

    dataname = '../../datas/2006-day-001.txt'  # data feed  

  

    data0 = bt.feeds.BacktraderCSVData(dataname=dataname,  

name='data0')  

    cerebro.adddata(data0)  

  

    data1 = bt.feeds.BacktraderCSVData(dataname=dataname,  

name='data1')  

    data1.addfilter(close_changer)  

    if not args.no_comp:  

        data1.compensate(data0)  

    data1.plotinfo.plotmaster = data0  
﻿    if args.sameaxis:  

        data1.plotinfo.sameaxis = True  

    cerebro.adddata(data1)  

  

    cerebro.addstrategy(St)  # sample strategy  

  

    cerebro.addobserver(bt.obs.Broker)  # removed below with  

stdstats=False  

    cerebro.addobserver(bt.obs.Trades)  # removed below with  

stdstats=False  

  

    cerebro.broker.set_coc(True)  

    cerebro.run(stdstats=False)  # execute  

    cerebro.plot(volume=False)  # and plot  

  

  

def parse_args(pargs=None):  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description=('Compensation example'))  

  

    parser.add_argument('--no-comp', required=False,  

action='store_true')  

    parser.add_argument('--sameaxis', required=False,  

action='store_true')  

    return parser.parse_args(pargs)  

  

  
﻿if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: gold-vs-sp500\gold-vs-sp500.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  
﻿<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

# Reference  

# https://estrategiastrading.com/oro-bolsa-estadistica-con-python/  

  

import argparse  

import datetime  

  

import scipy.stats  

  

import backtrader as bt  

  

  

class PearsonR(bt.ind.PeriodN):  

    _mindatas = 2  # hint to the platform  

  

    lines = ('correlation',)  

    params = (('period', 20),)  

  

    def next(self):  

        c, p =  

scipy.stats.pearsonr(self.data0.get(size=self.p.period),  
﻿                                     

self.data1.get(size=self.p.period))  

  

        self.lines.correlation[0] = c  

  

  

class MACrossOver(bt.Strategy):  

    params = (  

         ('ma', bt.ind.MovAv.SMA),  

         ('pd1', 20),  

         ('pd2', 20),  

    )  

  

    def __init__(self):  

        ma1 = self.p.ma(self.data0, period=self.p.pd1, subplot=True)  

        self.p.ma(self.data1, period=self.p.pd2, plotmaster=ma1)  

        PearsonR(self.data0, self.data1)  

  

  

def runstrat(args=None):  

    args = parse_args(args)  

  

    cerebro = bt.Cerebro()  

  

    # Data feed kwargs  

    kwargs = dict()  

  
﻿    # Parse from/to-date  

    dtfmt, tmfmt = '%Y-%m-%d', 'T%H:%M:%S'  

    for a, d in ((getattr(args, x), x) for x in ['fromdate',  

'todate']):  

        if a:  

            strpfmt = dtfmt + tmfmt * ('T' in a)  

            kwargs[d] = datetime.datetime.strptime(a, strpfmt)  

  

    if not args.offline:  

        YahooData = bt.feeds.YahooFinanceData  

    else:  

        YahooData = bt.feeds.YahooFinanceCSVData  

  

    # Data feeds  

    data0 = YahooData(dataname=args.data0, **kwargs)  

    # cerebro.adddata(data0)  

    cerebro.resampledata(data0, timeframe=bt.TimeFrame.Weeks)  

  

    data1 = YahooData(dataname=args.data1, **kwargs)  

    # cerebro.adddata(data1)  

    cerebro.resampledata(data1, timeframe=bt.TimeFrame.Weeks)  

    data1.plotinfo.plotmaster = data0  

  

    # Broker  

    kwargs = eval('dict(' + args.broker + ')')  

    cerebro.broker = bt.brokers.BackBroker(**kwargs)  

  
﻿    # Sizer  

    kwargs = eval('dict(' + args.sizer + ')')  

    cerebro.addsizer(bt.sizers.FixedSize, **kwargs)  

  

    # Strategy  

    if True:  

        kwargs = eval('dict(' + args.strat + ')')  

        cerebro.addstrategy(MACrossOver, **kwargs)  

  

    cerebro.addobserver(bt.observers.LogReturns2,  

                        timeframe=bt.TimeFrame.Weeks,  

                        compression=20)  

  

    # Execute  

    cerebro.run(**(eval('dict(' + args.cerebro + ')')))  

  

    if args.plot:  # Plot if requested to  

        cerebro.plot(**(eval('dict(' + args.plot + ')')))  

  

  

def parse_args(pargs=None):  

  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description=(  

            'Gold vs SP500 from '  

            'https://estrategiastrading.com/oro-bolsa-estadistica-con- 
﻿python/')  

    )  

  

    parser.add_argument('--data0', required=False, default='SPY',  

                        metavar='TICKER', help='Yahoo ticker to  

download')  

  

    parser.add_argument('--data1', required=False, default='GLD',  

                        metavar='TICKER', help='Yahoo ticker to  

download')  

  

    parser.add_argument('--offline', required=False,  

action='store_true',  

                        help='Use the offline files')  

  

    # Defaults for dates  

    parser.add_argument('--fromdate', required=False, default='2005- 

01-01',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--todate', required=False, default='2016-01- 

01',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--cerebro', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  
﻿  

    parser.add_argument('--broker', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--sizer', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--strat', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--plot', required=False, default='',  

                        nargs='?', const='{}',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    return parser.parse_args(pargs)  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: ib-cash-bid-ask\ib-cash-bid-ask.txt  

====================================================================== 
﻿==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

  

# When setting the parameter "what='ASK'" the quoted price for Ask  

will be used from the incoming messages (field 2) instead of the  
﻿default Bid price (field 1).  

  

# BID: <tickPrice tickerId=16777217, field=1, price=1.11582,  

canAutoExecute=1>  

# ASK: <tickPrice tickerId=16777219, field=2, price=1.11583,  

canAutoExecute=1>  

  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import backtrader as bt  

import datetime  

  

  

class St(bt.Strategy):  

    def logdata(self):  

        txt = []  

        txt.append('{}'.format(len(self)))  

         

txt.append('{}'.format(self.data.datetime.datetime(0).isoformat()))  

        txt.append(' open BID: ' + '{}'.format(self.datas[0].open[0]))  

        txt.append(' open ASK: ' + '{}'.format(self.datas[1].open[0]))  

        txt.append(' high BID: ' + '{}'.format(self.datas[0].high[0]))  

        txt.append(' high ASK: ' + '{}'.format(self.datas[1].high[0]))  

        txt.append(' low BID: ' + '{}'.format(self.datas[0].low[0]))  

        txt.append(' low ASK: ' + '{}'.format(self.datas[1].low[0]))  

        txt.append(' close BID: ' +  

'{}'.format(self.datas[0].close[0]))  
﻿        txt.append(' close ASK: ' +  

'{}'.format(self.datas[1].close[0]))  

        txt.append(' volume: ' + '{:.2f}'.format(self.data.volume[0]))  

        print(','.join(txt))  

  

    data_live = False  

  

    def notify_data(self, data, status, *args, **kwargs):  

        print('*' * 5, 'DATA NOTIF:', data._getstatusname(status),  

*args)  

        if self.datas[0]._laststatus == self.datas[0].LIVE and  

self.datas[1]._laststatus == self.datas[1].LIVE:  

            self.data_live = True  

  

    # def notify_order(self, order):  

    #     if order.status == order.Completed:  

    #         buysell = 'BUY ' if order.isbuy() else 'SELL'  

    #         txt = '{} {}@{}'.format(buysell, order.executed.size,  

    #                                 order.executed.price)  

    #         print(txt)  

  

    # bought = 0  

    # sold = 0  

  

    def next(self):  

        self.logdata()  

        if not self.data_live:  

            return  
﻿  

        # if not self.bought:  

        #     self.bought = len(self)  # keep entry bar  

        #     self.buy()  

        # elif not self.sold:  

        #     if len(self) == (self.bought + 3):  

        #         self.sell()  

  

  

ib_symbol = 'EUR.USD-CASH-IDEALPRO'  

compression = 5  

  

def run(args=None):  

    cerebro = bt.Cerebro(stdstats=False)  

    store = bt.stores.IBStore(port=7497,  

                              # _debug=True  

                              )  

  

    data0 = store.getdata(dataname=ib_symbol,  

                          timeframe=bt.TimeFrame.Ticks,  

                          )  

    cerebro.resampledata(data0,  

                         timeframe=bt.TimeFrame.Seconds,  

                         compression=compression  

                         )  

  

    data1 = store.getdata(dataname=ib_symbol,  
﻿                          timeframe=bt.TimeFrame.Ticks,  

                          what='ASK'  

                          )  

    cerebro.resampledata(data1,  

                         timeframe=bt.TimeFrame.Seconds,  

                         compression=compression  

                         )  

  

    cerebro.broker = store.getbroker()  

    cerebro.addstrategy(St)  

    cerebro.run()  

  

  

if __name__ == '__main__':  

    run()  

  

====================================================================== 

==========  

# 文件: ibtest\ibtest.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  
﻿#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

  

# The above could be sent to an independent module  

import backtrader as bt  

from backtrader.utils import flushfile  # win32 quick stdout flushing  

  
﻿  

class TestStrategy(bt.Strategy):  

    params = dict(  

        smaperiod=5,  

        trade=False,  

        stake=10,  

        exectype=bt.Order.Market,  

        stopafter=0,  

        valid=None,  

        cancel=0,  

        donotsell=False,  

        stoptrail=False,  

        stoptraillimit=False,  

        trailamount=None,  

        trailpercent=None,  

        limitoffset=None,  

        oca=False,  

        bracket=False,  

    )  

  

    def __init__(self):  

        # To control operation entries  

        self.orderid = list()  

        self.order = None  

  

        self.counttostop = 0  

        self.datastatus = 0  
﻿  

        # Create SMA on 2nd data  

        self.sma = bt.indicators.MovAv.SMA(self.data,  

period=self.p.smaperiod)  

  

        print('--------------------------------------------------')  

        print('Strategy Created')  

        print('--------------------------------------------------')  

  

    def notify_data(self, data, status, *args, **kwargs):  

        print('*' * 5, 'DATA NOTIF:', data._getstatusname(status),  

*args)  

        if status == data.LIVE:  

            self.counttostop = self.p.stopafter  

            self.datastatus = 1  

  

    def notify_store(self, msg, *args, **kwargs):  

        print('*' * 5, 'STORE NOTIF:', msg)  

  

    def notify_order(self, order):  

        if order.status in [order.Completed, order.Cancelled,  

order.Rejected]:  

            self.order = None  

  

        print('-' * 50, 'ORDER BEGIN', datetime.datetime.now())  

        print(order)  

        print('-' * 50, 'ORDER END')  

  
﻿    def notify_trade(self, trade):  

        print('-' * 50, 'TRADE BEGIN', datetime.datetime.now())  

        print(trade)  

        print('-' * 50, 'TRADE END')  

  

    def prenext(self):  

        self.next(frompre=True)  

  

    def next(self, frompre=False):  

        txt = list()  

        txt.append('Data0')  

        txt.append('%04d' % len(self.data0))  

        dtfmt = '%Y-%m-%dT%H:%M:%S.%f'  

        txt.append('{}'.format(self.data.datetime[0]))  

        txt.append('%s' %  

self.data.datetime.datetime(0).strftime(dtfmt))  

        txt.append('{}'.format(self.data.open[0]))  

        txt.append('{}'.format(self.data.high[0]))  

        txt.append('{}'.format(self.data.low[0]))  

        txt.append('{}'.format(self.data.close[0]))  

        txt.append('{}'.format(self.data.volume[0]))  

        txt.append('{}'.format(self.data.openinterest[0]))  

        txt.append('{}'.format(self.sma[0]))  

        print(', '.join(txt))  

  

        if len(self.datas) > 1 and len(self.data1):  

            txt = list()  
﻿            txt.append('Data1')  

            txt.append('%04d' % len(self.data1))  

            dtfmt = '%Y-%m-%dT%H:%M:%S.%f'  

            txt.append('{}'.format(self.data1.datetime[0]))  

            txt.append('%s' %  

self.data1.datetime.datetime(0).strftime(dtfmt))  

            txt.append('{}'.format(self.data1.open[0]))  

            txt.append('{}'.format(self.data1.high[0]))  

            txt.append('{}'.format(self.data1.low[0]))  

            txt.append('{}'.format(self.data1.close[0]))  

            txt.append('{}'.format(self.data1.volume[0]))  

            txt.append('{}'.format(self.data1.openinterest[0]))  

            txt.append('{}'.format(float('NaN')))  

            print(', '.join(txt))  

  

        if self.counttostop:  # stop after x live lines  

            self.counttostop -= 1  

            if not self.counttostop:  

                self.env.runstop()  

                return  

  

        if not self.p.trade:  

            return  

  

        if self.datastatus and not self.position and len(self.orderid)  

< 1:  

            exectype = self.p.exectype if not self.p.oca else  

bt.Order.Limit  
﻿            close = self.data0.close[0]  

            price = round(close * 0.90, 2)  

            self.order = self.buy(size=self.p.stake,  

                                  exectype=exectype,  

                                  price=price,  

                                  valid=self.p.valid,  

                                  transmit=not self.p.bracket)  

  

            self.orderid.append(self.order)  

  

            if self.p.bracket:  

                # low side  

                self.sell(size=self.p.stake,  

                          exectype=bt.Order.Stop,  

                          price=round(price * 0.90, 2),  

                          valid=self.p.valid,  

                          transmit=False,  

                          parent=self.order)  

  

                # high side  

                self.sell(size=self.p.stake,  

                          exectype=bt.Order.Limit,  

                          price=round(close * 1.10, 2),  

                          valid=self.p.valid,  

                          transmit=True,  

                          parent=self.order)  

  
﻿            elif self.p.oca:  

                self.buy(size=self.p.stake,  

                         exectype=bt.Order.Limit,  

                         price=round(self.data0.close[0] * 0.80, 2),  

                         oco=self.order)  

  

            elif self.p.stoptrail:  

                self.sell(size=self.p.stake,  

                          exectype=bt.Order.StopTrail,  

                          # price=round(self.data0.close[0] * 0.90,  

2),  

                          valid=self.p.valid,  

                          trailamount=self.p.trailamount,  

                          trailpercent=self.p.trailpercent)  

  

            elif self.p.stoptraillimit:  

                p = round(self.data0.close[0] - self.p.trailamount, 2)  

                # p = self.data0.close[0]  

                self.sell(size=self.p.stake,  

                          exectype=bt.Order.StopTrailLimit,  

                          price=p,  

                          plimit=p + self.p.limitoffset,  

                          valid=self.p.valid,  

                          trailamount=self.p.trailamount,  

                          trailpercent=self.p.trailpercent)  

  

        elif self.position.size > 0 and not self.p.donotsell:  
﻿            if self.order is None:  

                self.order = self.sell(size=self.p.stake // 2,  

                                       exectype=bt.Order.Market,  

                                       price=self.data0.close[0])  

  

        elif self.order is not None and self.p.cancel:  

            if self.datastatus > self.p.cancel:  

                self.cancel(self.order)  

  

        if self.datastatus:  

            self.datastatus += 1  

  

    def start(self):  

        if self.data0.contractdetails is not None:  

            print('Timezone from ContractDetails: {}'.format(  

                  self.data0.contractdetails.m_timeZoneId))  

  

        header = ['Datetime', 'Open', 'High', 'Low', 'Close',  

'Volume',  

                  'OpenInterest', 'SMA']  

        print(', '.join(header))  

  

        self.done = False  

  

  

def runstrategy():  

    args = parse_args()  
﻿  

    # Create a cerebro  

    cerebro = bt.Cerebro()  

  

    storekwargs = dict(  

        host=args.host, port=args.port,  

        clientId=args.clientId, timeoffset=not args.no_timeoffset,  

        reconnect=args.reconnect, timeout=args.timeout,  

        notifyall=args.notifyall, _debug=args.debug  

    )  

  

    if args.usestore:  

        ibstore = bt.stores.IBStore(**storekwargs)  

  

    if args.broker:  

        if args.usestore:  

            broker = ibstore.getbroker()  

        else:  

            broker = bt.brokers.IBBroker(**storekwargs)  

  

        cerebro.setbroker(broker)  

  

    timeframe = bt.TimeFrame.TFrame(args.timeframe)  

    # Manage data1 parameters  

    tf1 = args.timeframe1  

    tf1 = bt.TimeFrame.TFrame(tf1) if tf1 is not None else timeframe  

    cp1 = args.compression1  
﻿    cp1 = cp1 if cp1 is not None else args.compression  

  

    if args.resample or args.replay:  

        datatf = datatf1 = bt.TimeFrame.Ticks  

        datacomp = datacomp1 = 1  

    else:  

        datatf = timeframe  

        datacomp = args.compression  

        datatf1 = tf1  

        datacomp1 = cp1  

  

    fromdate = None  

    if args.fromdate:  

        dtformat = '%Y-%m-%d' + ('T%H:%M:%S' * ('T' in args.fromdate))  

        fromdate = datetime.datetime.strptime(args.fromdate, dtformat)  

  

    IBDataFactory = ibstore.getdata if args.usestore else  

bt.feeds.IBData  

  

    datakwargs = dict(  

        timeframe=datatf, compression=datacomp,  

        historical=args.historical, fromdate=fromdate,  

        rtbar=args.rtbar,  

        qcheck=args.qcheck,  

        what=args.what,  

        backfill_start=not args.no_backfill_start,  

        backfill=not args.no_backfill,  
﻿        latethrough=args.latethrough,  

        tz=args.timezone  

    )  

  

    if not args.usestore and not args.broker:   # neither store nor  

broker  

        datakwargs.update(storekwargs)  # pass the store args over the  

data  

  

    data0 = IBDataFactory(dataname=args.data0, **datakwargs)  

  

    data1 = None  

    if args.data1 is not None:  

        if args.data1 != args.data0:  

            datakwargs['timeframe'] = datatf1  

            datakwargs['compression'] = datacomp1  

            data1 = IBDataFactory(dataname=args.data1, **datakwargs)  

        else:  

            data1 = data0  

  

    rekwargs = dict(  

        timeframe=timeframe, compression=args.compression,  

        bar2edge=not args.no_bar2edge,  

        adjbartime=not args.no_adjbartime,  

        rightedge=not args.no_rightedge,  

        takelate=not args.no_takelate,  

    )  
﻿  

    if args.replay:  

        cerebro.replaydata(data0, **rekwargs)  

  

        if data1 is not None:  

            rekwargs['timeframe'] = tf1  

            rekwargs['compression'] = cp1  

            cerebro.replaydata(data1, **rekwargs)  

  

    elif args.resample:  

        cerebro.resampledata(data0, **rekwargs)  

  

        if data1 is not None:  

            rekwargs['timeframe'] = tf1  

            rekwargs['compression'] = cp1  

            cerebro.resampledata(data1, **rekwargs)  

  

    else:  

        cerebro.adddata(data0)  

        if data1 is not None:  

            cerebro.adddata(data1)  

  

    if args.valid is None:  

        valid = None  

    else:  

        valid = datetime.timedelta(seconds=args.valid)  

    # Add the strategy  
﻿    cerebro.addstrategy(TestStrategy,  

                        smaperiod=args.smaperiod,  

                        trade=args.trade,  

                        exectype=bt.Order.ExecType(args.exectype),  

                        stake=args.stake,  

                        stopafter=args.stopafter,  

                        valid=valid,  

                        cancel=args.cancel,  

                        donotsell=args.donotsell,  

                        stoptrail=args.stoptrail,  

                        stoptraillimit=args.traillimit,  

                        trailamount=args.trailamount,  

                        trailpercent=args.trailpercent,  

                        limitoffset=args.limitoffset,  

                        oca=args.oca,  

                        bracket=args.bracket)  

  

    # Live data ... avoid long data accumulation by switching to  

"exactbars"  

    cerebro.run(exactbars=args.exactbars)  

  

    if args.plot and args.exactbars < 1:  # plot if possible  

        cerebro.plot()  

  

  

def parse_args():  

    parser = argparse.ArgumentParser(  
﻿        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='Test Interactive Brokers integration')  

  

    parser.add_argument('--exactbars', default=1, type=int,  

                        required=False, action='store',  

                        help='exactbars level, use 0/-1/-2 to enable  

plotting')  

  

    parser.add_argument('--plot',  

                        required=False, action='store_true',  

                        help='Plot if possible')  

  

    parser.add_argument('--stopafter', default=0, type=int,  

                        required=False, action='store',  

                        help='Stop after x lines of LIVE data')  

  

    parser.add_argument('--usestore',  

                        required=False, action='store_true',  

                        help='Use the store pattern')  

  

    parser.add_argument('--notifyall',  

                        required=False, action='store_true',  

                        help='Notify all messages to strategy as store  

notifs')  

  

    parser.add_argument('--debug',  

                        required=False, action='store_true',  
﻿                        help='Display all info received form IB')  

  

    parser.add_argument('--host', default='127.0.0.1',  

                        required=False, action='store',  

                        help='Host for the Interactive Brokers TWS  

Connection')  

  

    parser.add_argument('--qcheck', default=0.5, type=float,  

                        required=False, action='store',  

                        help=('Timeout for periodic '  

                              'notification/resampling/replaying  

check'))  

  

    parser.add_argument('--port', default=7496, type=int,  

                        required=False, action='store',  

                        help='Port for the Interactive Brokers TWS  

Connection')  

  

    parser.add_argument('--clientId', default=None, type=int,  

                        required=False, action='store',  

                        help='Client Id to connect to TWS (default:  

random)')  

  

    parser.add_argument('--no-timeoffset',  

                        required=False, action='store_true',  

                        help=('Do not Use TWS/System time offset for  

non '  

                              'timestamped prices and to align  
﻿resampling'))  

  

    parser.add_argument('--reconnect', default=3, type=int,  

                        required=False, action='store',  

                        help='Number of recconnection attempts to  

TWS')  

  

    parser.add_argument('--timeout', default=3.0, type=float,  

                        required=False, action='store',  

                        help='Timeout between reconnection attempts to  

TWS')  

  

    parser.add_argument('--data0', default=None,  

                        required=True, action='store',  

                        help='data 0 into the system')  

  

    parser.add_argument('--data1', default=None,  

                        required=False, action='store',  

                        help='data 1 into the system')  

  

    parser.add_argument('--timezone', default=None,  

                        required=False, action='store',  

                        help='timezone to get time output into (pytz  

names)')  

  

    parser.add_argument('--what', default=None,  

                        required=False, action='store',  

                        help='specific price type for historical  
﻿requests')  

  

    parser.add_argument('--no-backfill_start',  

                        required=False, action='store_true',  

                        help='Disable backfilling at the start')  

  

    parser.add_argument('--latethrough',  

                        required=False, action='store_true',  

                        help=('if resampling replaying, adjusting time  

'  

                              'and disabling time offset, let late  

samples '  

                              'through'))  

  

    parser.add_argument('--no-backfill',  

                        required=False, action='store_true',  

                        help='Disable backfilling after a  

disconnection')  

  

    parser.add_argument('--rtbar', default=False,  

                        required=False, action='store_true',  

                        help='Use 5 seconds real time bar updates if  

possible')  

  

    parser.add_argument('--historical',  

                        required=False, action='store_true',  

                        help='do only historical download')  

  
﻿    parser.add_argument('--fromdate',  

                        required=False, action='store',  

                        help=('Starting date for historical download '  

                              'with format: YYYY-MM-DD[THH:MM:SS]'))  

  

    parser.add_argument('--smaperiod', default=5, type=int,  

                        required=False, action='store',  

                        help='Period to apply to the Simple Moving  

Average')  

  

    pgroup = parser.add_mutually_exclusive_group(required=False)  

  

    pgroup.add_argument('--replay',  

                        required=False, action='store_true',  

                        help='replay to chosen timeframe')  

  

    pgroup.add_argument('--resample',  

                        required=False, action='store_true',  

                        help='resample to chosen timeframe')  

  

    parser.add_argument('--timeframe', default=bt.TimeFrame.Names[0],  

                        choices=bt.TimeFrame.Names,  

                        required=False, action='store',  

                        help='TimeFrame for Resample/Replay')  

  

    parser.add_argument('--compression', default=1, type=int,  

                        required=False, action='store',  
﻿                        help='Compression for Resample/Replay')  

  

    parser.add_argument('--timeframe1', default=None,  

                        choices=bt.TimeFrame.Names,  

                        required=False, action='store',  

                        help='TimeFrame for Resample/Replay - Data1')  

  

    parser.add_argument('--compression1', default=None, type=int,  

                        required=False, action='store',  

                        help='Compression for Resample/Replay -  

Data1')  

  

    parser.add_argument('--no-takelate',  

                        required=False, action='store_true',  

                        help=('resample/replay, do not accept late  

samples '  

                              'in new bar if the data source let them  

through '  

                              '(latethrough)'))  

  

    parser.add_argument('--no-bar2edge',  

                        required=False, action='store_true',  

                        help='no bar2edge for resample/replay')  

  

    parser.add_argument('--no-adjbartime',  

                        required=False, action='store_true',  

                        help='no adjbartime for resample/replay')  

  
﻿    parser.add_argument('--no-rightedge',  

                        required=False, action='store_true',  

                        help='no rightedge for resample/replay')  

  

    parser.add_argument('--broker',  

                        required=False, action='store_true',  

                        help='Use IB as broker')  

  

    parser.add_argument('--trade',  

                        required=False, action='store_true',  

                        help='Do Sample Buy/Sell operations')  

  

    parser.add_argument('--donotsell',  

                        required=False, action='store_true',  

                        help='Do not sell after a buy')  

  

    parser.add_argument('--exectype', default=bt.Order.ExecTypes[0],  

                        choices=bt.Order.ExecTypes,  

                        required=False, action='store',  

                        help='Execution to Use when opening position')  

  

    parser.add_argument('--stake', default=10, type=int,  

                        required=False, action='store',  

                        help='Stake to use in buy operations')  

  

    parser.add_argument('--valid', default=None, type=int,  

                        required=False, action='store',  
﻿                        help='Seconds to keep the order alive (0 means  

DAY)')  

  

    pgroup = parser.add_mutually_exclusive_group(required=False)  

    pgroup.add_argument('--stoptrail',  

                        required=False, action='store_true',  

                        help='Issue a stoptraillimit after buy( do not  

sell')  

  

    pgroup.add_argument('--traillimit',  

                        required=False, action='store_true',  

                        help='Issue a stoptrail after buying (do not  

sell')  

  

    pgroup.add_argument('--oca',  

                        required=False, action='store_true',  

                        help='Test oca by putting 2 orders in a  

group')  

  

    pgroup.add_argument('--bracket',  

                        required=False, action='store_true',  

                        help='Test bracket orders by issuing high/low  

sides')  

  

    pgroup = parser.add_mutually_exclusive_group(required=False)  

    pgroup.add_argument('--trailamount', default=None, type=float,  

                        required=False, action='store',  

                        help='trailamount for StopTrail order')  
﻿  

    pgroup.add_argument('--trailpercent', default=None, type=float,  

                        required=False, action='store',  

                        help='trailpercent for StopTrail order')  

  

    parser.add_argument('--limitoffset', default=None, type=float,  

                        required=False, action='store',  

                        help='limitoffset for StopTrailLimit orders')  

  

    parser.add_argument('--cancel', default=0, type=int,  

                        required=False, action='store',  

                        help=('Cancel a buy order after n bars in  

operation,'  

                              ' to be combined with orders like  

Limit'))  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrategy()  

  

====================================================================== 

==========  

# 文件: kselrsi\ksignal.txt  

====================================================================== 

==========  

  
﻿#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  
﻿  

import backtrader as bt  

  

  

class TheStrategy(bt.SignalStrategy):  

    params = dict(rsi_per=14, rsi_upper=65.0, rsi_lower=35.0,  

rsi_out=50.0,  

                  warmup=35)  

  

    def notify_order(self, order):  

        super(TheStrategy, self).notify_order(order)  

        if order.status == order.Completed:  

            print('%s: Size: %d @ Price %f' %  

                   ('buy' if order.isbuy() else 'sell',  

                   order.executed.size, order.executed.price))  

  

            d = order.data  

            print('Close[-1]: %f - Open[0]: %f' % (d.close[-1],  

d.open[0]))  

  

    def __init__(self):  

        # Original code needs artificial warmup phase - hidden sma to  

replic  

        if self.p.warmup:  

            bt.indicators.SMA(period=self.p.warmup, plot=False)  

  

        rsi = bt.indicators.RSI(period=self.p.rsi_per,  

                                upperband=self.p.rsi_upper,  
﻿                                lowerband=self.p.rsi_lower)  

  

        crossup = bt.ind.CrossUp(rsi, self.p.rsi_lower)  

        self.signal_add(bt.SIGNAL_LONG, crossup)  

        self.signal_add(bt.SIGNAL_LONGEXIT, - (rsi > self.p.rsi_out))  

  

        crossdown = bt.ind.CrossDown(rsi, self.p.rsi_upper)  

        self.signal_add(bt.SIGNAL_SHORT, -crossdown)  

        self.signal_add(bt.SIGNAL_SHORTEXIT, rsi < self.p.rsi_out)  

  

  

def runstrat(pargs=None):  

    args = parse_args(pargs)  

  

    cerebro = bt.Cerebro()  

    cerebro.broker.set_cash(args.cash)  

    cerebro.broker.set_coc(args.coc)  

    data0 = bt.feeds.YahooFinanceData(  

        dataname=args.data,  

        fromdate=datetime.datetime.strptime(args.fromdate,  

'%Y-%m-%d'),  

        todate=datetime.datetime.strptime(args.todate, '%Y-%m-%d'),  

        round=False)  

  

    cerebro.adddata(data0)  

  

    cerebro.addsizer(bt.sizers.FixedSize, stake=args.stake)  
﻿    cerebro.addstrategy(TheStrategy, **(eval('dict(' + args.strat +  

')')))  

    cerebro.addobserver(bt.observers.Value)  

    cerebro.addobserver(bt.observers.Trades)  

    cerebro.addobserver(bt.observers.BuySell, barplot=True)  

  

    cerebro.run(stdstats=False)  

    if args.plot:  

        cerebro.plot(**(eval('dict(' + args.plot + ')')))  

  

  

def parse_args(pargs=None):  

  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='Sample after post at keithselover.wordpress.com')  

  

    parser.add_argument('--data', required=False, default='XOM',  

                        help='Yahoo Ticker')  

  

    parser.add_argument('--fromdate', required=False, default='2012- 

09-01',  

                        help='Ending date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', required=False, default='2016-01- 

01',  

                        help='Ending date in YYYY-MM-DD format')  

  
﻿    parser.add_argument('--cash', required=False, action='store',  

type=float,  

                        default=100000, help=('Cash to start with'))  

  

    parser.add_argument('--stake', required=False, action='store',  

type=int,  

                        default=100, help=('Cash to start with'))  

  

    parser.add_argument('--coc', required=False, action='store_true',  

                        help=('Buy on close of same bar as order is  

issued'))  

  

    parser.add_argument('--strat', required=False, action='store',  

default='',  

                        help=('Arguments for the strategy'))  

  

    parser.add_argument('--plot', '-p', nargs='?', required=False,  

                        metavar='kwargs', const='{}',  

                        help=('Plot the read data applying any kwargs  

passed\n'  

                              '\n'  

                              'For example:\n'  

                              '\n'  

                              '  --plot style="candle" (to plot  

candles)\n'))  

  

    return parser.parse_args(pargs)  

  
﻿  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: lineplotter\lineplotter.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  
﻿# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

  

import backtrader as bt  

  

  

class St(bt.Strategy):  

    params = (  

         ('ondata', False),  

    )  

  

    def __init__(self):  

        if not self.p.ondata:  

            a = self.data.high - self.data.low  

        else:  

            a = 1.05 * (self.data.high + self.data.low) / 2.0  

  

        b = bt.LinePlotterIndicator(a, name='hilo')  

        b.plotinfo.subplot = not self.p.ondata  
﻿  

  

def runstrat(pargs=None):  

    args = parse_args(pargs)  

  

    cerebro = bt.Cerebro()  

  

    dkwargs = dict()  

    # Get the dates from the args  

    if args.fromdate is not None:  

        fromdate = datetime.datetime.strptime(args.fromdate,  

'%Y-%m-%d')  

        dkwargs['fromdate'] = fromdate  

    if args.todate is not None:  

        todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

        dkwargs['todate'] = todate  

  

    data = bt.feeds.BacktraderCSVData(dataname=args.data, **dkwargs)  

    cerebro.adddata(data)  

  

    cerebro.addstrategy(St, ondata=args.ondata)  

    cerebro.run(stdstats=False)  

  

    # Plot if requested  

    if args.plot:  

        pkwargs = dict(style='bar')  

        if args.plot is not True:  # evals to True but is not True  
﻿            npkwargs = eval('dict(' + args.plot + ')')  # args were  

passed  

            pkwargs.update(npkwargs)  

  

        cerebro.plot(**pkwargs)  

  

  

def parse_args(pargs=None):  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='Fake Indicator')  

  

    parser.add_argument('--data', '-d',  

                        default='../../datas/2005-2006-day-001.txt',  

                        help='data to add to the system')  

  

    parser.add_argument('--fromdate', '-f',  

                        default=None,  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', '-t',  

                        default=None,  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--ondata', '-o', action='store_true',  

                        help='Plot fake indicator on the data')  

  
﻿    parser.add_argument('--plot', '-p', nargs='?', required=False,  

                        metavar='kwargs', const=True,  

                        help=('Plot the read data applying any kwargs  

passed\n'  

                              '\n'  

                              'For example:\n'  

                              '\n'  

                              '  --plot style="candle" (to plot  

candles)\n'))  

  

    if pargs is not None:  

        return parser.parse_args(pargs)  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: lrsi\lrsi-test.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 
﻿#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

  

import argparse  

import datetime  

  
﻿import backtrader as bt  

  

  

class St(bt.Strategy):  

    params = (  

    )  

  

    def __init__(self):  

        mid = (self.data.high + self.data.low) / 2.0  

        bt.ind.LaguerreRSI(mid)  

        bt.ind.LaguerreRSI3(mid)  

        bt.ind.LaguerreRSI2(mid)  

        pass  

  

    def next(self):  

        pass  

  

  

def runstrat(args=None):  

    args = parse_args(args)  

  

    cerebro = bt.Cerebro()  

  

    # Data feed kwargs  

    kwargs = dict()  

  

    # Parse from/to-date  
﻿    dtfmt, tmfmt = '%Y-%m-%d', 'T%H:%M:%S'  

    for a, d in ((getattr(args, x), x) for x in ['fromdate',  

'todate']):  

        if a:  

            strpfmt = dtfmt + tmfmt * ('T' in a)  

            kwargs[d] = datetime.datetime.strptime(a, strpfmt)  

  

    # Data feed  

    data0 = bt.feeds.BacktraderCSVData(dataname=args.data0, **kwargs)  

    cerebro.adddata(data0)  

  

    # Broker  

    cerebro.broker = bt.brokers.BackBroker(**eval('dict(' +  

args.broker + ')'))  

  

    # Sizer  

    cerebro.addsizer(bt.sizers.FixedSize, **eval('dict(' + args.sizer  

+ ')'))  

  

    # Strategy  

    cerebro.addstrategy(St, **eval('dict(' + args.strat + ')'))  

  

    # Execute  

    cerebro.run(**eval('dict(' + args.cerebro + ')'))  

  

    if args.plot:  # Plot if requested to  

        cerebro.plot(**eval('dict(' + args.plot + ')'))  

  
﻿  

def parse_args(pargs=None):  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description=(  

            'lrsi sampl'  

        )  

    )  

  

    parser.add_argument('--data0', default='../../datas/2005-2006-day- 

001.txt',  

                        required=False, help='Data to read in')  

  

    # Defaults for dates  

    parser.add_argument('--fromdate', required=False, default='',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--todate', required=False, default='',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--cerebro', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--broker', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  
﻿format')  

  

    parser.add_argument('--sizer', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--strat', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--plot', required=False, default='',  

                        nargs='?', const='{}',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    return parser.parse_args(pargs)  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: macd-settings\macd-settings.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  
﻿# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

  

import argparse  

import datetime  
﻿import random  

  

import backtrader as bt  

  

BTVERSION = tuple(int(x) for x in bt.__version__.split('.'))  

  

  

class FixedPerc(bt.Sizer):  

    '''This sizer simply returns a fixed size for any operation  

  

    Params:  

      - ``perc`` (default: ``0.20``) Perc of cash to allocate for  

operation  

    '''  

  

    params = (  

         ('perc', 0.20),  # perc of cash to use for operation  

    )  

  

    def _getsizing(self, comminfo, cash, data, isbuy):  

        cashtouse = self.p.perc * cash  

        if BTVERSION > (1, 7, 1, 93):  

            size = comminfo.getsize(data.close[0], cashtouse)  

        else:  

            size = cashtouse // data.close[0]  

        return size  

  
﻿  

class TheStrategy(bt.Strategy):  

    '''  

    This strategy is loosely based on some of the examples from the  

Van  

    K. Tharp book: *Trade Your Way To Financial Freedom*. The logic:  

  

      - Enter the market if:  

        - The MACD.macd line crosses the MACD.signal line to the  

upside  

        - The Simple Moving Average has a negative direction in the  

last x  

          periods (actual value below value x periods ago)  

  

     - Set a stop price x times the ATR value away from the close  

  

     - If in the market:  

  

       - Check if the current close has gone below the stop price. If  

yes,  

         exit.  

       - If not, update the stop price if the new stop price would be  

higher  

         than the current  

    '''  

  

    params = (  

        # Standard MACD Parameters  
﻿         ('macd1', 12),  

         ('macd2', 26),  

         ('macdsig', 9),  

         ('atrperiod', 14),  # ATR Period (standard)  

         ('atrdist', 3.0),   # ATR distance for stop price  

         ('smaperiod', 30),  # SMA Period (pretty standard)  

         ('dirperiod', 10),  # Lookback period to consider SMA trend  

direction  

    )  

  

    def notify_order(self, order):  

        if order.status == order.Completed:  

            pass  

  

        if not order.alive():  

            self.order = None  # indicate no order is pending  

  

    def __init__(self):  

        self.macd = bt.indicators.MACD(self.data,  

                                       period_me1=self.p.macd1,  

                                       period_me2=self.p.macd2,  

                                       period_signal=self.p.macdsig)  

  

        # Cross of macd.macd and macd.signal  

        self.mcross = bt.indicators.CrossOver(self.macd.macd,  

self.macd.signal)  

  
﻿        # To set the stop price  

        self.atr = bt.indicators.ATR(self.data,  

period=self.p.atrperiod)  

  

        # Control market trend  

        self.sma = bt.indicators.SMA(self.data,  

period=self.p.smaperiod)  

        self.smadir = self.sma - self.sma(-self.p.dirperiod)  

  

    def start(self):  

        self.order = None  # sentinel to avoid operrations on pending  

order  

  

    def next(self):  

        if self.order:  

            return  # pending order execution  

  

        if not self.position:  # not in the market  

            if self.mcross[0] > 0.0 and self.smadir < 0.0:  

                self.order = self.buy()  

                pdist = self.atr[0] * self.p.atrdist  

                self.pstop = self.data.close[0] - pdist  

  

        else:  # in the market  

            pclose = self.data.close[0]  

            pstop = self.pstop  

  

            if pclose < pstop:  
﻿                self.close()  # stop met - get out  

            else:  

                pdist = self.atr[0] * self.p.atrdist  

                # Update only if greater than  

                self.pstop = max(pstop, pclose - pdist)  

  

  

DATASETS = {  

    'yhoo': '../../datas/yhoo-1996-2014.txt',  

    'orcl': '../../datas/orcl-1995-2014.txt',  

    'nvda': '../../datas/nvda-1999-2014.txt',  

}  

  

  

def runstrat(args=None):  

    args = parse_args(args)  

  

    cerebro = bt.Cerebro()  

    cerebro.broker.set_cash(args.cash)  

    comminfo =  

bt.commissions.CommInfo_Stocks_Perc(commission=args.commperc,  

                                                   percabs=True)  

  

    cerebro.broker.addcommissioninfo(comminfo)  

  

    dkwargs = dict()  

    if args.fromdate is not None:  
﻿        fromdate = datetime.datetime.strptime(args.fromdate,  

'%Y-%m-%d')  

        dkwargs['fromdate'] = fromdate  

  

    if args.todate is not None:  

        todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

        dkwargs['todate'] = todate  

  

    # if dataset is None, args.data has been given  

    dataname = DATASETS.get(args.dataset, args.data)  

    data0 = bt.feeds.YahooFinanceCSVData(dataname=dataname, **dkwargs)  

    cerebro.adddata(data0)  

  

    cerebro.addstrategy(TheStrategy,  

                        macd1=args.macd1, macd2=args.macd2,  

                        macdsig=args.macdsig,  

                        atrperiod=args.atrperiod,  

                        atrdist=args.atrdist,  

                        smaperiod=args.smaperiod,  

                        dirperiod=args.dirperiod)  

  

    cerebro.addsizer(FixedPerc, perc=args.cashalloc)  

  

    # Add TimeReturn Analyzers for self and the benchmark data  

    cerebro.addanalyzer(bt.analyzers.TimeReturn, _name='alltime_roi',  

                        timeframe=bt.TimeFrame.NoTimeFrame)  

  
﻿    cerebro.addanalyzer(bt.analyzers.TimeReturn, data=data0,  

_name='benchmark',  

                        timeframe=bt.TimeFrame.NoTimeFrame)  

  

    # Add TimeReturn Analyzers fot the annuyl returns  

    cerebro.addanalyzer(bt.analyzers.TimeReturn,  

timeframe=bt.TimeFrame.Years)  

    # Add a SharpeRatio  

    cerebro.addanalyzer(bt.analyzers.SharpeRatio,  

timeframe=bt.TimeFrame.Years,  

                        riskfreerate=args.riskfreerate)  

  

    # Add SQN to qualify the trades  

    cerebro.addanalyzer(bt.analyzers.SQN)  

    cerebro.addobserver(bt.observers.DrawDown)  # visualize the  

drawdown evol  

  

    results = cerebro.run()  

    st0 = results[0]  

  

    for alyzer in st0.analyzers:  

        alyzer.print()  

  

    if args.plot:  

        pkwargs = dict(style='bar')  

        if args.plot is not True:  # evals to True but is not True  

            npkwargs = eval('dict(' + args.plot + ')')  # args were  

passed  
﻿            pkwargs.update(npkwargs)  

  

        cerebro.plot(**pkwargs)  

  

  

def parse_args(pargs=None):  

  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='Sample for Tharp example with MACD')  

  

    group1 = parser.add_mutually_exclusive_group(required=True)  

    group1.add_argument('--data', required=False, default=None,  

                        help='Specific data to be read in')  

  

    group1.add_argument('--dataset', required=False, action='store',  

                        default=None, choices=DATASETS.keys(),  

                        help='Choose one of the predefined data sets')  

  

    parser.add_argument('--fromdate', required=False,  

                        default='2005-01-01',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', required=False,  

                        default=None,  

                        help='Ending date in YYYY-MM-DD format')  

  
﻿    parser.add_argument('--cash', required=False, action='store',  

                        type=float, default=50000,  

                        help=('Cash to start with'))  

  

    parser.add_argument('--cashalloc', required=False, action='store',  

                        type=float, default=0.20,  

                        help=('Perc (abs) of cash to allocate for  

ops'))  

  

    parser.add_argument('--commperc', required=False, action='store',  

                        type=float, default=0.0033,  

                        help=('Perc (abs) commision in each operation.  

'  

                              '0.001 -> 0.1%%, 0.01 -> 1%%'))  

  

    parser.add_argument('--macd1', required=False, action='store',  

                        type=int, default=12,  

                        help=('MACD Period 1 value'))  

  

    parser.add_argument('--macd2', required=False, action='store',  

                        type=int, default=26,  

                        help=('MACD Period 2 value'))  

  

    parser.add_argument('--macdsig', required=False, action='store',  

                        type=int, default=9,  

                        help=('MACD Signal Period value'))  

  
﻿    parser.add_argument('--atrperiod', required=False, action='store',  

                        type=int, default=14,  

                        help=('ATR Period To Consider'))  

  

    parser.add_argument('--atrdist', required=False, action='store',  

                        type=float, default=3.0,  

                        help=('ATR Factor for stop price  

calculation'))  

  

    parser.add_argument('--smaperiod', required=False, action='store',  

                        type=int, default=30,  

                        help=('Period for the moving average'))  

  

    parser.add_argument('--dirperiod', required=False, action='store',  

                        type=int, default=10,  

                        help=('Period for SMA direction calculation'))  

  

    parser.add_argument('--riskfreerate', required=False,  

action='store',  

                        type=float, default=0.01,  

                        help=('Risk free rate in Perc (abs) of the  

asset for '  

                              'the Sharpe Ratio'))  

    # Plot options  

    parser.add_argument('--plot', '-p', nargs='?', required=False,  

                        metavar='kwargs', const=True,  

                        help=('Plot the read data applying any kwargs  

passed\n'  
﻿                              '\n'  

                              'For example:\n'  

                              '\n'  

                              '  --plot style="candle" (to plot  

candles)\n'))  

  

    if pargs is not None:  

        return parser.parse_args(pargs)  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: memory-savings\memory-savings.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  
﻿# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import sys  

  

import backtrader as bt  

import backtrader.feeds as btfeeds  

import backtrader.indicators as btind  

import backtrader.utils.flushfile  

  
﻿  

class TestInd(bt.Indicator):  

    lines = ('a', 'b')  

  

    def __init__(self):  

        self.lines.a = b = self.data.close - self.data.high  

        self.lines.b = btind.SMA(b, period=20)  

  

  

class St(bt.Strategy):  

    params = (  

         ('datalines', False),  

         ('lendetails', False),  

    )  

  

    def __init__(self):  

        btind.SMA()  

        btind.Stochastic()  

        btind.RSI()  

        btind.MACD()  

        btind.CCI()  

        TestInd().plotinfo.plot = False  

  

    def next(self):  

        if self.p.datalines:  

            txt = ','.join(  

                 ['%04d' % len(self),  
﻿                 '%04d' % len(self.data0),  

                 self.data.datetime.date(0).isoformat()]  

            )  

  

            print(txt)  

  

    def loglendetails(self, msg):  

        if self.p.lendetails:  

            print(msg)  

  

    def stop(self):  

        super(St, self).stop()  

  

        tlen = 0  

        self.loglendetails('-- Evaluating Datas')  

        for i, data in enumerate(self.datas):  

            tdata = 0  

            for line in data.lines:  

                tdata += len(line.array)  

                tline = len(line.array)  

  

            tlen += tdata  

            logtxt = '---- Data {} Total Cells {} - Cells per Line {}'  

            self.loglendetails(logtxt.format(i, tdata, tline))  

  

        self.loglendetails('-- Evaluating Indicators')  

        for i, ind in enumerate(self.getindicators()):  
﻿            tlen += self.rindicator(ind, i, 0)  

  

        self.loglendetails('-- Evaluating Observers')  

        for i, obs in enumerate(self.getobservers()):  

            tobs = 0  

            for line in obs.lines:  

                tobs += len(line.array)  

                tline = len(line.array)  

  

            tlen += tdata  

            logtxt = '---- Observer {} Total Cells {} - Cells per Line  

{}'  

            self.loglendetails(logtxt.format(i, tobs, tline))  

  

        print('Total memory cells used: {}'.format(tlen))  

  

    def rindicator(self, ind, i, deep):  

        tind = 0  

        for line in ind.lines:  

            tind += len(line.array)  

            tline = len(line.array)  

  

        thisind = tind  

  

        tsub = 0  

        for j, sind in enumerate(ind.getindicators()):  

            tsub += self.rindicator(sind, j, deep + 1)  
﻿  

        iname = ind.__class__.__name__.split('.')[-1]  

  

        logtxt = '---- Indicator {}.{} {} Total Cells {} - Cells per  

line {}'  

        self.loglendetails(logtxt.format(deep, i, iname, tind, tline))  

        logtxt = '---- SubIndicators Total Cells {}'  

        self.loglendetails(logtxt.format(deep, i, iname, tsub))  

  

        return tind + tsub  

  

  

def runstrat():  

    args = parse_args()  

  

    cerebro = bt.Cerebro()  

    data = btfeeds.YahooFinanceCSVData(dataname=args.data)  

    cerebro.adddata(data)  

    cerebro.addstrategy(  

        St, datalines=args.datalines, lendetails=args.lendetails)  

  

    cerebro.run(runonce=False, exactbars=args.save)  

    if args.plot:  

        cerebro.plot(style='bar')  

  

  

def parse_args():  
﻿    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='Check Memory Savings')  

  

    parser.add_argument('--data', required=False,  

                        default='../../datas/yhoo-1996-2015.txt',  

                        help='Data to be read in')  

  

    parser.add_argument('--save', required=False, type=int, default=0,  

                        help=('Memory saving level [1, 0, -1, -2]'))  

  

    parser.add_argument('--datalines', required=False,  

action='store_true',  

                        help=('Print data lines'))  

  

    parser.add_argument('--lendetails', required=False,  

action='store_true',  

                        help=('Print individual items memory usage'))  

  

    parser.add_argument('--plot', required=False, action='store_true',  

                        help=('Plot the result'))  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrat()  
﻿  

====================================================================== 

==========  

# 文件: mixing-timeframes\mixing-timeframes.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  
﻿###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

  

import backtrader as bt  

import backtrader.feeds as btfeeds  

import backtrader.indicators as btind  

import backtrader.utils.flushfile  

  

  

class St(bt.Strategy):  

    params = dict(multi=True)  

  

    def __init__(self):  

        self.pp = pp = btind.PivotPoint(self.data1)  

        pp.plotinfo.plot = False  # deactivate plotting  

  

        if self.p.multi:  

            pp1 = pp()  # couple the entire indicators  

            self.sellsignal = self.data0.close < pp1.s1  

        else:  

            self.sellsignal = self.data0.close < pp.s1()  

  

    def next(self):  
﻿        txt = ','.join(  

             ['%04d' % len(self),  

             '%04d' % len(self.data0),  

             '%04d' % len(self.data1),  

             self.data.datetime.date(0).isoformat(),  

             '%.2f' % self.data0.close[0],  

             '%.2f' % self.pp.s1[0],  

             '%.2f' % self.sellsignal[0]])  

  

        print(txt)  

  

  

def runstrat():  

    args = parse_args()  

  

    cerebro = bt.Cerebro()  

    data = btfeeds.BacktraderCSVData(dataname=args.data)  

    cerebro.adddata(data)  

    cerebro.resampledata(data, timeframe=bt.TimeFrame.Months)  

  

    cerebro.addstrategy(St, multi=args.multi)  

  

    cerebro.run(stdstats=False, runonce=False)  

    if args.plot:  

        cerebro.plot(style='bar')  

  

  
﻿def parse_args():  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='Sample for pivot point and cross plotting')  

  

    parser.add_argument('--data', required=False,  

                        default='../../datas/2005-2006-day-001.txt',  

                        help='Data to be read in')  

  

    parser.add_argument('--multi', required=False,  

action='store_true',  

                        help='Couple all lines of the indicator')  

  

    parser.add_argument('--plot', required=False, action='store_true',  

                        help=('Plot the result'))  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: multi-copy\multi-copy.txt  

====================================================================== 

==========  

  
﻿#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

  

import argparse  
﻿import datetime  

import random  

  

import backtrader as bt  

  

  

class TheStrategy(bt.Strategy):  

    '''  

    This strategy is capable of:  

  

      - Going Long with a Moving Average upwards CrossOver  

  

      - Going Long again with a MACD upwards CrossOver  

  

      - Closing the aforementioned longs with the corresponding  

downwards  

        crossovers  

    '''  

  

    params = (  

         ('myname', None),  

         ('dtarget', None),  

         ('stake', 100),  

         ('macd1', 12),  

         ('macd2', 26),  

         ('macdsig', 9),  

         ('sma1', 10),  
﻿         ('sma2', 30),  

    )  

  

    def notify_order(self, order):  

        if not order.alive():  

            if not order.isbuy():  # going flat  

                self.order = 0  

  

            if order.status == order.Completed:  

                tfields = [self.p.myname,  

                           len(self),  

                           order.data.datetime.date(),  

                           order.data._name,  

                           'BUY' * order.isbuy() or 'SELL',  

                           order.executed.size, order.executed.price]  

  

                print(','.join(str(x) for x in tfields))  

  

    def __init__(self):  

        # Choose data to buy from  

        self.dtarget = self.getdatabyname(self.p.dtarget)  

  

        # Create indicators  

        sma1 = bt.ind.SMA(self.dtarget, period=self.p.sma1)  

        sma2 = bt.ind.SMA(self.dtarget, period=self.p.sma2)  

        self.smasig = bt.ind.CrossOver(sma1, sma2)  

  
﻿        macd = bt.ind.MACD(self.dtarget,  

                           period_me1=self.p.macd1,  

                           period_me2=self.p.macd2,  

                           period_signal=self.p.macdsig)  

  

        # Cross of macd.macd and macd.signal  

        self.macdsig = bt.ind.CrossOver(macd.macd, macd.signal)  

  

    def start(self):  

        self.order = 0  # sentinel to avoid operrations on pending  

order  

  

        tfields = ['Name', 'Length', 'Datetime', 'Operation/Names',  

                   'Position1.Size', 'Position2.Size']  

        print(','.join(str(x) for x in tfields))  

  

    def next(self):  

        tfields = [self.p.myname,  

                   len(self),  

                   self.data.datetime.date(),  

                   self.getposition(self.data0).size]  

        if len(self.datas) > 1:  

            tfields.append(self.getposition(self.data1).size)  

  

        print(','.join(str(x) for x in tfields))  

  

        buysize = self.p.stake // 2  # let each signal buy half  
﻿        if self.macdsig[0] > 0.0:  

            self.buy(data=self.dtarget, size=buysize)  

  

        if self.smasig[0] > 0.0:  

            self.buy(data=self.dtarget, size=buysize)  

  

        size = self.getposition(self.dtarget).size  

  

        # if 2x in the market, let each potential close ... close 1/2  

        if size == self.p.stake:  

            size //= 2  

  

        if self.macdsig[0] < 0.0:  

            self.close(data=self.dtarget, size=size)  

  

        if self.smasig[0] < 0.0:  

            self.close(data=self.dtarget, size=size)  

  

  

class TheStrategy2(TheStrategy):  

    '''  

    Subclass of TheStrategy to simply change the parameters  

  

    '''  

    params = (  

         ('stake', 200),  

         ('macd1', 15),  
﻿         ('macd2', 22),  

         ('macdsig', 7),  

         ('sma1', 15),  

         ('sma2', 50),  

    )  

  

  

def runstrat(args=None):  

    args = parse_args(args)  

  

    cerebro = bt.Cerebro()  

    cerebro.broker.set_cash(args.cash)  

  

    dkwargs = dict()  

    if args.fromdate is not None:  

        fromdate = datetime.datetime.strptime(args.fromdate,  

'%Y-%m-%d')  

        dkwargs['fromdate'] = fromdate  

  

    if args.todate is not None:  

        todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

        dkwargs['todate'] = todate  

  

    # if dataset is None, args.data has been given  

    data0 = bt.feeds.YahooFinanceCSVData(dataname=args.data0,  

**dkwargs)  

    cerebro.adddata(data0, name='MyData0')  
﻿  

    st0kwargs = dict()  

    if args.st0 is not None:  

        tmpdict = eval('dict(' + args.st0 + ')')  # args were passed  

        st0kwargs.update(tmpdict)  

  

    cerebro.addstrategy(TheStrategy,  

                        myname='St1', dtarget='MyData0', **st0kwargs)  

  

    if args.copydata:  

        data1 = data0.copyas('MyData1')  

        cerebro.adddata(data1)  

        dtarget = 'MyData1'  

  

    else:  # use same target  

        dtarget = 'MyData0'  

  

    st1kwargs = dict()  

    if args.st1 is not None:  

        tmpdict = eval('dict(' + args.st1 + ')')  # args were passed  

        st1kwargs.update(tmpdict)  

  

    cerebro.addstrategy(TheStrategy2,  

                        myname='St2', dtarget=dtarget, **st1kwargs)  

  

    results = cerebro.run()  

  
﻿    if args.plot:  

        pkwargs = dict(style='bar')  

        if args.plot is not True:  # evals to True but is not True  

            npkwargs = eval('dict(' + args.plot + ')')  # args were  

passed  

            pkwargs.update(npkwargs)  

  

        cerebro.plot(**pkwargs)  

  

  

def parse_args(pargs=None):  

  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='Sample for Tharp example with MACD')  

  

    # pgroup = parser.add_mutually_exclusive_group(required=True)  

    parser.add_argument('--data0', required=False,  

                        default='../../datas/yhoo-1996-2014.txt',  

                        help='Specific data0 to be read in')  

  

    parser.add_argument('--fromdate', required=False,  

                        default='2005-01-01',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', required=False,  

                        default='2006-12-31',  
﻿                        help='Ending date in YYYY-MM-DD format')  

  

    parser.add_argument('--cash', required=False, action='store',  

                        type=float, default=50000,  

                        help=('Cash to start with'))  

  

    parser.add_argument('--copydata', required=False,  

action='store_true',  

                        help=('Copy Data for 2nd strategy'))  

  

    parser.add_argument('--st0', required=False, action='store',  

                        default=None,  

                        help=('Params for 1st strategy: as a list of  

comma '  

                              'separated name=value pairs like: '  

                              'stake=100,macd1=12,macd2=26,macdsig=9,'  

                              'sma1=10,sma2=30'))  

  

    parser.add_argument('--st1', required=False, action='store',  

                        default=None,  

                        help=('Params for 1st strategy: as a list of  

comma '  

                              'separated name=value pairs like: '  

                              'stake=200,macd1=15,macd2=22,macdsig=7,'  

                              'sma1=15,sma2=50'))  

  

    # Plot options  

    parser.add_argument('--plot', '-p', nargs='?', required=False,  
﻿                        metavar='kwargs', const=True,  

                        help=('Plot the read data applying any kwargs  

passed\n'  

                              '\n'  

                              'For example:\n'  

                              '\n'  

                              '  --plot style="candle" (to plot  

candles)\n'))  

  

    if pargs is not None:  

        return parser.parse_args(pargs)  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: multi-example\mult-values.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  
﻿#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

  

import argparse  

import datetime  

  

import backtrader as bt  
﻿  

  

class TestSizer(bt.Sizer):  

    params = dict(stake=1)  

  

    def _getsizing(self, comminfo, cash, data, isbuy):  

        dt, i = self.strategy.datetime.date(), data._id  

        s = self.p.stake * (1 + (not isbuy))  

        print('{} Data {} OType {} Sizing to {}'.format(  

            dt, data._name, ('buy' * isbuy) or 'sell', s))  

  

        return s  

  

  

class St(bt.Strategy):  

    params = dict(  

        enter=[1, 3, 4],  # data ids are 1 based  

        hold=[7, 10, 15],  # data ids are 1 based  

        usebracket=True,  

        rawbracket=True,  

        pentry=0.015,  

        plimits=0.03,  

        valid=10,  

    )  

  

    def notify_order(self, order):  

        if order.status == order.Submitted:  
﻿            return  

  

        dt, dn = self.datetime.date(), order.data._name  

        print('{} {} Order {} Status {}'.format(  

            dt, dn, order.ref, order.getstatusname())  

        )  

  

        whichord = ['main', 'stop', 'limit', 'close']  

        if not order.alive():  # not alive - nullify  

            dorders = self.o[order.data]  

            idx = dorders.index(order)  

            dorders[idx] = None  

            print('-- No longer alive {} Ref'.format(whichord[idx]))  

  

            if all(x is None for x in dorders):  

                dorders[:] = []  # empty list - New orders allowed  

  

    def __init__(self):  

        self.o = dict()  # orders per data (main, stop, limit, manual- 

close)  

        self.holding = dict()  # holding periods per data  

  

    def next(self):  

        for i, d in enumerate(self.datas):  

            dt, dn = self.datetime.date(), d._name  

            pos = self.getposition(d).size  

            print('{} {} Position {}'.format(dt, dn, pos))  
﻿  

            if not pos and not self.o.get(d, None):  # no market / no  

orders  

                if dt.weekday() == self.p.enter[i]:  

                    if not self.p.usebracket:  

                        self.o[d] = [self.buy(data=d)]  

                        print('{} {} Buy {}'.format(dt, dn,  

self.o[d][0].ref))  

  

                    else:  

                        p = d.close[0] * (1.0 - self.p.pentry)  

                        pstp = p * (1.0 - self.p.plimits)  

                        plmt = p * (1.0 + self.p.plimits)  

                        valid = datetime.timedelta(self.p.valid)  

  

                        if self.p.rawbracket:  

                            o1 = self.buy(data=d,  

exectype=bt.Order.Limit,  

                                          price=p, valid=valid,  

transmit=False)  

  

                            o2 = self.sell(data=d,  

exectype=bt.Order.Stop,  

                                           price=pstp, size=o1.size,  

                                           transmit=False, parent=o1)  

  

                            o3 = self.sell(data=d,  

exectype=bt.Order.Limit,  
﻿                                           price=plmt, size=o1.size,  

                                           transmit=True, parent=o1)  

  

                            self.o[d] = [o1, o2, o3]  

  

                        else:  

                            self.o[d] = self.buy_bracket(  

                                data=d, price=p, stopprice=pstp,  

                                limitprice=plmt,  

oargs=dict(valid=valid))  

  

                        print('{} {} Main {} Stp {} Lmt {}'.format(  

                            dt, dn, *(x.ref for x in self.o[d])))  

  

                    self.holding[d] = 0  

  

            elif pos:  # exiting can also happen after a number of  

days  

                self.holding[d] += 1  

                if self.holding[d] >= self.p.hold[i]:  

                    o = self.close(data=d)  

                    self.o[d].append(o)  # manual order to list of  

orders  

                    print('{} {} Manual Close {}'.format(dt, dn,  

o.ref))  

                    if self.p.usebracket:  

                        self.cancel(self.o[d][1])  # cancel stop side  

                        print('{} {} Cancel {}'.format(dt, dn,  
﻿self.o[d][1]))  

  

  

def runstrat(args=None):  

    args = parse_args(args)  

  

    cerebro = bt.Cerebro()  

  

    # Data feed kwargs  

    kwargs = dict()  

  

    # Parse from/to-date  

    dtfmt, tmfmt = '%Y-%m-%d', 'T%H:%M:%S'  

    for a, d in ((getattr(args, x), x) for x in ['fromdate',  

'todate']):  

        if a:  

            strpfmt = dtfmt + tmfmt * ('T' in a)  

            kwargs[d] = datetime.datetime.strptime(a, strpfmt)  

  

    # Data feed  

    data0 = bt.feeds.YahooFinanceCSVData(dataname=args.data0,  

**kwargs)  

    cerebro.adddata(data0, name='d0')  

  

    data1 = bt.feeds.YahooFinanceCSVData(dataname=args.data1,  

**kwargs)  

    data1.plotinfo.plotmaster = data0  

    cerebro.adddata(data1, name='d1')  
﻿  

    data2 = bt.feeds.YahooFinanceCSVData(dataname=args.data2,  

**kwargs)  

    data2.plotinfo.plotmaster = data0  

    cerebro.adddata(data2, name='d2')  

  

    # Broker  

    cerebro.broker = bt.brokers.BackBroker(**eval('dict(' +  

args.broker + ')'))  

    cerebro.broker.setcommission(commission=0.001)  

  

    # Sizer  

    # cerebro.addsizer(bt.sizers.FixedSize, **eval('dict(' +  

args.sizer + ')'))  

    cerebro.addsizer(TestSizer, **eval('dict(' + args.sizer + ')'))  

  

    # Strategy  

    cerebro.addstrategy(St, **eval('dict(' + args.strat + ')'))  

  

    # Execute  

    cerebro.run(**eval('dict(' + args.cerebro + ')'))  

  

    if args.plot:  # Plot if requested to  

        cerebro.plot(**eval('dict(' + args.plot + ')'))  

  

  

def parse_args(pargs=None):  

    parser = argparse.ArgumentParser(  
﻿        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description=(  

            'Multiple Values and Brackets'  

        )  

    )  

  

    parser.add_argument('--data0', default='../../datas/nvda-1999- 

2014.txt',  

                        required=False, help='Data0 to read in')  

  

    parser.add_argument('--data1', default='../../datas/yhoo-1996- 

2014.txt',  

                        required=False, help='Data1 to read in')  

  

    parser.add_argument('--data2', default='../../datas/orcl-1995- 

2014.txt',  

                        required=False, help='Data1 to read in')  

  

    # Defaults for dates  

    parser.add_argument('--fromdate', required=False, default='2001- 

01-01',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--todate', required=False, default='2007-01- 

01',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  
﻿    parser.add_argument('--cerebro', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--broker', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--sizer', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--strat', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--plot', required=False, default='',  

                        nargs='?', const='{}',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    return parser.parse_args(pargs)  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 
﻿==========  

# 文件: multidata-strategy\multidata-strategy-unaligned.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  
﻿from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

  

# The above could be sent to an independent module  

import backtrader as bt  

import backtrader.feeds as btfeeds  

import backtrader.indicators as btind  

  

  

class MultiDataStrategy(bt.Strategy):  

    '''  

    This strategy operates on 2 datas. The expectation is that the 2  

datas are  

    correlated and the 2nd data is used to generate signals on the 1st  

  

      - Buy/Sell Operationss will be executed on the 1st data  

      - The signals are generated using a Simple Moving Average on the  

2nd data  

        when the close price crosses upwwards/downwards  

  

    The strategy is a long-only strategy  

    '''  

    params = dict(  

        period=15,  
﻿        stake=10,  

        printout=True,  

    )  

  

    def log(self, txt, dt=None):  

        if self.p.printout:  

            dt = dt or self.data.datetime[0]  

            dt = bt.num2date(dt)  

            print('%s, %s' % (dt.isoformat(), txt))  

  

    def notify_order(self, order):  

        if order.status in [bt.Order.Submitted, bt.Order.Accepted]:  

            return  # Await further notifications  

  

        if order.status == order.Completed:  

            if order.isbuy():  

                buytxt = 'BUY COMPLETE, %.2f' % order.executed.price  

                self.log(buytxt, order.executed.dt)  

            else:  

                selltxt = 'SELL COMPLETE, %.2f' % order.executed.price  

                self.log(selltxt, order.executed.dt)  

  

        elif order.status in [order.Expired, order.Canceled,  

order.Margin]:  

            self.log('%s ,' % order.Status[order.status])  

            pass  # Simply log  

  
﻿        # Allow new orders  

        self.orderid = None  

  

    def __init__(self):  

        # To control operation entries  

        self.orderid = None  

  

        # Create SMA on 2nd data  

        sma = btind.MovAv.SMA(self.data1, period=self.p.period)  

        # Create a CrossOver Signal from close an moving average  

        self.signal = btind.CrossOver(self.data1.close, sma)  

  

    def next(self):  

        if self.orderid:  

            return  # if an order is active, no new orders are allowed  

  

        if self.p.printout:  

            print('Self  len:', len(self))  

            print('Data0 len:', len(self.data0))  

            print('Data1 len:', len(self.data1))  

            print('Data0 len == Data1 len:',  

                  len(self.data0) == len(self.data1))  

  

            print('Data0 dt:', self.data0.datetime.datetime())  

            print('Data1 dt:', self.data1.datetime.datetime())  

  

        if not self.position:  # not yet in market  
﻿            if self.signal > 0.0:  # cross upwards  

                self.log('BUY CREATE , %.2f' % self.data1.close[0])  

                self.buy(size=self.p.stake)  

  

        else:  # in the market  

            if self.signal < 0.0:  # crosss downwards  

                self.log('SELL CREATE , %.2f' % self.data1.close[0])  

                self.sell(size=self.p.stake)  

  

    def stop(self):  

        print('==================================================')  

        print('Starting Value - %.2f' % self.broker.startingcash)  

        print('Ending   Value - %.2f' % self.broker.getvalue())  

        print('==================================================')  

  

  

def runstrategy():  

    args = parse_args()  

  

    # Create a cerebro  

    cerebro = bt.Cerebro()  

  

    # Get the dates from the args  

    fromdate = datetime.datetime.strptime(args.fromdate, '%Y-%m-%d')  

    todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

  

    # Create the 1st data  
﻿    data0 = btfeeds.YahooFinanceCSVData(  

        dataname=args.data0,  

        fromdate=fromdate,  

        todate=todate)  

  

    # Add the 1st data to cerebro  

    cerebro.adddata(data0)  

  

    # Create the 2nd data  

    data1 = btfeeds.YahooFinanceCSVData(  

        dataname=args.data1,  

        fromdate=fromdate,  

        todate=todate)  

  

    # Add the 2nd data to cerebro  

    cerebro.adddata(data1)  

  

    # Add the strategy  

    cerebro.addstrategy(MultiDataStrategy,  

                        period=args.period,  

                        stake=args.stake)  

  

    # Add the commission - only stocks like a for each operation  

    cerebro.broker.setcash(args.cash)  

  

    # Add the commission - only stocks like a for each operation  

    cerebro.broker.setcommission(commission=args.commperc)  
﻿  

    # And run it  

    cerebro.run(runonce=not args.runnext,  

                preload=not args.nopreload,  

                oldsync=args.oldsync)  

  

    # Plot if requested  

    if args.plot:  

        cerebro.plot(numfigs=args.numfigs, volume=False, zdown=False)  

  

  

def parse_args():  

    parser = argparse.ArgumentParser(description='MultiData Strategy')  

  

    parser.add_argument('--data0', '-d0',  

                        default='../../datas/orcl-2003-2005.txt',  

                        help='1st data into the system')  

  

    parser.add_argument('--data1', '-d1',  

                        default='../../datas/yhoo-2003-2005.txt',  

                        help='2nd data into the system')  

  

    parser.add_argument('--fromdate', '-f',  

                        default='2003-01-01',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', '-t',  
﻿                        default='2005-12-31',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--period', default=15, type=int,  

                        help='Period to apply to the Simple Moving  

Average')  

  

    parser.add_argument('--cash', default=100000, type=int,  

                        help='Starting Cash')  

  

    parser.add_argument('--runnext', action='store_true',  

                        help='Use next by next instead of runonce')  

  

    parser.add_argument('--nopreload', action='store_true',  

                        help='Do not preload the data')  

  

    parser.add_argument('--oldsync', action='store_true',  

                        help='Use old data synchronization method')  

  

    parser.add_argument('--commperc', default=0.005, type=float,  

                        help='Percentage commission (0.005 is 0.5%%')  

  

    parser.add_argument('--stake', default=10, type=int,  

                        help='Stake to apply in each operation')  

  

    parser.add_argument('--plot', '-p', action='store_true',  

                        help='Plot the read data')  
﻿  

    parser.add_argument('--numfigs', '-n', default=1,  

                        help='Plot using numfigs figures')  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrategy()  

  

====================================================================== 

==========  

# 文件: multidata-strategy\multidata-strategy.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  
﻿# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

  

# The above could be sent to an independent module  

import backtrader as bt  

import backtrader.feeds as btfeeds  

import backtrader.indicators as btind  

  

  

class MultiDataStrategy(bt.Strategy):  

    '''  

    This strategy operates on 2 datas. The expectation is that the 2  

datas are  

    correlated and the 2nd data is used to generate signals on the 1st  
﻿  

      - Buy/Sell Operationss will be executed on the 1st data  

      - The signals are generated using a Simple Moving Average on the  

2nd data  

        when the close price crosses upwwards/downwards  

  

    The strategy is a long-only strategy  

    '''  

    params = dict(  

        period=15,  

        stake=10,  

        printout=True,  

    )  

  

    def log(self, txt, dt=None):  

        if self.p.printout:  

            dt = dt or self.data.datetime[0]  

            dt = bt.num2date(dt)  

            print('%s, %s' % (dt.isoformat(), txt))  

  

    def notify_order(self, order):  

        if order.status in [bt.Order.Submitted, bt.Order.Accepted]:  

            return  # Await further notifications  

  

        if order.status == order.Completed:  

            if order.isbuy():  

                buytxt = 'BUY COMPLETE, %.2f' % order.executed.price  
﻿                self.log(buytxt, order.executed.dt)  

            else:  

                selltxt = 'SELL COMPLETE, %.2f' % order.executed.price  

                self.log(selltxt, order.executed.dt)  

  

        elif order.status in [order.Expired, order.Canceled,  

order.Margin]:  

            self.log('%s ,' % order.Status[order.status])  

            pass  # Simply log  

  

        # Allow new orders  

        self.orderid = None  

  

    def __init__(self):  

        # To control operation entries  

        self.orderid = None  

  

        # Create SMA on 2nd data  

        sma = btind.MovAv.SMA(self.data1, period=self.p.period)  

        # Create a CrossOver Signal from close an moving average  

        self.signal = btind.CrossOver(self.data1.close, sma)  

  

    def next(self):  

        if self.orderid:  

            return  # if an order is active, no new orders are allowed  

  

        if self.p.printout:  
﻿            print('Self  len:', len(self))  

            print('Data0 len:', len(self.data0))  

            print('Data1 len:', len(self.data1))  

            print('Data0 len == Data1 len:',  

                  len(self.data0) == len(self.data1))  

  

            print('Data0 dt:', self.data0.datetime.datetime())  

            print('Data1 dt:', self.data1.datetime.datetime())  

  

        if not self.position:  # not yet in market  

            if self.signal > 0.0:  # cross upwards  

                self.log('BUY CREATE , %.2f' % self.data1.close[0])  

                self.buy(size=self.p.stake)  

                self.buy(data=self.data1, size=self.p.stake)  

  

        else:  # in the market  

            if self.signal < 0.0:  # crosss downwards  

                self.log('SELL CREATE , %.2f' % self.data1.close[0])  

                self.sell(size=self.p.stake)  

                self.sell(data=self.data1, size=self.p.stake)  

  

    def stop(self):  

        print('==================================================')  

        print('Starting Value - %.2f' % self.broker.startingcash)  

        print('Ending   Value - %.2f' % self.broker.getvalue())  

        print('==================================================')  

  
﻿  

def runstrategy():  

    args = parse_args()  

  

    # Create a cerebro  

    cerebro = bt.Cerebro()  

  

    # Get the dates from the args  

    fromdate = datetime.datetime.strptime(args.fromdate, '%Y-%m-%d')  

    todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

  

    # Create the 1st data  

    data0 = btfeeds.YahooFinanceCSVData(  

        dataname=args.data0,  

        fromdate=fromdate,  

        todate=todate)  

  

    # Add the 1st data to cerebro  

    cerebro.adddata(data0)  

  

    # Create the 2nd data  

    data1 = btfeeds.YahooFinanceCSVData(  

        dataname=args.data1,  

        fromdate=fromdate,  

        todate=todate)  

  

    # Add the 2nd data to cerebro  
﻿    cerebro.adddata(data1)  

  

    # Add the strategy  

    cerebro.addstrategy(MultiDataStrategy,  

                        period=args.period,  

                        stake=args.stake)  

  

    # Add the commission - only stocks like a for each operation  

    cerebro.broker.setcash(args.cash)  

  

    # Add the commission - only stocks like a for each operation  

    cerebro.broker.setcommission(commission=args.commperc)  

  

    # And run it  

    cerebro.run(runonce=not args.runnext,  

                preload=not args.nopreload,  

                oldsync=args.oldsync)  

  

    # Plot if requested  

    if args.plot:  

        cerebro.plot(numfigs=args.numfigs, volume=False, zdown=False)  

  

  

def parse_args():  

    parser = argparse.ArgumentParser(description='MultiData Strategy')  

  

    parser.add_argument('--data0', '-d0',  
﻿                        default='../../datas/orcl-1995-2014.txt',  

                        help='1st data into the system')  

  

    parser.add_argument('--data1', '-d1',  

                        default='../../datas/yhoo-1996-2014.txt',  

                        help='2nd data into the system')  

  

    parser.add_argument('--fromdate', '-f',  

                        default='2003-01-01',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', '-t',  

                        default='2005-12-31',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--period', default=15, type=int,  

                        help='Period to apply to the Simple Moving  

Average')  

  

    parser.add_argument('--cash', default=100000, type=int,  

                        help='Starting Cash')  

  

    parser.add_argument('--runnext', action='store_true',  

                        help='Use next by next instead of runonce')  

  

    parser.add_argument('--nopreload', action='store_true',  

                        help='Do not preload the data')  
﻿  

    parser.add_argument('--oldsync', action='store_true',  

                        help='Use old data synchronization method')  

  

    parser.add_argument('--commperc', default=0.005, type=float,  

                        help='Percentage commission (0.005 is 0.5%%')  

  

    parser.add_argument('--stake', default=10, type=int,  

                        help='Stake to apply in each operation')  

  

    parser.add_argument('--plot', '-p', action='store_true',  

                        help='Plot the read data')  

  

    parser.add_argument('--numfigs', '-n', default=1,  

                        help='Plot using numfigs figures')  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrategy()  

  

====================================================================== 

==========  

# 文件: multitrades\mtradeobserver.txt  

====================================================================== 

==========  
﻿  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import math  
﻿  

import backtrader as bt  

  

  

class MTradeObserver(bt.observer.Observer):  

    lines = ('Id_0', 'Id_1', 'Id_2')  

  

    plotinfo = dict(plot=True, subplot=True, plotlinelabels=True)  

  

    plotlines = dict(  

        Id_0=dict(marker='*', markersize=8.0, color='lime',  

fillstyle='full'),  

        Id_1=dict(marker='o', markersize=8.0, color='red',  

fillstyle='full'),  

        Id_2=dict(marker='s', markersize=8.0, color='blue',  

fillstyle='full')  

    )  

  

    def next(self):  

        for trade in self._owner._tradespending:  

  

            if trade.data is not self.data:  

                continue  

  

            if not trade.isclosed:  

                continue  

  

            self.lines[trade.tradeid][0] = trade.pnlcomm  
﻿  

====================================================================== 

==========  

# 文件: multitrades\multitrades.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  
﻿###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

import itertools  

  

# The above could be sent to an independent module  

import backtrader as bt  

import backtrader.feeds as btfeeds  

import backtrader.indicators as btind  

  

import mtradeobserver  

  

  

class MultiTradeStrategy(bt.Strategy):  

    '''This strategy buys/sells upong the close price crossing  

    upwards/downwards a Simple Moving Average.  

  

    It can be a long-only strategy by setting the param "onlylong" to  

True  

    '''  

    params = dict(  

        period=15,  

        stake=1,  
﻿        printout=False,  

        onlylong=False,  

        mtrade=False,  

    )  

  

    def log(self, txt, dt=None):  

        if self.p.printout:  

            dt = dt or self.data.datetime[0]  

            dt = bt.num2date(dt)  

            print('%s, %s' % (dt.isoformat(), txt))  

  

    def __init__(self):  

        # To control operation entries  

        self.order = None  

  

        # Create SMA on 2nd data  

        sma = btind.MovAv.SMA(self.data, period=self.p.period)  

        # Create a CrossOver Signal from close an moving average  

        self.signal = btind.CrossOver(self.data.close, sma)  

  

        # To alternate amongst different tradeids  

        if self.p.mtrade:  

            self.tradeid = itertools.cycle([0, 1, 2])  

        else:  

            self.tradeid = itertools.cycle([0])  

  

    def next(self):  
﻿        if self.order:  

            return  # if an order is active, no new orders are allowed  

  

        if self.signal > 0.0:  # cross upwards  

            if self.position:  

                self.log('CLOSE SHORT , %.2f' % self.data.close[0])  

                self.close(tradeid=self.curtradeid)  

  

            self.log('BUY CREATE , %.2f' % self.data.close[0])  

            self.curtradeid = next(self.tradeid)  

            self.buy(size=self.p.stake, tradeid=self.curtradeid)  

  

        elif self.signal < 0.0:  

            if self.position:  

                self.log('CLOSE LONG , %.2f' % self.data.close[0])  

                self.close(tradeid=self.curtradeid)  

  

            if not self.p.onlylong:  

                self.log('SELL CREATE , %.2f' % self.data.close[0])  

                self.curtradeid = next(self.tradeid)  

                self.sell(size=self.p.stake, tradeid=self.curtradeid)  

  

    def notify_order(self, order):  

        if order.status in [bt.Order.Submitted, bt.Order.Accepted]:  

            return  # Await further notifications  

  

        if order.status == order.Completed:  
﻿            if order.isbuy():  

                buytxt = 'BUY COMPLETE, %.2f' % order.executed.price  

                self.log(buytxt, order.executed.dt)  

            else:  

                selltxt = 'SELL COMPLETE, %.2f' % order.executed.price  

                self.log(selltxt, order.executed.dt)  

  

        elif order.status in [order.Expired, order.Canceled,  

order.Margin]:  

            self.log('%s ,' % order.Status[order.status])  

            pass  # Simply log  

  

        # Allow new orders  

        self.order = None  

  

    def notify_trade(self, trade):  

        if trade.isclosed:  

            self.log('TRADE PROFIT, GROSS %.2f, NET %.2f' %  

                      (trade.pnl, trade.pnlcomm))  

  

        elif trade.justopened:  

            self.log('TRADE OPENED, SIZE %2d' % trade.size)  

  

  

def runstrategy():  

    args = parse_args()  

  
﻿    # Create a cerebro  

    cerebro = bt.Cerebro()  

  

    # Get the dates from the args  

    fromdate = datetime.datetime.strptime(args.fromdate, '%Y-%m-%d')  

    todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

  

    # Create the 1st data  

    data = btfeeds.BacktraderCSVData(  

        dataname=args.data,  

        fromdate=fromdate,  

        todate=todate)  

  

    # Add the 1st data to cerebro  

    cerebro.adddata(data)  

  

    # Add the strategy  

    cerebro.addstrategy(MultiTradeStrategy,  

                        period=args.period,  

                        onlylong=args.onlylong,  

                        stake=args.stake,  

                        printout=args.printout,  

                        mtrade=args.mtrade)  

  

    # Add the commission - only stocks like a for each operation  

    cerebro.broker.setcash(args.cash)  

  
﻿    # Add the commission - only stocks like a for each operation  

    cerebro.broker.setcommission(commission=args.comm,  

                                 mult=args.mult,  

                                 margin=args.margin)  

  

    # Add the MultiTradeObserver  

    cerebro.addobserver(mtradeobserver.MTradeObserver)  

  

    # And run it  

    cerebro.run()  

  

    # Plot if requested  

    if args.plot:  

        cerebro.plot(numfigs=args.numfigs, volume=False, zdown=False)  

  

  

def parse_args():  

    parser = argparse.ArgumentParser(description='MultiTrades')  

  

    parser.add_argument('--data', '-d',  

                        default='../../datas/2006-day-001.txt',  

                        help='data to add to the system')  

  

    parser.add_argument('--fromdate', '-f',  

                        default='2006-01-01',  

                        help='Starting date in YYYY-MM-DD format')  

  
﻿    parser.add_argument('--todate', '-t',  

                        default='2006-12-31',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--mtrade', action='store_true',  

                        help='Activate MultiTrade Ids')  

  

    parser.add_argument('--period', default=15, type=int,  

                        help='Period to apply to the Simple Moving  

Average')  

  

    parser.add_argument('--onlylong', '-ol', action='store_true',  

                        help='Do only long operations')  

  

    parser.add_argument('--printout', action='store_true',  

                        help='Print operation log from strategy')  

  

    parser.add_argument('--cash', default=100000, type=int,  

                        help='Starting Cash')  

  

    parser.add_argument('--comm', default=2, type=float,  

                        help='Commission for operation')  

  

    parser.add_argument('--mult', default=10, type=int,  

                        help='Multiplier for futures')  

  

    parser.add_argument('--margin', default=2000.0, type=float,  
﻿                        help='Margin for each future')  

  

    parser.add_argument('--stake', default=1, type=int,  

                        help='Stake to apply in each operation')  

  

    parser.add_argument('--plot', '-p', action='store_true',  

                        help='Plot the read data')  

  

    parser.add_argument('--numfigs', '-n', default=1,  

                        help='Plot using numfigs figures')  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrategy()  

  

====================================================================== 

==========  

# 文件: oandatest\oandatest.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  
﻿# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

  

# The above could be sent to an independent module  

import backtrader as bt  

from backtrader.utils import flushfile  # win32 quick stdout flushing  
﻿  

StoreCls = bt.stores.OandaStore  

DataCls = bt.feeds.OandaData  

# BrokerCls = bt.brokers.OandaBroker  

  

  

class TestStrategy(bt.Strategy):  

    params = dict(  

        smaperiod=5,  

        trade=False,  

        stake=10,  

        exectype=bt.Order.Market,  

        stopafter=0,  

        valid=None,  

        cancel=0,  

        donotcounter=False,  

        sell=False,  

        usebracket=False,  

    )  

  

    def __init__(self):  

        # To control operation entries  

        self.orderid = list()  

        self.order = None  

  

        self.counttostop = 0  

        self.datastatus = 0  
﻿  

        # Create SMA on 2nd data  

        self.sma = bt.indicators.MovAv.SMA(self.data,  

period=self.p.smaperiod)  

  

        print('--------------------------------------------------')  

        print('Strategy Created')  

        print('--------------------------------------------------')  

  

    def notify_data(self, data, status, *args, **kwargs):  

        print('*' * 5, 'DATA NOTIF:', data._getstatusname(status),  

*args)  

        if status == data.LIVE:  

            self.counttostop = self.p.stopafter  

            self.datastatus = 1  

  

    def notify_store(self, msg, *args, **kwargs):  

        print('*' * 5, 'STORE NOTIF:', msg)  

  

    def notify_order(self, order):  

        if order.status in [order.Completed, order.Cancelled,  

order.Rejected]:  

            self.order = None  

  

        print('-' * 50, 'ORDER BEGIN', datetime.datetime.now())  

        print(order)  

        print('-' * 50, 'ORDER END')  

  
﻿    def notify_trade(self, trade):  

        print('-' * 50, 'TRADE BEGIN', datetime.datetime.now())  

        print(trade)  

        print('-' * 50, 'TRADE END')  

  

    def prenext(self):  

        self.next(frompre=True)  

  

    def next(self, frompre=False):  

        txt = list()  

        txt.append('Data0')  

        txt.append('%04d' % len(self.data0))  

        dtfmt = '%Y-%m-%dT%H:%M:%S.%f'  

        txt.append('{:f}'.format(self.data.datetime[0]))  

        txt.append('%s' %  

self.data.datetime.datetime(0).strftime(dtfmt))  

        txt.append('{:f}'.format(self.data.open[0]))  

        txt.append('{:f}'.format(self.data.high[0]))  

        txt.append('{:f}'.format(self.data.low[0]))  

        txt.append('{:f}'.format(self.data.close[0]))  

        txt.append('{:6d}'.format(int(self.data.volume[0])))  

        txt.append('{:d}'.format(int(self.data.openinterest[0])))  

        txt.append('{:f}'.format(self.sma[0]))  

        print(', '.join(txt))  

  

        if len(self.datas) > 1 and len(self.data1):  

            txt = list()  
﻿            txt.append('Data1')  

            txt.append('%04d' % len(self.data1))  

            dtfmt = '%Y-%m-%dT%H:%M:%S.%f'  

            txt.append('{}'.format(self.data1.datetime[0]))  

            txt.append('%s' %  

self.data1.datetime.datetime(0).strftime(dtfmt))  

            txt.append('{}'.format(self.data1.open[0]))  

            txt.append('{}'.format(self.data1.high[0]))  

            txt.append('{}'.format(self.data1.low[0]))  

            txt.append('{}'.format(self.data1.close[0]))  

            txt.append('{}'.format(self.data1.volume[0]))  

            txt.append('{}'.format(self.data1.openinterest[0]))  

            txt.append('{}'.format(float('NaN')))  

            print(', '.join(txt))  

  

        if self.counttostop:  # stop after x live lines  

            self.counttostop -= 1  

            if not self.counttostop:  

                self.env.runstop()  

                return  

  

        if not self.p.trade:  

            return  

  

        if self.datastatus and not self.position and len(self.orderid)  

< 1:  

            if not self.p.usebracket:  
﻿                if not self.p.sell:  

                    # price = round(self.data0.close[0] * 0.90, 2)  

                    price = self.data0.close[0] - 0.005  

                    self.order = self.buy(size=self.p.stake,  

                                          exectype=self.p.exectype,  

                                          price=price,  

                                          valid=self.p.valid)  

                else:  

                    # price = round(self.data0.close[0] * 1.10, 4)  

                    price = self.data0.close[0] - 0.05  

                    self.order = self.sell(size=self.p.stake,  

                                           exectype=self.p.exectype,  

                                           price=price,  

                                           valid=self.p.valid)  

  

            else:  

                print('USING BRACKET')  

                price = self.data0.close[0] - 0.05  

                self.order, _, _ = self.buy_bracket(size=self.p.stake,  

                                                     

exectype=bt.Order.Market,  

                                                    price=price,  

                                                    stopprice=price -  

0.10,  

                                                    limitprice=price +  

0.10,  

                                                     

valid=self.p.valid)  
﻿  

            self.orderid.append(self.order)  

        elif self.position and not self.p.donotcounter:  

            if self.order is None:  

                if not self.p.sell:  

                    self.order = self.sell(size=self.p.stake // 2,  

                                           exectype=bt.Order.Market,  

                                           price=self.data0.close[0])  

                else:  

                    self.order = self.buy(size=self.p.stake // 2,  

                                          exectype=bt.Order.Market,  

                                          price=self.data0.close[0])  

  

            self.orderid.append(self.order)  

  

        elif self.order is not None and self.p.cancel:  

            if self.datastatus > self.p.cancel:  

                self.cancel(self.order)  

  

        if self.datastatus:  

            self.datastatus += 1  

  

    def start(self):  

        if self.data0.contractdetails is not None:  

            print('-- Contract Details:')  

            print(self.data0.contractdetails)  

  
﻿        header = ['Datetime', 'Open', 'High', 'Low', 'Close',  

'Volume',  

                  'OpenInterest', 'SMA']  

        print(', '.join(header))  

  

        self.done = False  

  

  

def runstrategy():  

    args = parse_args()  

  

    # Create a cerebro  

    cerebro = bt.Cerebro()  

  

    storekwargs = dict(  

        token=args.token,  

        account=args.account,  

        practice=not args.live  

    )  

  

    if not args.no_store:  

        store = StoreCls(**storekwargs)  

  

    if args.broker:  

        if args.no_store:  

            broker = BrokerCls(**storekwargs)  

        else:  
﻿            broker = store.getbroker()  

  

        cerebro.setbroker(broker)  

  

    timeframe = bt.TimeFrame.TFrame(args.timeframe)  

    # Manage data1 parameters  

    tf1 = args.timeframe1  

    tf1 = bt.TimeFrame.TFrame(tf1) if tf1 is not None else timeframe  

    cp1 = args.compression1  

    cp1 = cp1 if cp1 is not None else args.compression  

  

    if args.resample or args.replay:  

        datatf = datatf1 = bt.TimeFrame.Ticks  

        datacomp = datacomp1 = 1  

    else:  

        datatf = timeframe  

        datacomp = args.compression  

        datatf1 = tf1  

        datacomp1 = cp1  

  

    fromdate = None  

    if args.fromdate:  

        dtformat = '%Y-%m-%d' + ('T%H:%M:%S' * ('T' in args.fromdate))  

        fromdate = datetime.datetime.strptime(args.fromdate, dtformat)  

  

    DataFactory = DataCls if args.no_store else store.getdata  

  
﻿    datakwargs = dict(  

        timeframe=datatf, compression=datacomp,  

        qcheck=args.qcheck,  

        historical=args.historical,  

        fromdate=fromdate,  

        bidask=args.bidask,  

        useask=args.useask,  

        backfill_start=not args.no_backfill_start,  

        backfill=not args.no_backfill,  

        tz=args.timezone  

    )  

  

    if args.no_store and not args.broker:   # neither store nor broker  

        datakwargs.update(storekwargs)  # pass the store args over the  

data  

  

    data0 = DataFactory(dataname=args.data0, **datakwargs)  

  

    data1 = None  

    if args.data1 is not None:  

        if args.data1 != args.data0:  

            datakwargs['timeframe'] = datatf1  

            datakwargs['compression'] = datacomp1  

            data1 = DataFactory(dataname=args.data1, **datakwargs)  

        else:  

            data1 = data0  

  
﻿    rekwargs = dict(  

        timeframe=timeframe, compression=args.compression,  

        bar2edge=not args.no_bar2edge,  

        adjbartime=not args.no_adjbartime,  

        rightedge=not args.no_rightedge,  

        takelate=not args.no_takelate,  

    )  

  

    if args.replay:  

        cerebro.replaydata(data0, **rekwargs)  

  

        if data1 is not None:  

            rekwargs['timeframe'] = tf1  

            rekwargs['compression'] = cp1  

            cerebro.replaydata(data1, **rekwargs)  

  

    elif args.resample:  

        cerebro.resampledata(data0, **rekwargs)  

  

        if data1 is not None:  

            rekwargs['timeframe'] = tf1  

            rekwargs['compression'] = cp1  

            cerebro.resampledata(data1, **rekwargs)  

  

    else:  

        cerebro.adddata(data0)  

        if data1 is not None:  
﻿            cerebro.adddata(data1)  

  

    if args.valid is None:  

        valid = None  

    else:  

        valid = datetime.timedelta(seconds=args.valid)  

    # Add the strategy  

    cerebro.addstrategy(TestStrategy,  

                        smaperiod=args.smaperiod,  

                        trade=args.trade,  

                        exectype=bt.Order.ExecType(args.exectype),  

                        stake=args.stake,  

                        stopafter=args.stopafter,  

                        valid=valid,  

                        cancel=args.cancel,  

                        donotcounter=args.donotcounter,  

                        sell=args.sell,  

                        usebracket=args.usebracket)  

  

    # Live data ... avoid long data accumulation by switching to  

"exactbars"  

    cerebro.run(exactbars=args.exactbars)  

    if args.exactbars < 1:  # plotting is possible  

        if args.plot:  

            pkwargs = dict(style='line')  

            if args.plot is not True:  # evals to True but is not True  

                npkwargs = eval('dict(' + args.plot + ')')  # args  
﻿were passed  

                pkwargs.update(npkwargs)  

  

            cerebro.plot(**pkwargs)  

  

  

def parse_args(pargs=None):  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='Test Oanda integration')  

  

    parser.add_argument('--exactbars', default=1, type=int,  

                        required=False, action='store',  

                        help='exactbars level, use 0/-1/-2 to enable  

plotting')  

  

    parser.add_argument('--stopafter', default=0, type=int,  

                        required=False, action='store',  

                        help='Stop after x lines of LIVE data')  

  

    parser.add_argument('--no-store',  

                        required=False, action='store_true',  

                        help='Do not use the store pattern')  

  

    parser.add_argument('--debug',  

                        required=False, action='store_true',  

                        help='Display all info received from source')  
﻿  

    parser.add_argument('--token', default=None,  

                        required=True, action='store',  

                        help='Access token to use')  

  

    parser.add_argument('--account', default=None,  

                        required=True, action='store',  

                        help='Account identifier to use')  

  

    parser.add_argument('--live', default=None,  

                        required=False, action='store',  

                        help='Go to live server rather than practice')  

  

    parser.add_argument('--qcheck', default=0.5, type=float,  

                        required=False, action='store',  

                        help=('Timeout for periodic '  

                              'notification/resampling/replaying  

check'))  

  

    parser.add_argument('--data0', default=None,  

                        required=True, action='store',  

                        help='data 0 into the system')  

  

    parser.add_argument('--data1', default=None,  

                        required=False, action='store',  

                        help='data 1 into the system')  

  
﻿    parser.add_argument('--timezone', default=None,  

                        required=False, action='store',  

                        help='timezone to get time output into (pytz  

names)')  

  

    parser.add_argument('--bidask', default=None,  

                        required=False, action='store_true',  

                        help='Use bidask ... if False use midpoint')  

  

    parser.add_argument('--useask', default=None,  

                        required=False, action='store_true',  

                        help='Use the "ask" of bidask  

prices/streaming')  

  

    parser.add_argument('--no-backfill_start',  

                        required=False, action='store_true',  

                        help='Disable backfilling at the start')  

  

    parser.add_argument('--no-backfill',  

                        required=False, action='store_true',  

                        help='Disable backfilling after a  

disconnection')  

  

    parser.add_argument('--historical',  

                        required=False, action='store_true',  

                        help='do only historical download')  

  

    parser.add_argument('--fromdate',  
﻿                        required=False, action='store',  

                        help=('Starting date for historical download '  

                              'with format: YYYY-MM-DD[THH:MM:SS]'))  

  

    parser.add_argument('--smaperiod', default=5, type=int,  

                        required=False, action='store',  

                        help='Period to apply to the Simple Moving  

Average')  

  

    pgroup = parser.add_mutually_exclusive_group(required=False)  

  

    pgroup.add_argument('--replay',  

                        required=False, action='store_true',  

                        help='replay to chosen timeframe')  

  

    pgroup.add_argument('--resample',  

                        required=False, action='store_true',  

                        help='resample to chosen timeframe')  

  

    parser.add_argument('--timeframe', default=bt.TimeFrame.Names[1],  

                        choices=bt.TimeFrame.Names,  

                        required=False, action='store',  

                        help='TimeFrame for Resample/Replay')  

  

    parser.add_argument('--compression', default=1, type=int,  

                        required=False, action='store',  

                        help='Compression for Resample/Replay')  
﻿  

    parser.add_argument('--timeframe1', default=None,  

                        choices=bt.TimeFrame.Names,  

                        required=False, action='store',  

                        help='TimeFrame for Resample/Replay - Data1')  

  

    parser.add_argument('--compression1', default=None, type=int,  

                        required=False, action='store',  

                        help='Compression for Resample/Replay -  

Data1')  

  

    parser.add_argument('--no-takelate',  

                        required=False, action='store_true',  

                        help=('resample/replay, do not accept late  

samples'))  

  

    parser.add_argument('--no-bar2edge',  

                        required=False, action='store_true',  

                        help='no bar2edge for resample/replay')  

  

    parser.add_argument('--no-adjbartime',  

                        required=False, action='store_true',  

                        help='no adjbartime for resample/replay')  

  

    parser.add_argument('--no-rightedge',  

                        required=False, action='store_true',  

                        help='no rightedge for resample/replay')  
﻿  

    parser.add_argument('--broker',  

                        required=False, action='store_true',  

                        help='Use Oanda as broker')  

  

    parser.add_argument('--trade',  

                        required=False, action='store_true',  

                        help='Do Sample Buy/Sell operations')  

  

    parser.add_argument('--sell',  

                        required=False, action='store_true',  

                        help='Start by selling')  

  

    parser.add_argument('--usebracket',  

                        required=False, action='store_true',  

                        help='Test buy_bracket')  

  

    parser.add_argument('--donotcounter',  

                        required=False, action='store_true',  

                        help='Do not counter the 1st operation')  

  

    parser.add_argument('--exectype', default=bt.Order.ExecTypes[0],  

                        choices=bt.Order.ExecTypes,  

                        required=False, action='store',  

                        help='Execution to Use when opening position')  

  

    parser.add_argument('--stake', default=10, type=int,  
﻿                        required=False, action='store',  

                        help='Stake to use in buy operations')  

  

    parser.add_argument('--valid', default=None, type=float,  

                        required=False, action='store',  

                        help='Seconds to keep the order alive (0 means  

DAY)')  

  

    parser.add_argument('--cancel', default=0, type=int,  

                        required=False, action='store',  

                        help=('Cancel a buy order after n bars in  

operation,'  

                              ' to be combined with orders like  

Limit'))  

  

    # Plot options  

    parser.add_argument('--plot', '-p', nargs='?', required=False,  

                        metavar='kwargs', const=True,  

                        help=('Plot the read data applying any kwargs  

passed\n'  

                              '\n'  

                              'For example (escape the quotes if  

needed):\n'  

                              '\n'  

                              '  --plot style="candle" (to plot  

candles)\n'))  

  

    if pargs is not None:  
﻿        return parser.parse_args(pargs)  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrategy()  

  

====================================================================== 

==========  

# 文件: observer-benchmark\observer-benchmark.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  
﻿# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

  

import argparse  

import datetime  

import random  

  

import backtrader as bt  

  

  

class St(bt.Strategy):  

    params = (  

         ('period', 10),  

         ('printout', False),  

         ('stake', 1000),  

    )  

  
﻿    def __init__(self):  

        sma = bt.indicators.SMA(self.data, period=self.p.period)  

        self.crossover = bt.indicators.CrossOver(self.data, sma)  

  

    def start(self):  

        if self.p.printout:  

            txtfields = list()  

            txtfields.append('Len')  

            txtfields.append('Datetime')  

            txtfields.append('Open')  

            txtfields.append('High')  

            txtfields.append('Low')  

            txtfields.append('Close')  

            txtfields.append('Volume')  

            txtfields.append('OpenInterest')  

            print(','.join(txtfields))  

  

    def next(self):  

        if self.p.printout:  

            # Print only 1st data ... is just a check that things are  

running  

            txtfields = list()  

            txtfields.append('%04d' % len(self))  

             

txtfields.append(self.data.datetime.datetime(0).isoformat())  

            txtfields.append('%.2f' % self.data0.open[0])  

            txtfields.append('%.2f' % self.data0.high[0])  
﻿            txtfields.append('%.2f' % self.data0.low[0])  

            txtfields.append('%.2f' % self.data0.close[0])  

            txtfields.append('%.2f' % self.data0.volume[0])  

            txtfields.append('%.2f' % self.data0.openinterest[0])  

            print(','.join(txtfields))  

  

        if self.position:  

            if self.crossover < 0.0:  

                if self.p.printout:  

                    print('CLOSE {} @%{}'.format(size,  

                                                 self.data.close[0]))  

                self.close()  

  

        else:  

            if self.crossover > 0.0:  

                self.buy(size=self.p.stake)  

                if self.p.printout:  

                    print('BUY   {} @%{}'.format(self.p.stake,  

                                                self.data.close[0]))  

  

  

TIMEFRAMES = {  

    None: None,  

    'days': bt.TimeFrame.Days,  

    'weeks': bt.TimeFrame.Weeks,  

    'months': bt.TimeFrame.Months,  

    'years': bt.TimeFrame.Years,  
﻿    'notimeframe': bt.TimeFrame.NoTimeFrame,  

}  

  

  

def runstrat(args=None):  

    args = parse_args(args)  

  

    cerebro = bt.Cerebro()  

    cerebro.broker.set_cash(args.cash)  

  

    dkwargs = dict()  

    if args.fromdate:  

        fromdate = datetime.datetime.strptime(args.fromdate,  

'%Y-%m-%d')  

        dkwargs['fromdate'] = fromdate  

  

    if args.todate:  

        todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

        dkwargs['todate'] = todate  

  

    data0 = bt.feeds.YahooFinanceCSVData(dataname=args.data0,  

**dkwargs)  

    cerebro.adddata(data0, name='Data0')  

  

    cerebro.addstrategy(St,  

                        period=args.period,  

                        stake=args.stake,  
﻿                        printout=args.printout)  

  

    if args.timereturn:  

        cerebro.addobserver(bt.observers.TimeReturn,  

                            timeframe=TIMEFRAMES[args.timeframe])  

    else:  

        benchdata = data0  

        if args.benchdata1:  

            data1 = bt.feeds.YahooFinanceCSVData(dataname=args.data1,  

**dkwargs)  

            cerebro.adddata(data1, name='Data1')  

            benchdata = data1  

  

        cerebro.addobserver(bt.observers.Benchmark,  

                            data=benchdata,  

                            timeframe=TIMEFRAMES[args.timeframe])  

  

    cerebro.run()  

  

    if args.plot:  

        pkwargs = dict()  

        if args.plot is not True:  # evals to True but is not True  

            pkwargs = eval('dict(' + args.plot + ')')  # args were  

passed  

  

        cerebro.plot(**pkwargs)  

  
﻿  

def parse_args(pargs=None):  

  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='Benchmark/TimeReturn Observers Sample')  

  

    parser.add_argument('--data0', required=False,  

                        default='../../datas/yhoo-1996-2015.txt',  

                        help='Data0 to be read in')  

  

    parser.add_argument('--data1', required=False,  

                        default='../../datas/orcl-1995-2014.txt',  

                        help='Data1 to be read in')  

  

    parser.add_argument('--benchdata1', required=False,  

action='store_true',  

                        help=('Benchmark against data1'))  

  

    parser.add_argument('--fromdate', required=False,  

                        default='2005-01-01',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', required=False,  

                        default='2006-12-31',  

                        help='Ending date in YYYY-MM-DD format')  

  
﻿    parser.add_argument('--printout', required=False,  

action='store_true',  

                        help=('Print data lines'))  

  

    parser.add_argument('--cash', required=False, action='store',  

                        type=float, default=50000,  

                        help=('Cash to start with'))  

  

    parser.add_argument('--period', required=False, action='store',  

                        type=int, default=30,  

                        help=('Period for the crossover moving  

average'))  

  

    parser.add_argument('--stake', required=False, action='store',  

                        type=int, default=1000,  

                        help=('Stake to apply for the buy  

operations'))  

  

    parser.add_argument('--timereturn', required=False,  

action='store_true',  

                        default=None,  

                        help=('Use TimeReturn observer instead of  

Benchmark'))  

  

    parser.add_argument('--timeframe', required=False, action='store',  

                        default=None, choices=TIMEFRAMES.keys(),  

                        help=('TimeFrame to apply to the Observer'))  

  
﻿    # Plot options  

    parser.add_argument('--plot', '-p', nargs='?', required=False,  

                        metavar='kwargs', const=True,  

                        help=('Plot the read data applying any kwargs  

passed\n'  

                              '\n'  

                              'For example:\n'  

                              '\n'  

                              '  --plot style="candle" (to plot  

candles)\n'))  

  

    if pargs:  

        return parser.parse_args(pargs)  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: observers\observers-default-drawdown.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  
﻿###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

import os.path  

import time  
﻿import sys  

  

  

import backtrader as bt  

import backtrader.feeds as btfeeds  

import backtrader.indicators as btind  

  

  

class MyStrategy(bt.Strategy):  

    params = (('smaperiod', 15),)  

  

    def log(self, txt, dt=None):  

        ''' Logging function fot this strategy'''  

        dt = dt or self.data.datetime[0]  

        if isinstance(dt, float):  

            dt = bt.num2date(dt)  

        print('%s, %s' % (dt.isoformat(), txt))  

  

    def __init__(self):  

        # SimpleMovingAverage on main data  

        # Equivalent to -> sma = btind.SMA(self.data,  

period=self.p.smaperiod)  

        sma = btind.SMA(period=self.p.smaperiod)  

  

        # CrossOver (1: up, -1: down) close / sma  

        self.buysell = btind.CrossOver(self.data.close, sma,  

plot=True)  
﻿  

        # Sentinel to None: new ordersa allowed  

        self.order = None  

  

    def next(self):  

        # Access -1, because drawdown[0] will be calculated after  

"next"  

        self.log('DrawDown: %.2f' % self.stats.drawdown.drawdown[-1])  

        self.log('MaxDrawDown: %.2f' %  

self.stats.drawdown.maxdrawdown[-1])  

  

        # Check if we are in the market  

        if self.position:  

            if self.buysell < 0:  

                self.log('SELL CREATE, %.2f' % self.data.close[0])  

                self.sell()  

  

        elif self.buysell > 0:  

            self.log('BUY CREATE, %.2f' % self.data.close[0])  

            self.buy()  

  

  

def runstrat():  

    cerebro = bt.Cerebro()  

  

    data = bt.feeds.BacktraderCSVData(dataname='../../datas/2006-day- 

001.txt')  

    cerebro.adddata(data)  
﻿  

    cerebro.addobserver(bt.observers.DrawDown)  

    cerebro.addobserver(bt.observers.DrawDown_Old)  

  

    cerebro.addstrategy(MyStrategy)  

    cerebro.run()  

  

    cerebro.plot()  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: observers\observers-default.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  
﻿# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import backtrader as bt  

import backtrader.feeds as btfeeds  

  

if __name__ == '__main__':  

    cerebro = bt.Cerebro(stdstats=True)  

    cerebro.addstrategy(bt.Strategy)  

  

    data = bt.feeds.BacktraderCSVData(dataname='../../datas/2006-day- 

001.txt')  

    cerebro.adddata(data)  

  
﻿    cerebro.run()  

    cerebro.plot()  

  

====================================================================== 

==========  

# 文件: observers\observers-orderobserver.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  
﻿<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import datetime  

  

import backtrader as bt  

import backtrader.feeds as btfeeds  

import backtrader.indicators as btind  

  

from orderobserver import OrderObserver  

  

  

class MyStrategy(bt.Strategy):  

    params = (  

         ('smaperiod', 15),  

         ('limitperc', 1.0),  

         ('valid', 7),  

    )  

  

    def log(self, txt, dt=None):  

        ''' Logging function fot this strategy'''  

        dt = dt or self.data.datetime[0]  

        if isinstance(dt, float):  
﻿            dt = bt.num2date(dt)  

        print('%s, %s' % (dt.isoformat(), txt))  

  

    def notify_order(self, order):  

        if order.status in [order.Submitted, order.Accepted]:  

            # Buy/Sell order submitted/accepted to/by broker - Nothing  

to do  

            self.log('ORDER ACCEPTED/SUBMITTED', dt=order.created.dt)  

            self.order = order  

            return  

  

        if order.status in [order.Expired]:  

            self.log('BUY EXPIRED')  

  

        elif order.status in [order.Completed]:  

            if order.isbuy():  

                self.log(  

                    'BUY EXECUTED, Price: %.2f, Cost: %.2f,  

Comm %.2f' %  

                     (order.executed.price,  

                     order.executed.value,  

                     order.executed.comm))  

  

            else:  # Sell  

                self.log('SELL EXECUTED, Price: %.2f, Cost: %.2f,  

Comm %.2f' %  

                          (order.executed.price,  

                          order.executed.value,  
﻿                          order.executed.comm))  

  

        # Sentinel to None: new orders allowed  

        self.order = None  

  

    def __init__(self):  

        # SimpleMovingAverage on main data  

        # Equivalent to -> sma = btind.SMA(self.data,  

period=self.p.smaperiod)  

        sma = btind.SMA(period=self.p.smaperiod)  

  

        # CrossOver (1: up, -1: down) close / sma  

        self.buysell = btind.CrossOver(self.data.close, sma,  

plot=True)  

  

        # Sentinel to None: new ordersa allowed  

        self.order = None  

  

    def next(self):  

        if self.order:  

            # pending order ... do nothing  

            return  

  

        # Check if we are in the market  

        if self.position:  

            if self.buysell < 0:  

                self.log('SELL CREATE, %.2f' % self.data.close[0])  
﻿                self.sell()  

  

        elif self.buysell > 0:  

            plimit = self.data.close[0] * (1.0 - self.p.limitperc /  

100.0)  

            valid = self.data.datetime.date(0) + \  

                datetime.timedelta(days=self.p.valid)  

            self.log('BUY CREATE, %.2f' % plimit)  

            self.buy(exectype=bt.Order.Limit, price=plimit,  

valid=valid)  

  

  

def runstrat():  

    cerebro = bt.Cerebro()  

  

    data = bt.feeds.BacktraderCSVData(dataname='../../datas/2006-day- 

001.txt')  

    cerebro.adddata(data)  

  

    cerebro.addobserver(OrderObserver)  

  

    cerebro.addstrategy(MyStrategy)  

    cerebro.run()  

  

    cerebro.plot()  

  

  

if __name__ == '__main__':  
﻿    runstrat()  

  

====================================================================== 

==========  

# 文件: observers\orderobserver.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  
﻿#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import math  

  

import backtrader as bt  

  

  

class OrderObserver(bt.observer.Observer):  

    lines = ('created', 'expired',)  

  

    plotinfo = dict(plot=True, subplot=True, plotlinelabels=True)  

  

    plotlines = dict(  

        created=dict(marker='*', markersize=8.0, color='lime',  

fillstyle='full'),  

        expired=dict(marker='s', markersize=8.0, color='red',  

fillstyle='full')  

    )  

  

    def next(self):  

        for order in self._owner._orderspending:  

            if order.data is not self.data:  

                continue  

  
﻿            if not order.isbuy():  

                continue  

  

            # Only interested in "buy" orders, because the sell orders  

            # in the strategy are Market orders and will be  

immediately  

            # executed  

  

            if order.status in [bt.Order.Accepted,  

bt.Order.Submitted]:  

                self.lines.created[0] = order.created.price  

  

            elif order.status in [bt.Order.Expired]:  

                self.lines.expired[0] = order.created.price  

  

====================================================================== 

==========  

# 文件: oco\oco.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  
﻿# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

  

import argparse  

import datetime  

  

import backtrader as bt  

  

  

class St(bt.Strategy):  
﻿    params = dict(  

        ma=bt.ind.SMA,  

        p1=5,  

        p2=15,  

        limit=0.005,  

        limdays=3,  

        limdays2=1000,  

        hold=10,  

        usetarget=False,  # use order_target_size  

        switchp1p2=False,  # switch prices of order1 and order2  

        oco1oco2=False,  # False - use order1 as oco for order3, else  

order2  

        do_oco=True,  # use oco or not  

    )  

  

    def notify_order(self, order):  

        print('{}: Order ref: {} / Type {} / Status {}'.format(  

            self.data.datetime.date(0),  

            order.ref, 'Buy' * order.isbuy() or 'Sell',  

            order.getstatusname()))  

  

        if order.status == order.Completed:  

            self.holdstart = len(self)  

  

        if not order.alive() and order.ref in self.orefs:  

            self.orefs.remove(order.ref)  

  
﻿    def __init__(self):  

        ma1, ma2 = self.p.ma(period=self.p.p1),  

self.p.ma(period=self.p.p2)  

        self.cross = bt.ind.CrossOver(ma1, ma2)  

  

        self.orefs = list()  

  

        if self.p.usetarget:  

            print('-' * 5, 'Using order_target_size')  

            self._dobuy = self.order_target_size  

            self._doclose = self.order_target_size  

        else:  

            self._dobuy = self.buy  

            self._doclose = self.close  

  

    def next(self):  

        if self.orefs:  

            return  # pending orders do nothing  

  

        if not self.position:  

            if self.cross > 0.0:  # crossing up  

  

                p1 = self.data.close[0] * (1.0 - self.p.limit)  

                p2 = self.data.close[0] * (1.0 - 2 * 2 * self.p.limit)  

                p3 = self.data.close[0] * (1.0 - 3 * 3 * self.p.limit)  

  

                valid1 = datetime.timedelta(self.p.limdays)  
﻿                valid2 = valid3 = datetime.timedelta(self.p.limdays2)  

  

                if self.p.switchp1p2:  

                    p1, p2 = p2, p1  

                    valid1, valid2 = valid2, valid1  

  

                print('valid1 is:', valid1)  

  

                kargs = dict(exectype=bt.Order.Limit)  

                kargs[('target' * self.p.usetarget) or 'size'] = 1  

  

                o1 = self._dobuy(price=p1, valid=valid1, **kargs)  

                print('{}: Oref {} / Buy at {}'.format(  

                    self.datetime.date(), o1.ref, p1))  

  

                oco2 = o1 if self.p.do_oco else None  

                o2 = self._dobuy(price=p2, valid=valid2, oco=oco2,  

**kargs)  

  

                print('{}: Oref {} / Buy at {}'.format(  

                    self.datetime.date(), o2.ref, p2))  

  

                if self.p.do_oco:  

                    oco3 = o1 if not self.p.oco1oco2 else oco2  

                else:  

                    oco3 = None  

  
﻿                o3 = self._dobuy(price=p3, valid=valid3, oco=oco3,  

**kargs)  

  

                print('{}: Oref {} / Buy at {}'.format(  

                    self.datetime.date(), o3.ref, p3))  

  

                self.orefs = [o1.ref, o2.ref, o3.ref]  

  

        else:  # in the market  

            if (len(self) - self.holdstart) >= self.p.hold:  

                self._doclose()  

  

  

def runstrat(args=None):  

    args = parse_args(args)  

  

    cerebro = bt.Cerebro()  

  

    # Data feed kwargs  

    kwargs = dict()  

  

    # Parse from/to-date  

    dtfmt, tmfmt = '%Y-%m-%d', 'T%H:%M:%S'  

    for a, d in ((getattr(args, x), x) for x in ['fromdate',  

'todate']):  

        if a:  

            strpfmt = dtfmt + tmfmt * ('T' in a)  
﻿            kwargs[d] = datetime.datetime.strptime(a, strpfmt)  

  

    # Data feed  

    data0 = bt.feeds.BacktraderCSVData(dataname=args.data0, **kwargs)  

    cerebro.adddata(data0)  

  

    # Broker  

    cerebro.broker = bt.brokers.BackBroker(**eval('dict(' +  

args.broker + ')'))  

  

    # Sizer  

    cerebro.addsizer(bt.sizers.FixedSize, **eval('dict(' + args.sizer  

+ ')'))  

  

    # Strategy  

    cerebro.addstrategy(St, **eval('dict(' + args.strat + ')'))  

  

    # Execute  

    cerebro.run(**eval('dict(' + args.cerebro + ')'))  

  

    if args.plot:  # Plot if requested to  

        cerebro.plot(**eval('dict(' + args.plot + ')'))  

  

  

def parse_args(pargs=None):  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  
﻿        description=(  

            'Sample Skeleton'  

        )  

    )  

  

    parser.add_argument('--data0', default='../../datas/2005-2006-day- 

001.txt',  

                        required=False, help='Data to read in')  

  

    # Defaults for dates  

    parser.add_argument('--fromdate', required=False, default='',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--todate', required=False, default='',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--cerebro', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--broker', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--sizer', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  
﻿format')  

  

    parser.add_argument('--strat', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--plot', required=False, default='',  

                        nargs='?', const='{}',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    return parser.parse_args(pargs)  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: optimization\optimization.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  
﻿# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

import time  

  

from backtrader.utils.py3 import range  

  
﻿import backtrader as bt  

import backtrader.indicators as btind  

import backtrader.feeds as btfeeds  

  

  

class OptimizeStrategy(bt.Strategy):  

    params = (('smaperiod', 15),  

               ('macdperiod1', 12),  

               ('macdperiod2', 26),  

               ('macdperiod3', 9),  

              )  

  

    def __init__(self):  

        # Add indicators to add load  

  

        btind.SMA(period=self.p.smaperiod)  

        btind.MACD(period_me1=self.p.macdperiod1,  

                   period_me2=self.p.macdperiod2,  

                   period_signal=self.p.macdperiod3)  

  

  

def runstrat():  

    args = parse_args()  

  

    # Create a cerebro entity  

    cerebro = bt.Cerebro(maxcpus=args.maxcpus,  

                         runonce=not args.no_runonce,  
﻿                         exactbars=args.exactbars,  

                         optdatas=not args.no_optdatas,  

                         optreturn=not args.no_optreturn)  

  

    # Add a strategy  

    cerebro.optstrategy(  

        OptimizeStrategy,  

        smaperiod=range(args.ma_low, args.ma_high),  

        macdperiod1=range(args.m1_low, args.m1_high),  

        macdperiod2=range(args.m2_low, args.m2_high),  

        macdperiod3=range(args.m3_low, args.m3_high),  

    )  

  

    # Get the dates from the args  

    fromdate = datetime.datetime.strptime(args.fromdate, '%Y-%m-%d')  

    todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

  

    # Create the 1st data  

    data = btfeeds.BacktraderCSVData(  

        dataname=args.data,  

        fromdate=fromdate,  

        todate=todate)  

  

    # Add the Data Feed to Cerebro  

    cerebro.adddata(data)  

  

    # clock the start of the process  
﻿    tstart = time.clock()  

  

    # Run over everything  

    stratruns = cerebro.run()  

  

    # clock the end of the process  

    tend = time.clock()  

  

    print('==================================================')  

    for stratrun in stratruns:  

        print('**************************************************')  

        for strat in stratrun:  

            print('-------------------------------------------------- 

')  

            print(strat.p._getkwargs())  

    print('==================================================')  

  

    # print out the result  

    print('Time used:', str(tend - tstart))  

  

  

def parse_args():  

    parser = argparse.ArgumentParser(  

        description='Optimization',  

        formatter_class=argparse.RawTextHelpFormatter,  

    )  

  
﻿    parser.add_argument(  

        '--data', '-d',  

        default='../../datas/2006-day-001.txt',  

        help='data to add to the system')  

  

    parser.add_argument(  

        '--fromdate', '-f',  

        default='2006-01-01',  

        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument(  

        '--todate', '-t',  

        default='2006-12-31',  

        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument(  

        '--maxcpus', '-m',  

        type=int, required=False, default=0,  

        help=('Number of CPUs to use in the optimization'  

              '\n'  

              '  - 0 (default): use all available CPUs\n'  

              '  - 1 -> n: use as many as specified\n'))  

  

    parser.add_argument(  

        '--no-runonce', action='store_true', required=False,  

        help='Run in next mode')  

  
﻿    parser.add_argument(  

        '--exactbars', required=False, type=int, default=0,  

        help=('Use the specified exactbars still compatible with  

preload\n'  

              '  0 No memory savings\n'  

              '  -1 Moderate memory savings\n'  

              '  -2 Less moderate memory savings\n'))  

  

    parser.add_argument(  

        '--no-optdatas', action='store_true', required=False,  

        help='Do not optimize data preloading in optimization')  

  

    parser.add_argument(  

        '--no-optreturn', action='store_true', required=False,  

        help='Do not optimize the returned values to save time')  

  

    parser.add_argument(  

        '--ma_low', type=int,  

        default=10, required=False,  

        help='SMA range low to optimize')  

  

    parser.add_argument(  

        '--ma_high', type=int,  

        default=30, required=False,  

        help='SMA range high to optimize')  

  

    parser.add_argument(  
﻿        '--m1_low', type=int,  

        default=12, required=False,  

        help='MACD Fast MA range low to optimize')  

  

    parser.add_argument(  

        '--m1_high', type=int,  

        default=20, required=False,  

        help='MACD Fast MA range high to optimize')  

  

    parser.add_argument(  

        '--m2_low', type=int,  

        default=26, required=False,  

        help='MACD Slow MA range low to optimize')  

  

    parser.add_argument(  

        '--m2_high', type=int,  

        default=30, required=False,  

        help='MACD Slow MA range high to optimize')  

  

    parser.add_argument(  

        '--m3_low', type=int,  

        default=9, required=False,  

        help='MACD Signal range low to optimize')  

  

    parser.add_argument(  

        '--m3_high', type=int,  

        default=15, required=False,  
﻿        help='MACD Signal range high to optimize')  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: order-close\close-daily.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  
﻿# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,)  

#                        unicode_literals)  

  

import argparse  

import datetime  

import random  

  

import backtrader as bt  

import backtrader.feeds as btfeeds  

  

from backtrader.utils.py3 import with_metaclass  

  

  

class St(bt.Strategy):  

    def __init__(self):  

        self.order = None  

  

    def notify_order(self, order):  
﻿        curdtstr =  

self.data.datetime.datetime().strftime('%a %Y-%m-%d')  

        if order.status in [order.Completed]:  

            dtstr =  

bt.num2date(order.executed.dt).strftime('%a %Y-%m-%d')  

            if order.isbuy():  

                print('%s: BUY  EXECUTED, on:' % curdtstr, dtstr)  

            else:  # Sell  

                print('%s: SELL EXECUTED, on:' % curdtstr, dtstr)  

  

            self.order = None  

  

    def next(self):  

        dtstr =  

self.data.datetime.datetime().strftime('%a %Y-%m-%d %H:%M:%S')  

        # print('%s: data' % dtstr)  

        if self.order:  

            return  

  

        if not random.randint(0, 5):  # roll a dice to decide  

entering/exit  

            if self.position:  

                print('%s: SELL CREATED' % dtstr)  

                self.order = self.close(exectype=bt.Order.Close)  

            else:  # no pending order  

                print('%s: BUY  CREATED' % dtstr)  

                self.order = self.buy(exectype=bt.Order.Close)  

  
﻿  

class SessionEndFiller(with_metaclass(bt.metabase.MetaParams,  

object)):  

    '''This data filter simply adds the time given in param  

``endtime`` to the  

    current data datetime  

  

    It is intended for daily bars which come from sources with no time  

    indication and can be used to signal the bar is passed the end of  

the  

    session  

  

    The default value for ``endtime`` is 1 second before midnight  

23:59:59  

    '''  

    params = (('endtime', datetime.time(23, 59, 59)),)  

  

    def __call__(self, data):  

        '''  

        Params:  

          - data: the data source to filter/process  

  

        Returns:  

          - False (always) because this filter does not remove bars  

from the  

            stream  

        '''  

        # Get time of current (from data source) bar  
﻿        dtime = datetime.combine(data.datetime.date(), self.p.endtime)  

        data.datetime[0] = data.date2num(dtime)  

        return False  

  

  

def runstrat():  

    args = parse_args()  

  

    cerebro = bt.Cerebro()  

    cerebro.adddata(getdata(args))  

    cerebro.addstrategy(St)  

    if args.eosbar:  

        cerebro.broker.seteosbar(True)  

  

    cerebro.run()  

  

  

def getdata(args):  

  

    dataformat = dict(  

        bt=btfeeds.BacktraderCSVData,  

        visualchart=btfeeds.VChartCSVData,  

        sierrachart=btfeeds.SierraChartCSVData,  

        yahoo=btfeeds.YahooFinanceCSVData,  

        yahoo_unreversed=btfeeds.YahooFinanceCSVData  

    )  

  
﻿    dfkwargs = dict()  

    if args.csvformat == 'yahoo_unreversed':  

        dfkwargs['reverse'] = True  

  

    if args.fromdate:  

        fromdate = datetime.datetime.strptime(args.fromdate,  

'%Y-%m-%d')  

        dfkwargs['fromdate'] = fromdate  

  

    if args.todate:  

        fromdate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

        dfkwargs['todate'] = todate  

  

    if args.tend is not None:  

        # internally only the "time" part is used  

        dfkwargs['sessionend'] = datetime.datetime.strptime(args.tend,  

'%H:%M')  

  

    dfkwargs['dataname'] = args.infile  

    dfcls = dataformat[args.csvformat]  

  

    data = dfcls(**dfkwargs)  

  

    if args.filltime is not None:  

        filltime = datetime.datetime.strptime(args.filltime,  

'%H:%M:%S').time()  

        data.addfilter(SessionEndFiller, endtime=filltime)  

  
﻿    return data  

  

  

def parse_args():  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='Sample for Close Orders with daily data')  

  

    parser.add_argument('--infile', '-i', required=False,  

                        default='../../datas/2005-2006-day-001.txt',  

                        help='File to be read in')  

  

    parser.add_argument('--csvformat', '-c', required=False,  

default='bt',  

                        choices=['bt', 'visualchart', 'sierrachart',  

                                 'yahoo', 'yahoo_unreversed'],  

                        help='CSV Format')  

  

    parser.add_argument('--fromdate', '-f', required=False,  

default=None,  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', '-t', required=False,  

default=None,  

                        help='Ending date in YYYY-MM-DD format')  

  

    parser.add_argument('--eosbar', required=False,  

action='store_true',  
﻿                        help=('Consider a bar with the end of session  

time to'  

                              'be the end of the session'))  

  

    parser.add_argument('--tend', '-te',  

                        default=None, required=False,  

                        help='End time for the Session Filter  

(HH:MM)')  

  

    parser.add_argument('--filltime', '-ftime',  

                        default=None, required=False,  

                        help='Add Time to daily bars (HH:MM:SS)')  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: order-close\close-minute.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 
﻿#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,)  

#                        unicode_literals)  

  

import argparse  

import datetime  

  

import backtrader as bt  
﻿import backtrader.feeds as btfeeds  

  

  

class St(bt.Strategy):  

    def __init__(self):  

        self.curdate = datetime.date.min  

        self.elapsed = 0  

        self.order = None  

  

    def notify_order(self, order):  

        curdtstr =  

self.data.datetime.datetime().strftime('%a %Y-%m-%d %H:%M:%S')  

        if order.status in [order.Completed]:  

            dtstr =  

bt.num2date(order.executed.dt).strftime('%a %Y-%m-%d %H:%M:%S')  

            if order.isbuy():  

                print('%s: BUY  EXECUTED, on:' % curdtstr, dtstr)  

                self.order = None  

            else:  # Sell  

                print('%s: SELL EXECUTED, on:' % curdtstr, dtstr)  

  

    def next(self):  

        curdate = self.data.datetime.date()  

        if curdate > self.curdate:  

            self.elapsed += 1  

            self.curdate = curdate  

  
﻿        dtstr =  

self.data.datetime.datetime().strftime('%a %Y-%m-%d %H:%M:%S')  

        if self.position and self.elapsed == 2:  

            print('%s: SELL CREATED' % dtstr)  

            self.close(exectype=bt.Order.Close)  

            self.elapsed = 0  

        elif self.order is None and self.elapsed == 2:  # no pending  

order  

            print('%s: BUY  CREATED' % dtstr)  

            self.order = self.buy(exectype=bt.Order.Close)  

            self.elapsed = 0  

  

  

def runstrat():  

    args = parse_args()  

  

    cerebro = bt.Cerebro()  

    cerebro.adddata(getdata(args))  

    cerebro.addstrategy(St)  

    if args.eosbar:  

        cerebro.broker.seteosbar(True)  

  

    cerebro.run()  

  

  

def getdata(args):  

  
﻿    dataformat = dict(  

        bt=btfeeds.BacktraderCSVData,  

        visualchart=btfeeds.VChartCSVData,  

        sierrachart=btfeeds.SierraChartCSVData,  

        yahoo=btfeeds.YahooFinanceCSVData,  

        yahoo_unreversed=btfeeds.YahooFinanceCSVData  

    )  

  

    dfkwargs = dict()  

    if args.csvformat == 'yahoo_unreversed':  

        dfkwargs['reverse'] = True  

  

    if args.fromdate:  

        fromdate = datetime.datetime.strptime(args.fromdate,  

'%Y-%m-%d')  

        dfkwargs['fromdate'] = fromdate  

  

    if args.todate:  

        fromdate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

        dfkwargs['todate'] = todate  

  

    if args.tend is not None:  

        # internally only the "time" part is used  

        dfkwargs['sessionend'] = datetime.datetime.strptime(args.tend,  

'%H:%M')  

  

    dfkwargs['dataname'] = args.infile  
﻿    dfcls = dataformat[args.csvformat]  

  

    data = dfcls(**dfkwargs)  

  

    return data  

  

  

def parse_args():  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='Sample for Close Orders with daily data')  

  

    parser.add_argument('--infile', '-i', required=False,  

                        default='../../datas/2006-min-005.txt',  

                        help='File to be read in')  

  

    parser.add_argument('--csvformat', '-c', required=False,  

default='bt',  

                        choices=['bt', 'visualchart', 'sierrachart',  

                                 'yahoo', 'yahoo_unreversed'],  

                        help='CSV Format')  

  

    parser.add_argument('--fromdate', '-f', required=False,  

default=None,  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', '-t', required=False,  

default=None,  
﻿                        help='Ending date in YYYY-MM-DD format')  

  

    parser.add_argument('--eosbar', required=False,  

action='store_true',  

                        help=('Consider a bar with the end of session  

time to'  

                              'be the end of the session'))  

  

    parser.add_argument('--tend', '-te',  

                        default=None, required=False,  

                        help='End time for the Session Filter  

(HH:MM)')  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: order-execution\order-execution.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 
﻿#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

import os.path  

import time  
﻿import sys  

  

  

import backtrader as bt  

import backtrader.feeds as btfeeds  

import backtrader.indicators as btind  

  

  

class OrderExecutionStrategy(bt.Strategy):  

    params = (  

         ('smaperiod', 15),  

         ('exectype', 'Market'),  

         ('perc1', 3),  

         ('perc2', 1),  

         ('valid', 4),  

    )  

  

    def log(self, txt, dt=None):  

        ''' Logging function fot this strategy'''  

        dt = dt or self.data.datetime[0]  

        if isinstance(dt, float):  

            dt = bt.num2date(dt)  

        print('%s, %s' % (dt.isoformat(), txt))  

  

    def notify_order(self, order):  

        if order.status in [order.Submitted, order.Accepted]:  

            # Buy/Sell order submitted/accepted to/by broker - Nothing  
﻿to do  

            self.log('ORDER ACCEPTED/SUBMITTED', dt=order.created.dt)  

            self.order = order  

            return  

  

        if order.status in [order.Expired]:  

            self.log('BUY EXPIRED')  

  

        elif order.status in [order.Completed]:  

            if order.isbuy():  

                self.log(  

                    'BUY EXECUTED, Price: %.2f, Cost: %.2f,  

Comm %.2f' %  

                     (order.executed.price,  

                     order.executed.value,  

                     order.executed.comm))  

  

            else:  # Sell  

                self.log('SELL EXECUTED, Price: %.2f, Cost: %.2f,  

Comm %.2f' %  

                          (order.executed.price,  

                          order.executed.value,  

                          order.executed.comm))  

  

        # Sentinel to None: new orders allowed  

        self.order = None  

  
﻿    def __init__(self):  

        # SimpleMovingAverage on main data  

        # Equivalent to -> sma = btind.SMA(self.data,  

period=self.p.smaperiod)  

        sma = btind.SMA(period=self.p.smaperiod)  

  

        # CrossOver (1: up, -1: down) close / sma  

        self.buysell = btind.CrossOver(self.data.close, sma,  

plot=True)  

  

        # Sentinel to None: new ordersa allowed  

        self.order = None  

  

    def next(self):  

        if self.order:  

            # An order is pending ... nothing can be done  

            return  

  

        # Check if we are in the market  

        if self.position:  

            # In the maerket - check if it's the time to sell  

            if self.buysell < 0:  

                self.log('SELL CREATE, %.2f' % self.data.close[0])  

                self.sell()  

  

        elif self.buysell > 0:  

            if self.p.valid:  
﻿                valid = self.data.datetime.date(0) + \  

                        datetime.timedelta(days=self.p.valid)  

            else:  

                valid = None  

  

            # Not in the market and signal to buy  

            if self.p.exectype == 'Market':  

                self.buy(exectype=bt.Order.Market)  # default if not  

given  

  

                self.log('BUY CREATE, exectype Market, price %.2f' %  

                         self.data.close[0])  

  

            elif self.p.exectype == 'Close':  

                self.buy(exectype=bt.Order.Close)  

  

                self.log('BUY CREATE, exectype Close, price %.2f' %  

                         self.data.close[0])  

  

            elif self.p.exectype == 'Limit':  

                price = self.data.close * (1.0 - self.p.perc1 / 100.0)  

  

                self.buy(exectype=bt.Order.Limit, price=price,  

valid=valid)  

  

                if self.p.valid:  

                    txt = 'BUY CREATE, exectype Limit, price %.2f,  

valid: %s'  
﻿                    self.log(txt % (price,  

valid.strftime('%Y-%m-%d')))  

                else:  

                    txt = 'BUY CREATE, exectype Limit, price %.2f'  

                    self.log(txt % price)  

  

            elif self.p.exectype == 'Stop':  

                price = self.data.close * (1.0 + self.p.perc1 / 100.0)  

  

                self.buy(exectype=bt.Order.Stop, price=price,  

valid=valid)  

  

                if self.p.valid:  

                    txt = 'BUY CREATE, exectype Stop, price %.2f,  

valid: %s'  

                    self.log(txt % (price,  

valid.strftime('%Y-%m-%d')))  

                else:  

                    txt = 'BUY CREATE, exectype Stop, price %.2f'  

                    self.log(txt % price)  

  

            elif self.p.exectype == 'StopLimit':  

                price = self.data.close * (1.0 + self.p.perc1 / 100.0)  

  

                plimit = self.data.close * (1.0 + self.p.perc2 /  

100.0)  

  

                self.buy(exectype=bt.Order.StopLimit, price=price,  
﻿valid=valid,  

                         plimit=plimit)  

  

                if self.p.valid:  

                    txt = ('BUY CREATE, exectype StopLimit,  

price %.2f,'  

                           ' valid: %s, pricelimit: %.2f')  

                    self.log(txt % (price, valid.strftime('%Y-%m-%d'),  

plimit))  

                else:  

                    txt = ('BUY CREATE, exectype StopLimit,  

price %.2f,'  

                           ' pricelimit: %.2f')  

                    self.log(txt % (price, plimit))  

  

  

def runstrat():  

    args = parse_args()  

  

    cerebro = bt.Cerebro()  

  

    data = getdata(args)  

    cerebro.adddata(data)  

  

    cerebro.addstrategy(  

        OrderExecutionStrategy,  

        exectype=args.exectype,  

        perc1=args.perc1,  
﻿        perc2=args.perc2,  

        valid=args.valid,  

        smaperiod=args.smaperiod  

    )  

    cerebro.run()  

  

    if args.plot:  

        cerebro.plot(numfigs=args.numfigs, style=args.plotstyle)  

  

  

def getdata(args):  

  

    dataformat = dict(  

        bt=btfeeds.BacktraderCSVData,  

        visualchart=btfeeds.VChartCSVData,  

        sierrachart=btfeeds.SierraChartCSVData,  

        yahoo=btfeeds.YahooFinanceCSVData,  

        yahoo_unreversed=btfeeds.YahooFinanceCSVData  

    )  

  

    dfkwargs = dict()  

    if args.csvformat == 'yahoo_unreversed':  

        dfkwargs['reverse'] = True  

  

    if args.fromdate:  

        fromdate = datetime.datetime.strptime(args.fromdate,  

'%Y-%m-%d')  
﻿        dfkwargs['fromdate'] = fromdate  

  

    if args.todate:  

        fromdate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

        dfkwargs['todate'] = todate  

  

    dfkwargs['dataname'] = args.infile  

  

    dfcls = dataformat[args.csvformat]  

  

    return dfcls(**dfkwargs)  

  

  

def parse_args():  

    parser = argparse.ArgumentParser(  

        description='Showcase for Order Execution Types')  

  

    parser.add_argument('--infile', '-i', required=False,  

                        default='../../datas/2006-day-001.txt',  

                        help='File to be read in')  

  

    parser.add_argument('--csvformat', '-c', required=False,  

default='bt',  

                        choices=['bt', 'visualchart', 'sierrachart',  

                                 'yahoo', 'yahoo_unreversed'],  

                        help='CSV Format')  

  
﻿    parser.add_argument('--fromdate', '-f', required=False,  

default=None,  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', '-t', required=False,  

default=None,  

                        help='Ending date in YYYY-MM-DD format')  

  

    parser.add_argument('--plot', '-p', action='store_true',  

required=False,  

                        help='Plot the read data')  

  

    parser.add_argument('--plotstyle', '-ps', required=False,  

default='bar',  

                        choices=['bar', 'line', 'candle'],  

                        help='Plot the read data')  

  

    parser.add_argument('--numfigs', '-n', required=False, default=1,  

                        help='Plot using n figures')  

  

    parser.add_argument('--smaperiod', '-s', required=False,  

default=15,  

                        help='Simple Moving Average Period')  

  

    parser.add_argument('--exectype', '-e', required=False,  

default='Market',  

                        help=('Execution Type: Market (default),  

Close, Limit,'  

                              ' Stop, StopLimit'))  
﻿  

    parser.add_argument('--valid', '-v', required=False, default=0,  

type=int,  

                        help='Validity for Limit sample: default 0  

days')  

  

    parser.add_argument('--perc1', '-p1', required=False, default=0.0,  

                        type=float,  

                        help=('%% distance from close price at order  

creation'  

                              ' time for the limit/trigger price in  

Limit/Stop'  

                              ' orders'))  

  

    parser.add_argument('--perc2', '-p2', required=False, default=0.0,  

                        type=float,  

                        help=('%% distance from close price at order  

creation'  

                              ' time for the limit price in StopLimit  

orders'))  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  
﻿# 文件: order-history\order-history.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  
﻿                        unicode_literals)  

  

import argparse  

import datetime  

  

import backtrader as bt  

  

  

ORDER_HISTORY = (  

     ('2005-02-01', 1, 2984.63),  

     ('2005-03-04', -1, 3079.93),  

     ('2005-03-08', 1, 3113.82),  

     ('2005-03-22', -1, 3040.55),  

     ('2005-04-08', 1, 3092.07),  

     ('2005-04-20', -1, 2957.92),  

     ('2005-05-13', 1, 2991.71),  

     ('2005-08-19', -1, 3284.35),  

     ('2005-08-22', 1, 3328.84),  

     ('2005-08-25', -1, 3293.69),  

     ('2005-09-12', 1, 3361.1),  

     ('2005-10-18', -1, 3356.73),  

     ('2005-11-09', 1, 3361.92),  

     ('2006-01-24', -1, 3544.78),  

     ('2006-02-06', 1, 3678.87),  

     ('2006-03-13', -1, 3801.03),  

     ('2006-03-20', 1, 3833.25),  

     ('2006-04-13', -1, 3777.24),  
﻿     ('2006-05-02', 1, 3839.24),  

     ('2006-05-16', -1, 3711.46),  

     ('2006-06-30', 1, 3592.01),  

     ('2006-07-21', -1, 3580.53),  

     ('2006-08-01', 1, 3687.82),  

     ('2006-09-14', -1, 3809.08),  

     ('2006-09-25', 1, 3815.13),  

     ('2006-12-01', -1, 3993.03),  

     ('2006-12-18', 1, 4140.99),  

)  

  

  

class SmaCross(bt.SignalStrategy):  

    params = dict(sma1=10, sma2=20)  

  

    def notify_order(self, order):  

        if not order.alive():  

            print(','.join(str(x) for x in  

                            

(self.data.num2date(order.executed.dt).date(),  

                            order.executed.size * 1 if order.isbuy()  

else -1,  

                            order.executed.price)))  

  

    def notify_trade(self, trade):  

        if trade.isclosed:  

            print('profit {}'.format(trade.pnlcomm))  
﻿  

    def __init__(self):  

        print('Creating Signal Strategy')  

        sma1 = bt.ind.SMA(period=self.params.sma1)  

        sma2 = bt.ind.SMA(period=self.params.sma2)  

        crossover = bt.ind.CrossOver(sma1, sma2)  

        self.signal_add(bt.SIGNAL_LONG, crossover)  

  

  

class St(bt.Strategy):  

    params = dict(  

    )  

  

    def notify_order(self, order):  

        if not order.alive():  

            print(','.join(str(x) for x in  

                            

(self.data.num2date(order.executed.dt).date(),  

                            order.executed.size * 1 if order.isbuy()  

else -1,  

                            order.executed.price)))  

  

    def notify_trade(self, trade):  

        if trade.isclosed:  

            print('profit {}'.format(trade.pnlcomm))  

  

    def __init__(self):  
﻿        print('Creating Empty Strategy')  

        pass  

  

    def next(self):  

        pass  

  

  

def runstrat(args=None):  

    args = parse_args(args)  

  

    cerebro = bt.Cerebro()  

  

    # Data feed kwargs  

    kwargs = dict()  

  

    # Parse from/to-date  

    dtfmt, tmfmt = '%Y-%m-%d', 'T%H:%M:%S'  

    for a, d in ((getattr(args, x), x) for x in ['fromdate',  

'todate']):  

        if a:  

            strpfmt = dtfmt + tmfmt * ('T' in a)  

            kwargs[d] = datetime.datetime.strptime(a, strpfmt)  

  

    data0 = bt.feeds.BacktraderCSVData(dataname=args.data0, **kwargs)  

    cerebro.adddata(data0)  

  

    # Broker  
﻿    cerebro.broker = bt.brokers.BackBroker(**eval('dict(' +  

args.broker + ')'))  

  

    # Sizer  

    cerebro.addsizer(bt.sizers.FixedSize, **eval('dict(' + args.sizer  

+ ')'))  

  

    # Strategy  

    if not args.order_history:  

        cerebro.addstrategy(SmaCross, **eval('dict(' + args.strat +  

')'))  

    else:  

        cerebro.addstrategy(St, **eval('dict(' + args.strat + ')'))  

        cerebro.add_order_history(ORDER_HISTORY, notify=True)  

  

    cerebro.addanalyzer(bt.analyzers.TimeReturn,  

timeframe=bt.TimeFrame.Months)  

    cerebro.addanalyzer(bt.analyzers.TimeReturn,  

timeframe=bt.TimeFrame.Years)  

    cerebro.addanalyzer(bt.analyzers.TradeAnalyzer)  

  

    # Execute  

    cerebro.run(**eval('dict(' + args.cerebro + ')'))  

  

    if args.plot:  # Plot if requested to  

        cerebro.plot(**eval('dict(' + args.plot + ')'))  

  

  
﻿def parse_args(pargs=None):  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description=(  

            'Order History Sample'  

        )  

    )  

  

    parser.add_argument('--data0', default='../../datas/2005-2006-day- 

001.txt',  

                        required=False, help='Data to read in')  

  

    # Defaults for dates  

    parser.add_argument('--fromdate', required=False, default='',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--todate', required=False, default='',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--order-history', required=False,  

action='store_true',  

                        help='use order history')  

  

    parser.add_argument('--cerebro', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  
﻿  

    parser.add_argument('--broker', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--sizer', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--strat', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--plot', required=False, default='',  

                        nargs='?', const='{}',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    return parser.parse_args(pargs)  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: order_target\order_target.txt  

====================================================================== 
﻿==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  
﻿import argparse  

from datetime import datetime  

  

import backtrader as bt  

  

  

class TheStrategy(bt.Strategy):  

    '''  

    This strategy is loosely based on some of the examples from the  

Van  

    K. Tharp book: *Trade Your Way To Financial Freedom*. The logic:  

  

      - Enter the market if:  

        - The MACD.macd line crosses the MACD.signal line to the  

upside  

        - The Simple Moving Average has a negative direction in the  

last x  

          periods (actual value below value x periods ago)  

  

     - Set a stop price x times the ATR value away from the close  

  

     - If in the market:  

  

       - Check if the current close has gone below the stop price. If  

yes,  

         exit.  

       - If not, update the stop price if the new stop price would be  

higher  
﻿         than the current  

    '''  

  

    params = (  

         ('use_target_size', False),  

         ('use_target_value', False),  

         ('use_target_percent', False),  

    )  

  

    def notify_order(self, order):  

        if order.status == order.Completed:  

            pass  

  

        if not order.alive():  

            self.order = None  # indicate no order is pending  

  

    def start(self):  

        self.order = None  # sentinel to avoid operrations on pending  

order  

  

    def next(self):  

        dt = self.data.datetime.date()  

  

        portfolio_value = self.broker.get_value()  

        print('%04d - %s - Position Size:     %02d - Value %.2f' %  

               (len(self), dt.isoformat(), self.position.size,  

portfolio_value))  
﻿  

        data_value = self.broker.get_value([self.data])  

  

        if self.p.use_target_value:  

            print('%04d - %s - data value %.2f' %  

                   (len(self), dt.isoformat(), data_value))  

  

        elif self.p.use_target_percent:  

            port_perc = data_value / portfolio_value  

            print('%04d - %s - data percent %.2f' %  

                   (len(self), dt.isoformat(), port_perc))  

  

        if self.order:  

            return  # pending order execution  

  

        size = dt.day  

        if (dt.month % 2) == 0:  

            size = 31 - size  

  

        if self.p.use_target_size:  

            target = size  

            print('%04d - %s - Order Target Size: %02d' %  

                   (len(self), dt.isoformat(), size))  

  

            self.order = self.order_target_size(target=size)  

  

        elif self.p.use_target_value:  
﻿            value = size * 1000  

  

            print('%04d - %s - Order Target Value: %.2f' %  

                   (len(self), dt.isoformat(), value))  

  

            self.order = self.order_target_value(target=value)  

  

        elif self.p.use_target_percent:  

            percent = size / 100.0  

  

            print('%04d - %s - Order Target Percent: %.2f' %  

                   (len(self), dt.isoformat(), percent))  

  

            self.order = self.order_target_percent(target=percent)  

  

  

def runstrat(args=None):  

    args = parse_args(args)  

  

    cerebro = bt.Cerebro()  

    cerebro.broker.setcash(args.cash)  

  

    dkwargs = dict()  

    if args.fromdate is not None:  

        dkwargs['fromdate'] = datetime.strptime(args.fromdate,  

'%Y-%m-%d')  

    if args.todate is not None:  
﻿        dkwargs['todate'] = datetime.strptime(args.todate, '%Y-%m-%d')  

  

    # data  

    data = bt.feeds.YahooFinanceCSVData(dataname=args.data, **dkwargs)  

    cerebro.adddata(data)  

  

    # strategy  

    cerebro.addstrategy(TheStrategy,  

                        use_target_size=args.target_size,  

                        use_target_value=args.target_value,  

                        use_target_percent=args.target_percent)  

  

    cerebro.run()  

  

    if args.plot:  

        pkwargs = dict(style='bar')  

        if args.plot is not True:  # evals to True but is not True  

            npkwargs = eval('dict(' + args.plot + ')')  # args were  

passed  

            pkwargs.update(npkwargs)  

  

        cerebro.plot(**pkwargs)  

  

  

def parse_args(pargs=None):  

  

    parser = argparse.ArgumentParser(  
﻿        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='Sample for Order Target')  

  

    parser.add_argument('--data', required=False,  

                        default='../../datas/yhoo-1996-2015.txt',  

                        help='Specific data to be read in')  

  

    parser.add_argument('--fromdate', required=False,  

                        default='2005-01-01',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', required=False,  

                        default='2006-12-31',  

                        help='Ending date in YYYY-MM-DD format')  

  

    parser.add_argument('--cash', required=False, action='store',  

                        type=float, default=1000000,  

                        help='Ending date in YYYY-MM-DD format')  

  

    pgroup = parser.add_mutually_exclusive_group(required=True)  

  

    pgroup.add_argument('--target-size', required=False,  

action='store_true',  

                        help=('Use order_target_size'))  

  

    pgroup.add_argument('--target-value', required=False,  

action='store_true',  
﻿                        help=('Use order_target_value'))  

  

    pgroup.add_argument('--target-percent', required=False,  

                        action='store_true',  

                        help=('Use order_target_percent'))  

  

    # Plot options  

    parser.add_argument('--plot', '-p', nargs='?', required=False,  

                        metavar='kwargs', const=True,  

                        help=('Plot the read data applying any kwargs  

passed\n'  

                              '\n'  

                              'For example:\n'  

                              '\n'  

                              '  --plot style="candle" (to plot  

candles)\n'))  

  

    if pargs is not None:  

        return parser.parse_args(pargs)  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  
﻿# 文件: partial-plot\partial-plot.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  
﻿                        unicode_literals)  

  

  

import argparse  

import datetime  

  

import backtrader as bt  

  

  

class St(bt.Strategy):  

    params = (  

    )  

  

    def __init__(self):  

        # self.schedule_once(self.pepe, when=datetime.datetime())  

        # This one won't have the expected fidelity in backtesting  

        # self.schedule_once(self.pepe, when=datetime.timedelta())  

        # self.schedule_reps(self.pepe, when=datetime.time(),  

days=bt.sched.)  

  

        bt.ind.SMA()  

        stoc = bt.ind.Stochastic()  

        bt.ind.CrossOver(stoc.lines.percK, stoc.lines.percD)  

  

    def next(self):  

        pass  

  
﻿  

def runstrat(args=None):  

    args = parse_args(args)  

  

    cerebro = bt.Cerebro()  

  

    # Data feed kwargs  

    kwargs = dict()  

  

    # Parse from/to-date  

    dtfmt, tmfmt = '%Y-%m-%d', 'T%H:%M:%S'  

    for a, d in ((getattr(args, x), x) for x in ['fromdate',  

'todate']):  

        if a:  

            strpfmt = dtfmt + tmfmt * ('T' in a)  

            kwargs[d] = datetime.datetime.strptime(a, strpfmt)  

  

    # Data feed  

    data0 = bt.feeds.BacktraderCSVData(dataname=args.data0, **kwargs)  

    cerebro.adddata(data0)  

  

    cerebro.resampledata(data0, timeframe=bt.TimeFrame.Weeks)  

  

    # Broker  

    cerebro.broker = bt.brokers.BackBroker(**eval('dict(' +  

args.broker + ')'))  

  
﻿    # Sizer  

    cerebro.addsizer(bt.sizers.FixedSize, **eval('dict(' + args.sizer  

+ ')'))  

  

    # Strategy  

    cerebro.addstrategy(St, **eval('dict(' + args.strat + ')'))  

  

    # Execute  

    cerebro.run(**eval('dict(' + args.cerebro + ')'))  

  

    if args.plot:  # Plot if requested to  

        cerebro.plot(**eval('dict(' + args.plot + ')'))  

  

  

def parse_args(pargs=None):  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description=(  

            'Sample for partial plotting'  

        )  

    )  

  

    parser.add_argument('--data0', default='../../datas/2005-2006-day- 

001.txt',  

                        required=False, help='Data to read in')  

  

    # Defaults for dates  
﻿    parser.add_argument('--fromdate', required=False, default='',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--todate', required=False, default='',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--cerebro', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--broker', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--sizer', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--strat', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--plot', required=False, default='',  

                        nargs='?', const='{}',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  
﻿    return parser.parse_args(pargs)  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: pinkfish-challenge\pinkfish-challenge.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  
﻿#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

  

import backtrader as bt  

import backtrader.indicators as btind  

  

  

class DayStepsCloseFilter(bt.with_metaclass(bt.MetaParams, object)):  

    '''  

    Replays a bar in 2 steps:  

  

      - In the 1st step the "Open-High-Low" could be evaluated to  

decide if to  

        act on the close (the close is still there ... should not be  

evaluated)  

  

      - If a "Close" order has been executed  

  
﻿        In this 1st fragment the "Close" is replaced through the  

"open" althoug  

        other alternatives would be possible like high - low average,  

or an  

        algorithm based on where the "close" ac  

  

      and  

  

      - Open-High-Low-Close  

    '''  

    params = (  

         ('cvol', 0.5),  # 0 -> 1 amount of volume to keep for close  

    )  

  

    def __init__(self, data):  

        self.pendingbar = None  

  

    def __call__(self, data):  

        # Make a copy of the new bar and remove it from stream  

        closebar = [data.lines[i][0] for i in range(data.size())]  

        datadt = data.datetime.date()  # keep the date  

  

        ohlbar = closebar[:]  # Make an open-high-low bar  

  

        # Adjust volume  

        ohlbar[data.Volume] = int(closebar[data.Volume] * (1.0 -  

self.p.cvol))  

  
﻿        dt = datetime.datetime.combine(datadt, data.p.sessionstart)  

        ohlbar[data.DateTime] = data.date2num(dt)  

  

        dt = datetime.datetime.combine(datadt, data.p.sessionend)  

        closebar[data.DateTime] = data.date2num(dt)  

  

        # Update stream  

        data.backwards()  # remove the copied bar from stream  

        # Overwrite the new data bar with our pending data - except  

start point  

        if self.pendingbar is not None:  

            data._updatebar(self.pendingbar)  

  

        self.pendingbar = closebar  # update the pending bar to the  

new bar  

        data._add2stack(ohlbar)  # Add the openbar to the stack for  

processing  

  

        return False  # the length of the stream was not changed  

  

    def last(self, data):  

        '''Called when the data is no longer producing bars  

        Can be called multiple times. It has the chance to (for  

example)  

        produce extra bars'''  

        if self.pendingbar is not None:  

            data.backwards()  # remove delivered open bar  

            data._add2stack(self.pendingbar)  # add remaining  
﻿            self.pendingbar = None  # No further action  

            return True  # something delivered  

  

        return False  # nothing delivered here  

  

  

class DayStepsReplayFilter(bt.with_metaclass(bt.MetaParams, object)):  

    '''  

    Replays a bar in 2 steps:  

  

      - In the 1st step the "Open-High-Low" could be evaluated to  

decide if to  

        act on the close (the close is still there ... should not be  

evaluated)  

  

      - If a "Close" order has been executed  

  

        In this 1st fragment the "Close" is replaced through the  

"open" althoug  

        other alternatives would be possible like high - low average,  

or an  

        algorithm based on where the "close" ac  

  

      and  

  

      - Open-High-Low-Close  

    '''  

    params = (  
﻿         ('closevol', 0.5),  # 0 -> 1 amount of volume to keep for  

close  

    )  

  

    # replaying = True  

  

    def __init__(self, data):  

        self.lastdt = None  

        pass  

  

    def __call__(self, data):  

        # Make a copy of the new bar and remove it from stream  

        datadt = data.datetime.date()  # keep the date  

  

        if self.lastdt == datadt:  

            return False  # skip bars that come again in the filter  

  

        self.lastdt = datadt  # keep ref to last seen bar  

  

        # Make a copy of current data for ohlbar  

        ohlbar = [data.lines[i][0] for i in range(data.size())]  

        closebar = ohlbar[:]  # Make a copy for the close  

  

        # replace close price with o-h-l average  

        ohlprice = ohlbar[data.Open] + ohlbar[data.High] +  

ohlbar[data.Low]  

        ohlbar[data.Close] = ohlprice / 3.0  
﻿  

        vol = ohlbar[data.Volume]  # adjust volume  

        ohlbar[data.Volume] = vohl = int(vol * (1.0 -  

self.p.closevol))  

  

        oi = ohlbar[data.OpenInterest]  # adjust open interst  

        ohlbar[data.OpenInterest] = 0  

  

        # Adjust times  

        dt = datetime.datetime.combine(datadt, data.p.sessionstart)  

        ohlbar[data.DateTime] = data.date2num(dt)  

  

        # Ajust closebar to generate a single tick -> close price  

        closebar[data.Open] = cprice = closebar[data.Close]  

        closebar[data.High] = cprice  

        closebar[data.Low] = cprice  

        closebar[data.Volume] = vol - vohl  

        ohlbar[data.OpenInterest] = oi  

  

        # Adjust times  

        dt = datetime.datetime.combine(datadt, data.p.sessionend)  

        closebar[data.DateTime] = data.date2num(dt)  

  

        # Update stream  

        data.backwards(force=True)  # remove the copied bar from  

stream  

        data._add2stack(ohlbar)  # add ohlbar to stack  
﻿        # Add 2nd part to stash to delay processing to next round  

        data._add2stack(closebar, stash=True)  

  

        return False  # the length of the stream was not changed  

  

  

class St(bt.Strategy):  

    params = (  

         ('highperiod', 20),  

         ('sellafter', 2),  

         ('market', False),  

    )  

  

    def __init__(self):  

        pass  

  

    def start(self):  

        self.callcounter = 0  

        txtfields = list()  

        txtfields.append('Calls')  

        txtfields.append('Len Strat')  

        txtfields.append('Len Data')  

        txtfields.append('Datetime')  

        txtfields.append('Open')  

        txtfields.append('High')  

        txtfields.append('Low')  

        txtfields.append('Close')  
﻿        txtfields.append('Volume')  

        txtfields.append('OpenInterest')  

        print(','.join(txtfields))  

  

        self.lcontrol = 0  # control if 1st or 2nd call  

        self.inmarket = 0  

  

        # Get the highest but delayed 1 ... to avoid "today"  

        self.highest = btind.Highest(self.data.high,  

                                     period=self.p.highperiod,  

                                     subplot=False)  

  

    def notify_order(self, order):  

        if order.isbuy() and order.status == order.Completed:  

            print('-- BUY Completed on:',  

                   

self.data.num2date(order.executed.dt).strftime('%Y-%m-%d'))  

            print('-- BUY Price:', order.executed.price)  

  

    def next(self):  

        self.callcounter += 1  

  

        txtfields = list()  

        txtfields.append('%04d' % self.callcounter)  

        txtfields.append('%04d' % len(self))  

        txtfields.append('%04d' % len(self.data0))  

        txtfields.append(self.data.datetime.datetime(0).isoformat())  
﻿        txtfields.append('%.2f' % self.data0.open[0])  

        txtfields.append('%.2f' % self.data0.high[0])  

        txtfields.append('%.2f' % self.data0.low[0])  

        txtfields.append('%.2f' % self.data0.close[0])  

        txtfields.append('%.2f' % self.data0.volume[0])  

        txtfields.append('%.2f' % self.data0.openinterest[0])  

        print(','.join(txtfields))  

  

        if not self.position:  

            if len(self.data) > self.lcontrol:  

                if self.data.high == self.highest:  # today is  

highest!!!  

                    print('High %.2f > Highest %.2f' %  

                           (self.data.high[0], self.highest[0]))  

                    print('LAST 19 highs:',  

                          self.data.high.get(size=19, ago=-1))  

                    print('-- BUY on date:',  

                           

self.data.datetime.date().strftime('%Y-%m-%d'))  

                    ex = bt.Order.Market if self.p.market else  

bt.Order.Close  

                    self.buy(exectype=ex)  

                    self.inmarket = len(self)  # reset period in  

market  

  

        else:  # in the market  

            if (len(self) - self.inmarket) >= self.p.sellafter:  

                self.sell()  
﻿  

        self.lcontrol = len(self.data)  

  

  

def runstrat():  

    args = parse_args()  

  

    cerebro = bt.Cerebro()  

    cerebro.broker.set_cash(args.cash)  

    cerebro.broker.set_eosbar(True)  

  

    dkwargs = dict()  

    if args.fromdate:  

        fromdate = datetime.datetime.strptime(args.fromdate,  

'%Y-%m-%d')  

        dkwargs['fromdate'] = fromdate  

  

    if args.todate:  

        todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

        dkwargs['todate'] = todate  

  

    if args.no_replay:  

        data = bt.feeds.YahooFinanceCSVData(dataname=args.data,  

                                             

timeframe=bt.TimeFrame.Days,  

                                            compression=1,  

                                            **dkwargs)  
﻿        data.addfilter(DayStepsCloseFilter)  

        cerebro.adddata(data)  

    else:  

        data = bt.feeds.YahooFinanceCSVData(dataname=args.data,  

                                             

timeframe=bt.TimeFrame.Minutes,  

                                            compression=1,  

                                            **dkwargs)  

        data.addfilter(DayStepsReplayFilter)  

        cerebro.replaydata(data, timeframe=bt.TimeFrame.Days,  

compression=1)  

  

    cerebro.addstrategy(St,  

                        sellafter=args.sellafter,  

                        highperiod=args.highperiod,  

                        market=args.market)  

  

    cerebro.run(runonce=False, preload=False,  

oldbuysell=args.oldbuysell)  

    if args.plot:  

        pkwargs = dict(style='bar')  

        if args.plot is not True:  # evals to True but is not True  

            npkwargs = eval('dict(' + args.plot + ')')  # args were  

passed  

            pkwargs.update(npkwargs)  

  

        cerebro.plot(**pkwargs)  

  
﻿  

def parse_args(pargs=None):  

  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='Sample for pinkfish challenge')  

  

    parser.add_argument('--data', required=False,  

                        default='../../datas/yhoo-1996-2015.txt',  

                        help='Data to be read in')  

  

    parser.add_argument('--fromdate', required=False,  

                        default='2005-01-01',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', required=False,  

                        default='2006-12-31',  

                        help='Ending date in YYYY-MM-DD format')  

  

    parser.add_argument('--cash', required=False, action='store',  

                        type=float, default=50000,  

                        help=('Cash to start with'))  

  

    parser.add_argument('--sellafter', required=False, action='store',  

                        type=int, default=2,  

                        help=('Sell after so many bars in market'))  

  
﻿    parser.add_argument('--highperiod', required=False,  

action='store',  

                        type=int, default=20,  

                        help=('Period to look for the highest'))  

  

    parser.add_argument('--no-replay', required=False,  

action='store_true',  

                        help=('Use Replay + replay filter'))  

  

    parser.add_argument('--market', required=False,  

action='store_true',  

                        help=('Use Market exec instead of Close'))  

  

    parser.add_argument('--oldbuysell', required=False,  

action='store_true',  

                        help=('Old buysell plot behavior - ON THE  

PRICE'))  

  

    # Plot options  

    parser.add_argument('--plot', '-p', nargs='?', required=False,  

                        metavar='kwargs', const=True,  

                        help=('Plot the read data applying any kwargs  

passed\n'  

                              '\n'  

                              'For example (escape the quotes if  

needed):\n'  

                              '\n'  

                              '  --plot style="candle" (to plot  

candles)\n'))  
﻿  

    if pargs is not None:  

        return parser.parse_args(pargs)  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: pivot-point\pivotpoint.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  
﻿# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,)  

#                        unicode_literals)  

  

import backtrader as bt  

  

  

class PivotPoint1(bt.Indicator):  

    lines = ('p', 's1', 's2', 'r1', 'r2',)  

  

    def __init__(self):  

        h = self.data.high(-1)  # previous high  

        l = self.data.low(-1)  # previous low  

        c = self.data.close(-1)  # previous close  

  

        self.lines.p = p = (h + l + c) / 3.0  

  
﻿        p2 = p * 2.0  

        self.lines.s1 = p2 - h  # (p x 2) - high  

        self.lines.r1 = p2 - l  # (p x 2) - low  

  

        hilo = h - l  

        self.lines.s2 = p - hilo  # p -  (high - low)  

        self.lines.r2 = p + hilo  # p + (high - low)  

  

  

class PivotPoint(bt.Indicator):  

    lines = ('p', 's1', 's2', 'r1', 'r2',)  

    plotinfo = dict(subplot=False)  

  

    def __init__(self):  

        h = self.data.high  # current high  

        l = self.data.low  # current high  

        c = self.data.close  # current high  

  

        self.lines.p = p = (h + l + c) / 3.0  

  

        p2 = p * 2.0  

        self.lines.s1 = p2 - h  # (p x 2) - high  

        self.lines.r1 = p2 - l  # (p x 2) - low  

  

        hilo = h - l  

        self.lines.s2 = p - hilo  # p -  (high - low)  

        self.lines.r2 = p + hilo  # p + (high - low)  
﻿  

====================================================================== 

==========  

# 文件: pivot-point\ppsample.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  
﻿###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

  

import backtrader as bt  

import backtrader.feeds as btfeeds  

import backtrader.utils.flushfile  

  

  

class St(bt.Strategy):  

    params = (('usepp1', False),  

               ('plot_on_daily', False))  

  

    def __init__(self):  

        autoplot = self.p.plot_on_daily  

        self.pp = pp = bt.ind.PivotPoint(self.data1,  

_autoplot=autoplot)  

  

    def next(self):  

        txt = ','.join(  

             ['%04d' % len(self),  

             '%04d' % len(self.data0),  

             '%04d' % len(self.data1),  

             self.data.datetime.date(0).isoformat(),  
﻿             '%04d' % len(self.pp),  

             '%.2f' % self.pp[0]])  

  

        print(txt)  

  

  

def runstrat():  

    args = parse_args()  

  

    cerebro = bt.Cerebro()  

    data = btfeeds.BacktraderCSVData(dataname=args.data)  

    cerebro.adddata(data)  

    cerebro.resampledata(data, timeframe=bt.TimeFrame.Months)  

  

    cerebro.addstrategy(St,  

                        usepp1=args.usepp1,  

                        plot_on_daily=args.plot_on_daily)  

    cerebro.run(runonce=False)  

    if args.plot:  

        cerebro.plot(style='bar')  

  

  

def parse_args():  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='Sample for pivot point and cross plotting')  

  
﻿    parser.add_argument('--data', required=False,  

                        default='../../datas/2005-2006-day-001.txt',  

                        help='Data to be read in')  

  

    parser.add_argument('--plot', required=False, action='store_true',  

                        help=('Plot the result'))  

  

    parser.add_argument('--plot-on-daily', required=False,  

action='store_true',  

                        help=('Plot the indicator on the daily data'))  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: plot-same-axis\plot-same-axis.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  
﻿# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

  

# The above could be sent to an independent module  

import backtrader as bt  

import backtrader.feeds as btfeeds  
﻿import backtrader.indicators as btind  

  

  

class PlotStrategy(bt.Strategy):  

    '''  

    The strategy does nothing but create indicators for plotting  

purposes  

    '''  

    params = dict(  

        smasubplot=False,  # default for Moving averages  

        nomacdplot=False,  

        rsioverstoc=False,  

        rsioversma=False,  

        stocrsi=False,  

        stocrsilabels=False,  

    )  

  

    def __init__(self):  

        sma = btind.SMA(subplot=self.params.smasubplot)  

  

        macd = btind.MACD()  

        # In SMA we passed plot directly as kwarg, here the  

plotinfo.plot  

        # attribute is changed - same effect  

        macd.plotinfo.plot = not self.params.nomacdplot  

  

        # Let's put rsi on stochastic/sma or the other way round  
﻿        stoc = btind.Stochastic()  

        rsi = btind.RSI()  

        if self.params.stocrsi:  

            stoc.plotinfo.plotmaster = rsi  

            stoc.plotinfo.plotlinelabels = self.p.stocrsilabels  

        elif self.params.rsioverstoc:  

            rsi.plotinfo.plotmaster = stoc  

        elif self.params.rsioversma:  

            rsi.plotinfo.plotmaster = sma  

  

  

def runstrategy():  

    args = parse_args()  

  

    # Create a cerebro  

    cerebro = bt.Cerebro()  

  

    # Get the dates from the args  

    fromdate = datetime.datetime.strptime(args.fromdate, '%Y-%m-%d')  

    todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

  

    # Create the 1st data  

    data = btfeeds.BacktraderCSVData(  

        dataname=args.data,  

        fromdate=fromdate,  

        todate=todate)  

  
﻿    # Add the 1st data to cerebro  

    cerebro.adddata(data)  

  

    # Add the strategy  

    cerebro.addstrategy(PlotStrategy,  

                        smasubplot=args.smasubplot,  

                        nomacdplot=args.nomacdplot,  

                        rsioverstoc=args.rsioverstoc,  

                        rsioversma=args.rsioversma,  

                        stocrsi=args.stocrsi,  

                        stocrsilabels=args.stocrsilabels)  

  

    # And run it  

    cerebro.run(stdstats=args.stdstats)  

  

    # Plot  

    cerebro.plot(numfigs=args.numfigs, volume=False)  

  

  

def parse_args():  

    parser = argparse.ArgumentParser(description='Plotting Example')  

  

    parser.add_argument('--data', '-d',  

                        default='../../datas/2006-day-001.txt',  

                        help='data to add to the system')  

  

    parser.add_argument('--fromdate', '-f',  
﻿                        default='2006-01-01',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', '-t',  

                        default='2006-12-31',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--stdstats', '-st', action='store_true',  

                        help='Show standard observers')  

  

    parser.add_argument('--smasubplot', '-ss', action='store_true',  

                        help='Put SMA on own subplot/axis')  

  

    parser.add_argument('--nomacdplot', '-nm', action='store_true',  

                        help='Hide the indicator from the plot')  

  

    group = parser.add_mutually_exclusive_group(required=False)  

  

    group.add_argument('--rsioverstoc', '-ros', action='store_true',  

                       help='Plot the RSI indicator on the Stochastic  

axis')  

  

    group.add_argument('--rsioversma', '-rom', action='store_true',  

                       help='Plot the RSI indicator on the SMA axis')  

  

    group.add_argument('--stocrsi', '-strsi', action='store_true',  

                       help='Plot the Stochastic indicator on the RSI  
﻿axis')  

  

    parser.add_argument('--stocrsilabels', action='store_true',  

                        help='Plot line names instead of indicator  

name')  

  

    parser.add_argument('--numfigs', '-n', default=1,  

                        help='Plot using numfigs figures')  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrategy()  

  

====================================================================== 

==========  

# 文件: psar\psar-intraday.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  
﻿# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

  

import argparse  

import datetime  

  

import backtrader as bt  

  

  

class St(bt.Strategy):  
﻿    params = (  

    )  

  

    def __init__(self):  

        self.psar0 = bt.ind.ParabolicSAR(self.data0)  

        self.psar1 = bt.ind.ParabolicSAR(self.data1)  

        pass  

  

    def next(self):  

        txt = []  

        txt.append('{:04d}'.format(len(self)))  

        txt.append('{:04d}'.format(len(self.data0)))  

        txt.append(self.data0.datetime.datetime())  

        txt.append('{:.2f}'.format(self.data0.close[0]))  

        txt.append('PSAR')  

        txt.append('{:04.2f}'.format(self.psar0[0]))  

        if len(self.data1):  

            txt.append('{:04d}'.format(len(self.data1)))  

            txt.append(self.data1.datetime.datetime())  

            txt.append('{:.2f}'.format(self.data1.close[0]))  

            txt.append('PSAR')  

            txt.append('{:04.2f}'.format(self.psar1[0]))  

  

        print(','.join(str(x) for x in txt))  

  

  

def runstrat(args=None):  
﻿    args = parse_args(args)  

  

    cerebro = bt.Cerebro()  

  

    # Data feed kwargs  

    kwargs = dict(  

        timeframe=bt.TimeFrame.Minutes,  

        compression=5,  

    )  

  

    # Parse from/to-date  

    dtfmt, tmfmt = '%Y-%m-%d', 'T%H:%M:%S'  

    for a, d in ((getattr(args, x), x) for x in ['fromdate',  

'todate']):  

        if a:  

            strpfmt = dtfmt + tmfmt * ('T' in a)  

            kwargs[d] = datetime.datetime.strptime(a, strpfmt)  

  

    # Data feed  

    data0 = bt.feeds.BacktraderCSVData(dataname=args.data0, **kwargs)  

    cerebro.adddata(data0)  

  

    cerebro.resampledata(data0, timeframe=bt.TimeFrame.Minutes,  

compression=15)  

  

    # Broker  

    cerebro.broker = bt.brokers.BackBroker(**eval('dict(' +  

args.broker + ')'))  
﻿  

    # Sizer  

    cerebro.addsizer(bt.sizers.FixedSize, **eval('dict(' + args.sizer  

+ ')'))  

  

    # Strategy  

    cerebro.addstrategy(St, **eval('dict(' + args.strat + ')'))  

  

    # Execute  

    cerebro.run(**eval('dict(' + args.cerebro + ')'))  

  

    if args.plot:  # Plot if requested to  

        cerebro.plot(**eval('dict(' + args.plot + ')'))  

  

  

def parse_args(pargs=None):  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description=(  

            'Sample Skeleton'  

        )  

    )  

  

    parser.add_argument('--data0', default='../../datas//2006-min- 

005.txt',  

                        required=False, help='Data to read in')  

  
﻿    # Defaults for dates  

    parser.add_argument('--fromdate', required=False, default='',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--todate', required=False, default='',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--cerebro', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--broker', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--sizer', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--strat', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--plot', required=False, default='',  

                        nargs='?', const='{}',  

                        metavar='kwargs', help='kwargs in key=value  

format')  
﻿  

    return parser.parse_args(pargs)  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: psar\psar.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  
﻿# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

  

import argparse  

import datetime  

  

import backtrader as bt  

  

  

class St(bt.Strategy):  

    params = (  

    )  

  

    def __init__(self):  

        self.psar = bt.ind.ParabolicSAR(period=20)  

        pass  

  

    def next(self):  
﻿        txt = ['{:4d}'.format(len(self))]  

        txt.append('{}'.format(self.datetime.date()))  

        txt.append('{:.2f}'.format(self.psar[0]))  

        print(','.join(txt))  

  

  

def runstrat(args=None):  

    args = parse_args(args)  

  

    cerebro = bt.Cerebro()  

  

    # Data feed kwargs  

    kwargs = dict()  

  

    # Parse from/to-date  

    dtfmt, tmfmt = '%Y-%m-%d', 'T%H:%M:%S'  

    for a, d in ((getattr(args, x), x) for x in ['fromdate',  

'todate']):  

        if a:  

            strpfmt = dtfmt + tmfmt * ('T' in a)  

            kwargs[d] = datetime.datetime.strptime(a, strpfmt)  

  

    # Data feed  

    data0 = bt.feeds.BacktraderCSVData(dataname=args.data0, **kwargs)  

    cerebro.adddata(data0)  

  

    # Broker  
﻿    cerebro.broker = bt.brokers.BackBroker(**eval('dict(' +  

args.broker + ')'))  

  

    # Sizer  

    cerebro.addsizer(bt.sizers.FixedSize, **eval('dict(' + args.sizer  

+ ')'))  

  

    # Strategy  

    cerebro.addstrategy(St, **eval('dict(' + args.strat + ')'))  

  

    # Execute  

    cerebro.run(**eval('dict(' + args.cerebro + ')'))  

  

    if args.plot:  # Plot if requested to  

        cerebro.plot(**eval('dict(' + args.plot + ')'))  

  

  

def parse_args(pargs=None):  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description=(  

            'Sample Skeleton'  

        )  

    )  

  

    parser.add_argument('--data0', default='../../datas/2005-2006-day- 

001.txt',  

                        required=False, help='Data to read in')  
﻿  

    # Defaults for dates  

    parser.add_argument('--fromdate', required=False, default='',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--todate', required=False, default='',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--cerebro', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--broker', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--sizer', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--strat', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--plot', required=False, default='',  

                        nargs='?', const='{}',  
﻿                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    return parser.parse_args(pargs)  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: pyfolio2\pyfoliotest.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  
﻿# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

  

import argparse  

import collections  

import datetime  

  

  

import backtrader as bt  

  

  

class St(bt.SignalStrategy):  

    params = (  

         ('pfast', 13),  

         ('pslow', 50),  

         ('printdata', False),  
﻿         ('stake', 1000),  

         ('short', False),  

    )  

  

    def __init__(self):  

        self.sfast = bt.indicators.SMA(period=self.p.pfast)  

        self.sslow = bt.indicators.SMA(period=self.p.pslow)  

        self.cover = bt.indicators.CrossOver(self.sfast, self.sslow)  

        if self.p.short:  

            self.signal_add(bt.SIGNAL_LONGSHORT, self.cover)  

        else:  

            self.signal_add(bt.SIGNAL_LONG, self.cover)  

  

    def start(self):  

        super(self.__class__, self).start()  

        if self.p.printdata:  

            txtfields = list()  

            txtfields.append('Len')  

            txtfields.append('Datetime')  

            txtfields.append('Open')  

            txtfields.append('High')  

            txtfields.append('Low')  

            txtfields.append('Close')  

            txtfields.append('Volume')  

            txtfields.append('OpenInterest')  

            print(','.join(txtfields))  

  
﻿    def next(self):  

        super(self.__class__, self).next()  

        if self.p.printdata:  

            # Print only 1st data ... is just a check that things are  

running  

            txtfields = list()  

            txtfields.append('%04d' % len(self))  

             

txtfields.append(self.data.datetime.datetime(0).isoformat())  

            txtfields.append('%.2f' % self.data0.open[0])  

            txtfields.append('%.2f' % self.data0.high[0])  

            txtfields.append('%.2f' % self.data0.low[0])  

            txtfields.append('%.2f' % self.data0.close[0])  

            txtfields.append('%.2f' % self.data0.volume[0])  

            txtfields.append('%.2f' % self.data0.openinterest[0])  

            print(','.join(txtfields))  

  

  

_TFRAMES = collections.OrderedDict(  

     (  

         ('minutes', bt.TimeFrame.Minutes),  

         ('days', bt.TimeFrame.Days),  

         ('weeks', bt.TimeFrame.Weeks),  

         ('months', bt.TimeFrame.Months),  

         ('years', bt.TimeFrame.Years),  

    )  

)  
﻿  

_TFS = _TFRAMES.keys()  

  

  

def runstrat(args=None):  

    args = parse_args(args)  

  

    cerebro = bt.Cerebro()  

    cerebro.broker.set_cash(args.cash)  

  

    dkwargs = dict()  

    if args.fromdate:  

        fromdate = datetime.datetime.strptime(args.fromdate,  

'%Y-%m-%d')  

        dkwargs['fromdate'] = fromdate  

  

    if args.todate:  

        todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

        dkwargs['todate'] = todate  

  

    if args.timeframe:  

        dkwargs['timeframe'] = _TFRAMES[args.timeframe]  

  

    if args.compression:  

        dkwargs['compression'] = args.compression  

  

    # data0 = bt.feeds.BacktraderCSVData(dataname=args.data0,  
﻿**dkwargs)  

    data0 = bt.feeds.VCData(dataname=args.data0, historical=True,  

**dkwargs)  

    cerebro.adddata(data0, name='Data0')  

  

    cerebro.addstrategy(St, short=args.short,  

printdata=args.printdata)  

    cerebro.addsizer(bt.sizers.FixedSize, stake=args.stake)  

  

    # Own analyzerset  

    cerebro.addanalyzer(bt.analyzers.TimeReturn,  

timeframe=bt.TimeFrame.Years)  

    cerebro.addanalyzer(bt.analyzers.SharpeRatio,  

timeframe=bt.TimeFrame.Years)  

    cerebro.addanalyzer(bt.analyzers.SQN,)  

  

    if args.pyfolio:  

        cerebro.addanalyzer(bt.analyzers.PyFolio, _name='pyfolio',  

                            timeframe=_TFRAMES[args.pftimeframe])  

  

    if args.printout:  

        print('Start run')  

    results = cerebro.run()  

    if args.printout:  

        print('End Run')  

    strat = results[0]  

  

    # Results of own analyzers  
﻿    al = strat.analyzers.timereturn  

    print('-- Time Return:')  

    for k, v in al.get_analysis().items():  

        print('{}: {}'.format(k, v))  

  

    al = strat.analyzers.sharperatio  

    print('-- Sharpe Ratio:')  

    for k, v in al.get_analysis().items():  

        print('{}: {}'.format(k, v))  

  

    al = strat.analyzers.sqn  

    print('-- SQN:')  

    for k, v in al.get_analysis().items():  

        print('{}: {}'.format(k, v))  

  

    if args.pyfolio:  

        pyfoliozer = strat.analyzers.getbyname('pyfolio',)  

  

        returns, positions, transactions, gross_lev =  

pyfoliozer.get_pf_items()  

        if args.printout:  

            print('-- RETURNS')  

            print(returns)  

            print('-- POSITIONS')  

            print(positions)  

            print('-- TRANSACTIONS')  

            print(transactions)  
﻿            print('-- GROSS LEVERAGE')  

            print(gross_lev)  

  

        if True:  

            import pyfolio as pf  

            pf.create_full_tear_sheet(  

                returns,  

                positions=positions,  

                transactions=transactions,  

                gross_lev=gross_lev,  

                round_trips=True)  

  

    if args.plot:  

        pkwargs = dict(style='bar')  

        if args.plot is not True:  # evals to True but is not True  

            pkwargs = eval('dict(' + args.plot + ')')  # args were  

passed  

  

        cerebro.plot(**pkwargs)  

  

  

def parse_args(pargs=None):  

  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='Sample for pivot point and cross plotting')  

  
﻿    parser.add_argument('--data0', required=True,  

                        help='Data to be read in')  

  

    parser.add_argument('--timeframe', required=False,  

                        default=_TFS[0], choices=_TFS,  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--compression', required=False,  

                        default=1, type=int,  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--fromdate', required=False,  

                        default='2013-01-01',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', required=False,  

                        default='2015-12-31',  

                        help='Ending date in YYYY-MM-DD format')  

  

    parser.add_argument('--stake', required=False, action='store',  

                        default=10, type=int,  

                        help=('Stake size'))  

  

    parser.add_argument('--short', required=False,  

action='store_true',  

                        help=('Go short too'))  

  
﻿    parser.add_argument('--cash', required=False, action='store',  

                        type=float, default=50000,  

                        help=('Cash to start with'))  

  

    parser.add_argument('--pyfolio', required=False,  

action='store_true',  

                        help=('Do pyfolio things'))  

  

    parser.add_argument('--pftimeframe', required=False,  

                        default='days', choices=_TFS,  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--printout', required=False,  

action='store_true',  

                        help=('Print infos'))  

  

    parser.add_argument('--printdata', required=False,  

action='store_true',  

                        help=('Print data lines'))  

  

    # Plot options  

    parser.add_argument('--plot', '-p', nargs='?', required=False,  

                        metavar='kwargs', const=True,  

                        help=('Plot the read data applying any kwargs  

passed\n'  

                              '\n'  

                              'For example:\n'  

                              '\n'  
﻿                              '  --plot style="candle" (to plot  

candles)\n'))  

  

    if pargs is not None:  

        return parser.parse_args(pargs)  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: pyfoliotest\pyfoliotest.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  
﻿# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

  

import argparse  

import datetime  

import random  

  

import backtrader as bt  

  

  

class St(bt.Strategy):  

    params = (  

         ('printout', False),  
﻿         ('stake', 1000),  

    )  

  

    def __init__(self):  

        pass  

  

    def start(self):  

        if self.p.printout:  

            txtfields = list()  

            txtfields.append('Len')  

            txtfields.append('Datetime')  

            txtfields.append('Open')  

            txtfields.append('High')  

            txtfields.append('Low')  

            txtfields.append('Close')  

            txtfields.append('Volume')  

            txtfields.append('OpenInterest')  

            print(','.join(txtfields))  

  

    def next(self):  

        if self.p.printout:  

            # Print only 1st data ... is just a check that things are  

running  

            txtfields = list()  

            txtfields.append('%04d' % len(self))  

             

txtfields.append(self.data.datetime.datetime(0).isoformat())  
﻿            txtfields.append('%.2f' % self.data0.open[0])  

            txtfields.append('%.2f' % self.data0.high[0])  

            txtfields.append('%.2f' % self.data0.low[0])  

            txtfields.append('%.2f' % self.data0.close[0])  

            txtfields.append('%.2f' % self.data0.volume[0])  

            txtfields.append('%.2f' % self.data0.openinterest[0])  

            print(','.join(txtfields))  

  

        # Data 0  

        for data in self.datas:  

            toss = random.randint(1, 10)  

            curpos = self.getposition(data)  

            if curpos.size:  

                if toss > 5:  

                    size = curpos.size // 2  

                    self.sell(data=data, size=size)  

                    if self.p.printout:  

                        print('SELL {} @%{}'.format(size,  

data.close[0]))  

  

            elif toss < 5:  

                self.buy(data=data, size=self.p.stake)  

                if self.p.printout:  

                    print('BUY  {} @%{}'.format(self.p.stake,  

data.close[0]))  

  

  
﻿def runstrat(args=None):  

    args = parse_args(args)  

  

    cerebro = bt.Cerebro()  

    cerebro.broker.set_cash(args.cash)  

  

    dkwargs = dict()  

    if args.fromdate:  

        fromdate = datetime.datetime.strptime(args.fromdate,  

'%Y-%m-%d')  

        dkwargs['fromdate'] = fromdate  

  

    if args.todate:  

        todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

        dkwargs['todate'] = todate  

  

    data0 = bt.feeds.YahooFinanceCSVData(dataname=args.data0,  

**dkwargs)  

    cerebro.adddata(data0, name='Data0')  

  

    data1 = bt.feeds.YahooFinanceCSVData(dataname=args.data1,  

**dkwargs)  

    cerebro.adddata(data1, name='Data1')  

  

    data2 = bt.feeds.YahooFinanceCSVData(dataname=args.data2,  

**dkwargs)  

    cerebro.adddata(data2, name='Data2')  

  
﻿    cerebro.addstrategy(St, printout=args.printout)  

    if not args.no_pyfolio:  

        cerebro.addanalyzer(bt.analyzers.PyFolio, _name='pyfolio')  

  

    results = cerebro.run()  

    if not args.no_pyfolio:  

        strat = results[0]  

        pyfoliozer = strat.analyzers.getbyname('pyfolio')  

  

        returns, positions, transactions, gross_lev =  

pyfoliozer.get_pf_items()  

        if args.printout:  

            print('-- RETURNS')  

            print(returns)  

            print('-- POSITIONS')  

            print(positions)  

            print('-- TRANSACTIONS')  

            print(transactions)  

            print('-- GROSS LEVERAGE')  

            print(gross_lev)  

  

        import pyfolio as pf  

        pf.create_full_tear_sheet(  

            returns,  

            positions=positions,  

            transactions=transactions,  

            gross_lev=gross_lev,  
﻿            live_start_date='2005-05-01',  

            round_trips=True)  

  

    if args.plot:  

        cerebro.plot(style=args.plot_style)  

  

  

def parse_args(args=None):  

  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='Sample for pivot point and cross plotting')  

  

    parser.add_argument('--data0', required=False,  

                        default='../../datas/yhoo-1996-2015.txt',  

                        help='Data to be read in')  

  

    parser.add_argument('--data1', required=False,  

                        default='../../datas/orcl-1995-2014.txt',  

                        help='Data to be read in')  

  

    parser.add_argument('--data2', required=False,  

                        default='../../datas/nvda-1999-2014.txt',  

                        help='Data to be read in')  

  

    parser.add_argument('--fromdate', required=False,  

                        default='2005-01-01',  
﻿                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', required=False,  

                        default='2006-12-31',  

                        help='Ending date in YYYY-MM-DD format')  

  

    parser.add_argument('--printout', required=False,  

action='store_true',  

                        help=('Print data lines'))  

  

    parser.add_argument('--cash', required=False, action='store',  

                        type=float, default=50000,  

                        help=('Cash to start with'))  

  

    parser.add_argument('--plot', required=False, action='store_true',  

                        help=('Plot the result'))  

  

    parser.add_argument('--plot-style', required=False,  

action='store',  

                        default='bar', choices=['bar', 'candle',  

'line'],  

                        help=('Plot style'))  

  

    parser.add_argument('--no-pyfolio', required=False,  

action='store_true',  

                        help=('Do not do pyfolio things'))  

  

    import sys  
﻿    aargs = args if args is not None else sys.argv[1:]  

    return parser.parse_args(aargs)  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: relative-volume\relative-volume.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  
﻿# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

  

# The above could be sent to an independent module  

import backtrader as bt  

import backtrader.feeds as btfeeds  

  

from relvolbybar import RelativeVolumeByBar  

  

  

def runstrategy():  

    args = parse_args()  

  

    # Create a cerebro  

    cerebro = bt.Cerebro()  

  
﻿    # Get the dates from the args  

    fromdate = datetime.datetime.strptime(args.fromdate, '%Y-%m-%d')  

    todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

  

    # Create the 1st data  

    data = btfeeds.BacktraderCSVData(  

        dataname=args.data,  

        fromdate=fromdate,  

        todate=todate,  

        )  

  

    # Add the 1st data to cerebro  

    cerebro.adddata(data)  

  

    # Add an empty strategy  

    cerebro.addstrategy(bt.Strategy)  

  

    # Get the session times to pass them to the indicator  

    prestart = datetime.datetime.strptime(args.prestart,  

'%H:%M').time()  

    start = datetime.datetime.strptime(args.start, '%H:%M').time()  

    end = datetime.datetime.strptime(args.end, '%H:%M').time()  

  

    # Add the Relative volume indicator  

    cerebro.addindicator(RelativeVolumeByBar,  

                         prestart=prestart, start=start, end=end)  

  
﻿    # Add a writer with CSV  

    if args.writer:  

        cerebro.addwriter(bt.WriterFile, csv=args.wrcsv)  

  

    # And run it  

    cerebro.run(stdstats=False)  

  

    # Plot if requested  

    if args.plot:  

        cerebro.plot(numfigs=args.numfigs, volume=True)  

  

  

def parse_args():  

    parser = argparse.ArgumentParser(description='MultiData Strategy')  

  

    parser.add_argument('--data', '-d',  

                        default='../../datas/2006-01-02-volume-min- 

001.txt',  

                        help='data to add to the system')  

  

    parser.add_argument('--prestart',  

                        default='08:00',  

                        help='Start time for the Session Filter')  

  

    parser.add_argument('--start',  

                        default='09:15',  

                        help='Start time for the Session Filter')  
﻿  

    parser.add_argument('--end', '-te',  

                        default='17:15',  

                        help='End time for the Session Filter')  

  

    parser.add_argument('--fromdate', '-f',  

                        default='2006-01-01',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', '-t',  

                        default='2006-12-31',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--writer', '-w', action='store_true',  

                        help='Add a writer to cerebro')  

  

    parser.add_argument('--wrcsv', '-wc', action='store_true',  

                        help='Enable CSV Output in the writer')  

  

    parser.add_argument('--plot', '-p', action='store_true',  

                        help='Plot the read data')  

  

    parser.add_argument('--numfigs', '-n', default=1,  

                        help='Plot using numfigs figures')  

  

    return parser.parse_args()  

  
﻿  

if __name__ == '__main__':  

    runstrategy()  

  

====================================================================== 

==========  

# 文件: relative-volume\relvolbybar.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  
﻿# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import collections  

import datetime  

import math  

  

  

import backtrader as bt  

  

  

class RelativeVolumeByBar(bt.Indicator):  

    alias = ('RVBB',)  

    lines = ('rvbb',)  

  

    params = (  

         ('prestart', datetime.time(8, 00)),  

         ('start', datetime.time(9, 10)),  

         ('end', datetime.time(17, 15)),  

    )  

  

    def _plotlabel(self):  
﻿        plabels = []  

        for name, value in self.params._getitems():  

            plabels.append('%s: %s' % (name, value.strftime('%H:%M')))  

  

        return plabels  

  

    def __init__(self):  

        # Inform the platform about the minimum period needs  

        minbuffer = self._calcbuffer()  

        self.addminperiod(minbuffer)  

  

        # Structures/variable to keep synchronization  

        self.pvol = dict()  

        self.vcount = collections.defaultdict(int)  

  

        self.days = 0  

        self.dtlast = datetime.date.min  

  

        # Done after calc to ensure coop inheritance and composition  

work  

        super(RelativeVolumeByBar, self).__init__()  

  

    def _barisvalid(self, tm):  

        return self.p.start <= tm <= self.p.end  

  

    def _daycount(self):  

        dt = self.data.datetime.date()  
﻿        if dt > self.dtlast:  

            self.days += 1  

            self.dtlast = dt  

  

    def prenext(self):  

        self._daycount()  

  

        tm = self.data.datetime.time()  

        if self._barisvalid(tm):  

            self.pvol[tm] = self.data.volume[0]  

            self.vcount[tm] += 1  

  

    def next(self):  

        self._daycount()  

  

        tm = self.data.datetime.time()  

        if not self._barisvalid(tm):  

            return  

  

        # Record the "minute/second" of this day has been seen  

        self.vcount[tm] += 1  

  

        # Get the bar's volume  

        vol = self.data.volume[0]  

  

        # If number of days is right, we saw the same "minute/second"  

last day  
﻿        if self.vcount[tm] == self.days:  

            self.lines.rvbb[0] = vol / self.pvol[tm]  

  

        # Synchronize the days and volume count for next cycle  

        self.vcount[tm] = self.days  

  

        # Record the volume for this bar for next cycle  

        self.pvol[tm] = vol  

  

    def _calcbuffer(self):  

        # Period calculation  

        minend = self.p.end.hour * 60 + self.p.end.minute  

        # minstart = session_start.hour * 60 + session_start.minute  

        # use prestart to account for market_data  

        minstart = self.p.prestart.hour * 60 + self.p.prestart.minute  

  

        minbuffer = minend - minstart  

  

        tframe = self.data._timeframe  

        tcomp = self.data._compression  

  

        if tframe == bt.TimeFrame.Seconds:  

            minbuffer = (minperiod * 60)  

  

        minbuffer = (minbuffer // tcomp) + tcomp  

  

        return minbuffer  
﻿  

====================================================================== 

==========  

# 文件: renko\renko.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  
﻿###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

  

import backtrader as bt  

  

  

class St(bt.Strategy):  

    params = dict(  

    )  

  

    def __init__(self):  

        for d in self.datas:  

            bt.ind.RSI(d)  

  

    def next(self):  

        pass  

  

  

def runstrat(args=None):  

    args = parse_args(args)  

  

    cerebro = bt.Cerebro()  
﻿  

    # Data feed kwargs  

    kwargs = dict()  

  

    # Parse from/to-date  

    dtfmt, tmfmt = '%Y-%m-%d', 'T%H:%M:%S'  

    for a, d in ((getattr(args, x), x) for x in ['fromdate',  

'todate']):  

        if a:  

            strpfmt = dtfmt + tmfmt * ('T' in a)  

            kwargs[d] = datetime.datetime.strptime(a, strpfmt)  

  

    data0 = bt.feeds.BacktraderCSVData(dataname=args.data0, **kwargs)  

  

    fkwargs = dict()  

    fkwargs.update(**eval('dict(' + args.renko + ')'))  

  

    if not args.dual:  

        data0.addfilter(bt.filters.Renko, **fkwargs)  

        cerebro.adddata(data0)  

    else:  

        cerebro.adddata(data0)  

        data1 = data0.clone()  

        data1.addfilter(bt.filters.Renko, **fkwargs)  

        cerebro.adddata(data1)  

  

    # Broker  
﻿    cerebro.broker = bt.brokers.BackBroker(**eval('dict(' +  

args.broker + ')'))  

  

    # Sizer  

    cerebro.addsizer(bt.sizers.FixedSize, **eval('dict(' + args.sizer  

+ ')'))  

  

    # Strategy  

    cerebro.addstrategy(St, **eval('dict(' + args.strat + ')'))  

  

    # Execute  

    kwargs = dict(stdstats=False)  

    kwargs.update(**eval('dict(' + args.cerebro + ')'))  

    cerebro.run(**kwargs)  

  

    if args.plot:  # Plot if requested to  

        kwargs = dict(style='candle')  

        kwargs.update(**eval('dict(' + args.plot + ')'))  

        cerebro.plot(**kwargs)  

  

  

def parse_args(pargs=None):  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description=(  

            'Renko bricks sample'  

        )  
﻿    )  

  

    parser.add_argument('--data0', default='../../datas/2005-2006-day- 

001.txt',  

                        required=False, help='Data to read in')  

  

    # Defaults for dates  

    parser.add_argument('--fromdate', required=False, default='',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--todate', required=False, default='',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--cerebro', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--broker', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--sizer', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--strat', required=False, default='',  
﻿                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--plot', required=False, default='',  

                        nargs='?', const='{}',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--renko', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--dual', required=False, action='store_true',  

                        help='put the filter on a second version of  

the data')  

  

    return parser.parse_args(pargs)  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: resample-tickdata\resample-tickdata.txt  

====================================================================== 

==========  

  
﻿#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

  
﻿import backtrader as bt  

import backtrader.feeds as btfeeds  

  

  

def runstrat():  

    args = parse_args()  

  

    # Create a cerebro entity  

    cerebro = bt.Cerebro(stdstats=False)  

  

    # Add a strategy  

    cerebro.addstrategy(bt.Strategy)  

  

    # Load the Data  

    datapath = args.dataname or '../../datas/ticksample.csv'  

  

    data = btfeeds.GenericCSVData(  

        dataname=datapath,  

        dtformat='%Y-%m-%dT%H:%M:%S.%f',  

        timeframe=bt.TimeFrame.Ticks,  

    )  

  

    # Handy dictionary for the argument timeframe conversion  

    tframes = dict(  

        ticks=bt.TimeFrame.Ticks,  

        microseconds=bt.TimeFrame.MicroSeconds,  

        seconds=bt.TimeFrame.Seconds,  
﻿        minutes=bt.TimeFrame.Minutes,  

        daily=bt.TimeFrame.Days,  

        weekly=bt.TimeFrame.Weeks,  

        monthly=bt.TimeFrame.Months)  

  

    # Resample the data  

    cerebro.resampledata(  

        data,  

        timeframe=tframes[args.timeframe],  

        compression=args.compression,  

        bar2edge=not args.nobar2edge,  

        adjbartime=not args.noadjbartime,  

        rightedge=args.rightedge)  

  

    if args.writer:  

        # add a writer  

        cerebro.addwriter(bt.WriterFile, csv=args.wrcsv)  

  

    # Run over everything  

    cerebro.run()  

  

    # Plot the result  

    cerebro.plot(style='bar')  

  

  

def parse_args():  

    parser = argparse.ArgumentParser(  
﻿        description='Resampling script down to tick data')  

  

    parser.add_argument('--dataname', default='', required=False,  

                        help='File Data to Load')  

  

    parser.add_argument('--timeframe', default='ticks',  

required=False,  

                        choices=['ticks', 'microseconds', 'seconds',  

                                 'minutes', 'daily', 'weekly',  

'monthly'],  

                        help='Timeframe to resample to')  

  

    parser.add_argument('--compression', default=1, required=False,  

type=int,  

                        help=('Compress n bars into 1'))  

  

    parser.add_argument('--nobar2edge', required=False,  

action='store_true',  

                        help=('Do not Resample IntraDay Timed Bars to  

edges'))  

  

    parser.add_argument('--noadjbartime', required=False,  

                        action='store_true',  

                        help=('Do not adjust the time bar to meet the  

edges'))  

  

    parser.add_argument('--rightedge', required=False,  

action='store_true',  

                        help=('Resample to right edge of boundary'))  
﻿  

    parser.add_argument('--writer', required=False,  

action='store_true',  

                        help=('Add a Writer'))  

  

    parser.add_argument('--wrcsv', required=False,  

action='store_true',  

                        help=('Add CSV to the Writer'))  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: rollover\rollover.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  
﻿# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

  

import argparse  

import bisect  

import calendar  

import datetime  

  

import backtrader as bt  

  
﻿  

class TheStrategy(bt.Strategy):  

    def start(self):  

        header = ['Len', 'Name', 'RollName', 'Datetime', 'WeekDay',  

'Open',  

                  'High', 'Low', 'Close', 'Volume', 'OpenInterest']  

        print(', '.join(header))  

  

    def next(self):  

        txt = list()  

        txt.append('%04d' % len(self.data0))  

        txt.append('{}'.format(self.data0._dataname))  

        # Internal knowledge ... current expiration in use is in _d  

        txt.append('{}'.format(self.data0._d._dataname))  

        txt.append('{}'.format(self.data.datetime.date()))  

         

txt.append('{}'.format(self.data.datetime.date().strftime('%a')))  

        txt.append('{}'.format(self.data.open[0]))  

        txt.append('{}'.format(self.data.high[0]))  

        txt.append('{}'.format(self.data.low[0]))  

        txt.append('{}'.format(self.data.close[0]))  

        txt.append('{}'.format(self.data.volume[0]))  

        txt.append('{}'.format(self.data.openinterest[0]))  

        print(', '.join(txt))  

  

  

def checkdate(dt, d):  
﻿    # Check if the date is in the week where the 3rd friday of  

Mar/Jun/Sep/Dec  

  

    # EuroStoxx50 expiry codes: MY  

    # M -> H, M, U, Z (Mar, Jun, Sep, Dec)  

    # Y -> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 -> year code. 5 -> 2015  

    MONTHS = dict(H=3, M=6, U=9, Z=12)  

  

    M = MONTHS[d._dataname[-2]]  

  

    centuria, year = divmod(dt.year, 10)  

    decade = centuria * 10  

  

    YCode = int(d._dataname[-1])  

    Y = decade + YCode  

    if Y < dt.year:  # Example: year 2019 ... YCode is 0 for 2023  

        Y += 10  

  

    exp_day = 21 -  (calendar.weekday(Y, M, 1) + 2) % 7  

    exp_dt = datetime.datetime(Y, M, exp_day)  

  

    # Get the year, week numbers  

    exp_year, exp_week, _ = exp_dt.isocalendar()  

    dt_year, dt_week, _ = dt.isocalendar()  

  

    # print('dt {} vs {} exp_dt'.format(dt, exp_dt))  

    # print('dt_week {} vs {} exp_week'.format(dt_week, exp_week))  
﻿  

    # can switch if in same week  

    return (dt_year, dt_week) == (exp_year, exp_week)  

  

  

def checkvolume(d0, d1):  

    return d0.volume[0] < d1.volume[0]  # Switch if volume from d0 <  

d1  

  

  

def runstrat(args=None):  

    args = parse_args(args)  

  

    cerebro = bt.Cerebro()  

  

    fcodes = ['199FESXM4', '199FESXU4', '199FESXZ4', '199FESXH5',  

'199FESXM5']  

    store = bt.stores.VChartFile()  

    ffeeds = [store.getdata(dataname=x) for x in fcodes]  

  

    rollkwargs = dict()  

    if args.checkdate:  

        rollkwargs['checkdate'] = checkdate  

  

        if args.checkcondition:  

            rollkwargs['checkcondition'] = checkvolume  

  
﻿    if not args.no_cerebro:  

        if args.rollover:  

            cerebro.rolloverdata(name='FESX', *ffeeds, **rollkwargs)  

        else:  

            cerebro.chaindata(name='FESX', *ffeeds)  

    else:  

        drollover = bt.feeds.RollOver(*ffeeds, dataname='FESX',  

**rollkwargs)  

        cerebro.adddata(drollover)  

  

    cerebro.addstrategy(TheStrategy)  

    cerebro.run(stdstats=False)  

  

    if args.plot:  

        pkwargs = dict(style='bar')  

        if args.plot is not True:  # evals to True but is not True  

            npkwargs = eval('dict(' + args.plot + ')')  # args were  

passed  

            pkwargs.update(npkwargs)  

  

        cerebro.plot(**pkwargs)  

  

  

def parse_args(pargs=None):  

  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  
﻿        description='Sample for Roll Over of Futures')  

  

    parser.add_argument('--no-cerebro', required=False,  

action='store_true',  

                        help='Use RollOver Directly')  

  

    parser.add_argument('--rollover', required=False,  

action='store_true')  

  

    parser.add_argument('--checkdate', required=False,  

action='store_true',  

                        help='Change during expiration week')  

  

    parser.add_argument('--checkcondition', required=False,  

                        action='store_true',  

                        help='Change when a given condition is met')  

  

    # Plot options  

    parser.add_argument('--plot', '-p', nargs='?', required=False,  

                        metavar='kwargs', const=True,  

                        help=('Plot the read data applying any kwargs  

passed\n'  

                              '\n'  

                              'For example:\n'  

                              '\n'  

                              '  --plot style="candle" (to plot  

candles)\n'))  

  
﻿    if pargs is not None:  

        return parser.parse_args(pargs)  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: sharpe-timereturn\sharpe-timereturn.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  
﻿# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

  

import backtrader as bt  

  

  

def runstrat(pargs=None):  

    args = parse_args(pargs)  

  

    # Create a cerebro  

    cerebro = bt.Cerebro()  

  

    if args.cash is not None:  

        cerebro.broker.set_cash(args.cash)  
﻿  

    # Get the dates from the args  

    fromdate = datetime.datetime.strptime(args.fromdate, '%Y-%m-%d')  

    todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

  

    # Create the 1st data  

    data = bt.feeds.BacktraderCSVData(  

        dataname=args.data,  

        fromdate=fromdate,  

        todate=todate)  

  

    cerebro.adddata(data)  # Add the data to cerebro  

  

    # Add the strategy  

    cerebro.addstrategy(bt.strategies.SMA_CrossOver)  

  

    tframes = dict(  

        days=bt.TimeFrame.Days,  

        weeks=bt.TimeFrame.Weeks,  

        months=bt.TimeFrame.Months,  

        years=bt.TimeFrame.Years)  

  

    # Add the Analyzers  

    cerebro.addanalyzer(bt.analyzers.TimeReturn,  

                        timeframe=tframes[args.tframe])  

  

    shkwargs = dict()  
﻿    if args.annualize:  

        shkwargs['annualize'] = True  

  

    if args.riskfreerate is not None:  

        shkwargs['riskfreerate'] = args.riskfreerate  

  

    if args.factor is not None:  

        shkwargs['factor'] = args.factor  

  

    if args.stddev_sample:  

        shkwargs['stddev_sample'] = True  

  

    if args.no_convertrate:  

        shkwargs['convertrate'] = False  

  

    cerebro.addanalyzer(bt.analyzers.SharpeRatio,  

                        timeframe=tframes[args.tframe],  

                        **shkwargs)  

  

    # Add a writer to get output  

    cerebro.addwriter(bt.WriterFile, csv=args.writercsv, rounding=4)  

  

    cerebro.run()  # And run it  

  

    # Plot if requested  

    if args.plot:  

        pkwargs = dict(style='bar')  
﻿        if args.plot is not True:  # evals to True but is not True  

            npkwargs = eval('dict(' + args.plot + ')')  # args were  

passed  

            pkwargs.update(npkwargs)  

  

        cerebro.plot(**pkwargs)  

  

  

def parse_args(pargs=None):  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='TimeReturns and SharpeRatio')  

  

    parser.add_argument('--data', '-d',  

                        default='../../datas/2005-2006-day-001.txt',  

                        help='data to add to the system')  

  

    parser.add_argument('--cash', default=None, type=float,  

required=False,  

                        help='Starting Cash')  

  

    parser.add_argument('--fromdate', '-f',  

                        default='2005-01-01',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', '-t',  

                        default='2006-12-31',  
﻿                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--writercsv', '-wcsv', action='store_true',  

                        help='Tell the writer to produce a csv  

stream')  

  

    parser.add_argument('--tframe', '--timeframe', default='years',  

                        required=False,  

                        choices=['days', 'weeks', 'months', 'years'],  

                        help='TimeFrame for the Returns/Sharpe  

calculations')  

  

    parser.add_argument('--annualize', required=False,  

action='store_true',  

                        help='Annualize Sharpe Ratio')  

  

    parser.add_argument('--riskfreerate', required=False,  

action='store',  

                        type=float, default=None,  

                        help='Riskfree Rate (annual) for Sharpe')  

  

    parser.add_argument('--factor', required=False, action='store',  

                        type=float, default=None,  

                        help=('Riskfree Rate conversion factor for  

Sharpe '  

                              'to downgrade riskfree rate to  

timeframe'))  

  
﻿    parser.add_argument('--stddev-sample', required=False,  

action='store_true',  

                        help='Consider Bessels correction for  

stddeviation')  

  

    parser.add_argument('--no-convertrate', required=False,  

                        action='store_true',  

                        help=('Upgrade returns to target timeframe  

rather than'  

                              'downgrading the riskfreerate'))  

  

    # Plot options  

    parser.add_argument('--plot', '-p', nargs='?', required=False,  

                        metavar='kwargs', const=True,  

                        help=('Plot the read data applying any kwargs  

passed\n'  

                              '\n'  

                              'For example:\n'  

                              '\n'  

                              '  --plot style="candle" (to plot  

candles)\n'))  

  

    if pargs is not None:  

        return parser.parse_args(pargs)  

  

    return parser.parse_args()  

  

  
﻿if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: signals-strategy\signals-strategy.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  
﻿<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import collections  

import datetime  

  

import backtrader as bt  

  

MAINSIGNALS = collections.OrderedDict(  

     (('longshort', bt.SIGNAL_LONGSHORT),  

      ('longonly', bt.SIGNAL_LONG),  

      ('shortonly', bt.SIGNAL_SHORT),)  

)  

  

  

EXITSIGNALS = {  

    'longexit': bt.SIGNAL_LONGEXIT,  

    'shortexit': bt.SIGNAL_LONGEXIT,  

}  

  

  

class SMACloseSignal(bt.Indicator):  
﻿    lines = ('signal',)  

    params = (('period', 30),)  

  

    def __init__(self):  

        self.lines.signal = self.data -  

bt.indicators.SMA(period=self.p.period)  

  

  

class SMAExitSignal(bt.Indicator):  

    lines = ('signal',)  

    params = (('p1', 5), ('p2', 30),)  

  

    def __init__(self):  

        sma1 = bt.indicators.SMA(period=self.p.p1)  

        sma2 = bt.indicators.SMA(period=self.p.p2)  

        self.lines.signal = sma1 - sma2  

  

  

def runstrat(args=None):  

    args = parse_args(args)  

  

    cerebro = bt.Cerebro()  

    cerebro.broker.set_cash(args.cash)  

  

    dkwargs = dict()  

    if args.fromdate is not None:  

        fromdate = datetime.datetime.strptime(args.fromdate,  
﻿'%Y-%m-%d')  

        dkwargs['fromdate'] = fromdate  

  

    if args.todate is not None:  

        todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

        dkwargs['todate'] = todate  

  

    # if dataset is None, args.data has been given  

    data = bt.feeds.BacktraderCSVData(dataname=args.data, **dkwargs)  

    cerebro.adddata(data)  

  

    cerebro.add_signal(MAINSIGNALS[args.signal],  

                       SMACloseSignal, period=args.smaperiod)  

  

    if args.exitsignal is not None:  

        cerebro.add_signal(EXITSIGNALS[args.exitsignal],  

                           SMAExitSignal,  

                           p1=args.exitperiod,  

                           p2=args.smaperiod)  

  

    cerebro.run()  

    if args.plot:  

        pkwargs = dict(style='bar')  

        if args.plot is not True:  # evals to True but is not True  

            npkwargs = eval('dict(' + args.plot + ')')  # args were  

passed  

            pkwargs.update(npkwargs)  
﻿  

        cerebro.plot(**pkwargs)  

  

  

def parse_args(pargs=None):  

  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='Sample for Signal concepts')  

  

    parser.add_argument('--data', required=False,  

                        default='../../datas/2005-2006-day-001.txt',  

                        help='Specific data to be read in')  

  

    parser.add_argument('--fromdate', required=False, default=None,  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', required=False, default=None,  

                        help='Ending date in YYYY-MM-DD format')  

  

    parser.add_argument('--cash', required=False, action='store',  

                        type=float, default=50000,  

                        help=('Cash to start with'))  

  

    parser.add_argument('--smaperiod', required=False, action='store',  

                        type=int, default=30,  

                        help=('Period for the moving average'))  
﻿  

    parser.add_argument('--exitperiod', required=False,  

action='store',  

                        type=int, default=5,  

                        help=('Period for the exit control SMA'))  

  

    parser.add_argument('--signal', required=False, action='store',  

                        default=MAINSIGNALS.keys()[0],  

choices=MAINSIGNALS,  

                        help=('Signal type to use for the main  

signal'))  

  

    parser.add_argument('--exitsignal', required=False,  

action='store',  

                        default=None, choices=EXITSIGNALS,  

                        help=('Signal type to use for the exit  

signal'))  

  

    # Plot options  

    parser.add_argument('--plot', '-p', nargs='?', required=False,  

                        metavar='kwargs', const=True,  

                        help=('Plot the read data applying any kwargs  

passed\n'  

                              '\n'  

                              'For example:\n'  

                              '\n'  

                              '  --plot style="candle" (to plot  

candles)\n'))  

  
﻿    if pargs is not None:  

        return parser.parse_args(pargs)  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: sigsmacross\sigsmacross.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  
﻿# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

  

import backtrader as bt  

  

  

class SmaCross(bt.SignalStrategy):  

    params = dict(sma1=10, sma2=20)  

  

    def notify_order(self, order):  

        if not order.alive():  

            print('{} {} {}@{}'.format(  

                bt.num2date(order.executed.dt),  

                'buy' if order.isbuy() else 'sell',  
﻿                order.executed.size,  

                order.executed.price)  

            )  

  

    def notify_trade(self, trade):  

        if trade.isclosed:  

            print('profit {}'.format(trade.pnlcomm))  

  

    def __init__(self):  

        sma1 = bt.ind.SMA(period=self.params.sma1)  

        sma2 = bt.ind.SMA(period=self.params.sma2)  

        crossover = bt.ind.CrossOver(sma1, sma2)  

        self.signal_add(bt.SIGNAL_LONG, crossover)  

  

  

def runstrat(pargs=None):  

    args = parse_args(pargs)  

  

    cerebro = bt.Cerebro()  

    cerebro.broker.set_cash(args.cash)  

  

    data0 = bt.feeds.YahooFinanceData(  

        dataname=args.data,  

        fromdate=datetime.datetime.strptime(args.fromdate,  

'%Y-%m-%d'),  

        todate=datetime.datetime.strptime(args.todate, '%Y-%m-%d'))  

    cerebro.adddata(data0)  
﻿  

    cerebro.addstrategy(SmaCross, **(eval('dict(' + args.strat +  

')')))  

    cerebro.addsizer(bt.sizers.FixedSize, stake=args.stake)  

  

    cerebro.run()  

    if args.plot:  

        cerebro.plot(**(eval('dict(' + args.plot + ')')))  

  

  

def parse_args(pargs=None):  

  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='sigsmacross')  

  

    parser.add_argument('--data', required=False, default='YHOO',  

                        help='Yahoo Ticker')  

  

    parser.add_argument('--fromdate', required=False, default='2011- 

01-01',  

                        help='Ending date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', required=False, default='2012-12- 

31',  

                        help='Ending date in YYYY-MM-DD format')  

  

    parser.add_argument('--cash', required=False, action='store',  
﻿type=float,  

                        default=10000, help=('Starting cash'))  

  

    parser.add_argument('--stake', required=False, action='store',  

type=int,  

                        default=1, help=('Stake to apply'))  

  

    parser.add_argument('--strat', required=False, action='store',  

default='',  

                        help=('Arguments for the strategy'))  

  

    parser.add_argument('--plot', '-p', nargs='?', required=False,  

                        metavar='kwargs', const='{}',  

                        help=('Plot the read data applying any kwargs  

passed\n'  

                              '\n'  

                              'For example:\n'  

                              '\n'  

                              '  --plot style="candle" (to plot  

candles)\n'))  

  

    return parser.parse_args(pargs)  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 
﻿==========  

# 文件: sigsmacross\sigsmacross2.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  
﻿from datetime import datetime  

import backtrader as bt  

  

  

class SmaCross(bt.SignalStrategy):  

    def __init__(self):  

        sma1 = bt.ind.SMA(period=10)  

        sma2 = bt.ind.SMA(period=30)  

        crossover = bt.ind.CrossOver(sma1, sma2)  

        self.signal_add(bt.SIGNAL_LONG, crossover)  

  

  

cerebro = bt.Cerebro()  

cerebro.addstrategy(SmaCross)  

  

data0 = bt.feeds.YahooFinanceData(dataname='YHOO',  

                                  fromdate=datetime(2011, 1, 1),  

                                  todate=datetime(2012, 12, 31))  

  

cerebro.adddata(data0)  

  

cerebro.run()  

cerebro.plot()  

  

====================================================================== 

==========  

# 文件: sizertest\sizertest.txt  
﻿====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  
﻿  

import argparse  

import datetime  

import random  

  

import backtrader as bt  

  

  

class CloseSMA(bt.Strategy):  

    params = (('period', 15),)  

  

    def __init__(self):  

        sma = bt.indicators.SMA(self.data, period=self.p.period)  

        self.crossover = bt.indicators.CrossOver(self.data, sma)  

  

    def next(self):  

        if self.crossover > 0:  

            self.buy()  

  

        elif self.crossover < 0:  

            self.sell()  

  

  

class LongOnly(bt.Sizer):  

    params = (('stake', 1),)  

  

    def _getsizing(self, comminfo, cash, data, isbuy):  
﻿        if isbuy:  

            return self.p.stake  

  

        # Sell situation  

        position = self.broker.getposition(data)  

        if not position.size:  

            return 0  # do not sell if nothing is open  

  

        return self.p.stake  

  

  

class FixedReverser(bt.Sizer):  

    params = (('stake', 1),)  

  

    def _getsizing(self, comminfo, cash, data, isbuy):  

        position = self.strategy.getposition(data)  

        size = self.p.stake * (1 + (position.size != 0))  

        return size  

  

  

def runstrat(args=None):  

    args = parse_args(args)  

  

    cerebro = bt.Cerebro()  

    cerebro.broker.set_cash(args.cash)  

  

    dkwargs = dict()  
﻿    if args.fromdate:  

        fromdate = datetime.datetime.strptime(args.fromdate,  

'%Y-%m-%d')  

        dkwargs['fromdate'] = fromdate  

  

    if args.todate:  

        todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

        dkwargs['todate'] = todate  

  

    data0 = bt.feeds.YahooFinanceCSVData(dataname=args.data0,  

**dkwargs)  

    cerebro.adddata(data0, name='Data0')  

  

    cerebro.addstrategy(CloseSMA, period=args.period)  

  

    if args.longonly:  

        cerebro.addsizer(LongOnly, stake=args.stake)  

    else:  

        cerebro.addsizer(bt.sizers.FixedReverser, stake=args.stake)  

  

    cerebro.run()  

    if args.plot:  

        pkwargs = dict()  

        if args.plot is not True:  # evals to True but is not True  

            pkwargs = eval('dict(' + args.plot + ')')  # args were  

passed  

  

        cerebro.plot(**pkwargs)  
﻿  

  

def parse_args(pargs=None):  

  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='Sample for sizer')  

  

    parser.add_argument('--data0', required=False,  

                        default='../../datas/yhoo-1996-2015.txt',  

                        help='Data to be read in')  

  

    parser.add_argument('--fromdate', required=False,  

                        default='2005-01-01',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', required=False,  

                        default='2006-12-31',  

                        help='Ending date in YYYY-MM-DD format')  

  

    parser.add_argument('--cash', required=False, action='store',  

                        type=float, default=50000,  

                        help=('Cash to start with'))  

  

    parser.add_argument('--longonly', required=False,  

action='store_true',  

                        help=('Use the LongOnly sizer'))  
﻿  

    parser.add_argument('--stake', required=False, action='store',  

                        type=int, default=1,  

                        help=('Stake to pass to the sizers'))  

  

    parser.add_argument('--period', required=False, action='store',  

                        type=int, default=15,  

                        help=('Period for the Simple Moving Average'))  

  

    # Plot options  

    parser.add_argument('--plot', '-p', nargs='?', required=False,  

                        metavar='kwargs', const=True,  

                        help=('Plot the read data applying any kwargs  

passed\n'  

                              '\n'  

                              'For example:\n'  

                              '\n'  

                              '  --plot style="candle" (to plot  

candles)\n'))  

  

    if pargs is not None:  

        return parser.parse_args(pargs)  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  
﻿    runstrat()  

  

====================================================================== 

==========  

# 文件: slippage\slippage.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  
﻿#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import collections  

import datetime  

import itertools  

  

import backtrader as bt  

  

  

class SMACrossOver(bt.Indicator):  

    lines = ('signal',)  

    params = (('p1', 10), ('p2', 30),)  

  

    def __init__(self):  

        sma1 = bt.indicators.SMA(period=self.p.p1)  

        sma2 = bt.indicators.SMA(period=self.p.p2)  

        self.lines.signal = bt.indicators.CrossOver(sma1, sma2)  

  

  

class SlipSt(bt.SignalStrategy):  

    opcounter = itertools.count(1)  

  
﻿    def notify_order(self, order):  

        if order.status == bt.Order.Completed:  

            t = ''  

            t += '{:02d}'.format(next(self.opcounter))  

            t += ' {}'.format(order.data.datetime.datetime())  

            t += ' BUY ' * order.isbuy() or ' SELL'  

            t += ' Size: {:+d} / Price: {:.2f}'  

            print(t.format(order.executed.size, order.executed.price))  

  

  

def runstrat(args=None):  

    args = parse_args(args)  

  

    cerebro = bt.Cerebro()  

    cerebro.broker.set_cash(args.cash)  

  

    dkwargs = dict()  

    if args.fromdate is not None:  

        fromdate = datetime.datetime.strptime(args.fromdate,  

'%Y-%m-%d')  

        dkwargs['fromdate'] = fromdate  

  

    if args.todate is not None:  

        todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

        dkwargs['todate'] = todate  

  

    # if dataset is None, args.data has been given  
﻿    data = bt.feeds.BacktraderCSVData(dataname=args.data, **dkwargs)  

    cerebro.adddata(data)  

  

    cerebro.signal_strategy(SlipSt)  

    if not args.longonly:  

        stype = bt.signal.SIGNAL_LONGSHORT  

    else:  

        stype = bt.signal.SIGNAL_LONG  

  

    cerebro.add_signal(stype, SMACrossOver, p1=args.period1,  

p2=args.period2)  

  

    if args.slip_perc is not None:  

        cerebro.broker.set_slippage_perc(args.slip_perc,  

                                         slip_open=args.slip_open,  

                                         slip_match=not  

args.no_slip_match,  

                                         slip_out=args.slip_out)  

  

    elif args.slip_fixed is not None:  

        cerebro.broker.set_slippage_fixed(args.slip_fixed,  

                                          slip_open=args.slip_open,  

                                          slip_match=not  

args.no_slip_match,  

                                          slip_out=args.slip_out)  

  

    cerebro.run()  

    if args.plot:  
﻿        pkwargs = dict(style='bar')  

        if args.plot is not True:  # evals to True but is not True  

            npkwargs = eval('dict(' + args.plot + ')')  # args were  

passed  

            pkwargs.update(npkwargs)  

  

        cerebro.plot(**pkwargs)  

  

  

def parse_args(pargs=None):  

  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='Sample for Slippage')  

  

    parser.add_argument('--data', required=False,  

                        default='../../datas/2005-2006-day-001.txt',  

                        help='Specific data to be read in')  

  

    parser.add_argument('--fromdate', required=False, default=None,  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', required=False, default=None,  

                        help='Ending date in YYYY-MM-DD format')  

  

    parser.add_argument('--cash', required=False, action='store',  

                        type=float, default=50000,  
﻿                        help=('Cash to start with'))  

  

    parser.add_argument('--period1', required=False, action='store',  

                        type=int, default=10,  

                        help=('Fast moving average period'))  

  

    parser.add_argument('--period2', required=False, action='store',  

                        type=int, default=30,  

                        help=('Slow moving average period'))  

  

    parser.add_argument('--longonly', required=False,  

action='store_true',  

                        help=('Long only strategy'))  

  

    pgroup = parser.add_mutually_exclusive_group(required=False)  

    pgroup.add_argument('--slip_perc', required=False, default=None,  

                        type=float,  

                        help='Set the value for commission  

percentage')  

  

    pgroup.add_argument('--slip_fixed', required=False, default=None,  

                        type=float,  

                        help='Set the value for commission  

percentage')  

  

    parser.add_argument('--no-slip_match', required=False,  

action='store_true',  

                        help=('Match by capping slippage at bar  
﻿ends'))  

  

    parser.add_argument('--slip_out', required=False,  

action='store_true',  

                        help=('Disable capping and return non-real  

prices'))  

  

    parser.add_argument('--slip_open', required=False,  

action='store_true',  

                        help=('Slip even if match price is next  

open'))  

  

    # Plot options  

    parser.add_argument('--plot', '-p', nargs='?', required=False,  

                        metavar='kwargs', const=True,  

                        help=('Plot the read data applying any kwargs  

passed\n'  

                              '\n'  

                              'For example:\n'  

                              '\n'  

                              '  --plot style="candle" (to plot  

candles)\n'))  

  

    if pargs is not None:  

        return parser.parse_args(pargs)  

  

    return parser.parse_args()  

  
﻿  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: sratio\sratio.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import itertools  

import math  

import operator  

import sys  

  

  

if sys.version_info.major == 2:  

    map = itertools.imap  

  

  
﻿def average(x):  

    return math.fsum(x) / len(x)  

  

  

def variance(x):  

    avgx = average(x)  

    return list(map(lambda y: (y - avgx) ** 2, x))  

  

  

def standarddev(x):  

    return math.sqrt(average(variance(x)))  

  

  

def run(pargs=None):  

    args = parse_args(pargs)  

  

    returns = [args.ret1, args.ret2]  

    retfree = args.riskfreerate  

  

    print('returns is:', returns, ' - retfree is:', retfree)  

  

    # Directly from backtrader  

    retfree = itertools.repeat(retfree)  

    ret_free = map(operator.sub, returns, retfree)  # excess returns  

    ret_free_avg = average(list(ret_free))  # mean of the excess  

returns  

    print('returns excess mean:', ret_free_avg)  
﻿    retdev = standarddev(returns)  # standard deviation  

    print('returns standard deviation:', retdev)  

    ratio = ret_free_avg / retdev  # mean excess returns  / std  

deviation  

    print('Sharpe Ratio is:', ratio)  

  

  

def parse_args(pargs=None):  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='Sample Sharpe Ratio')  

  

    parser.add_argument('--ret1', required=False, action='store',  

                        type=float, default=0.023286,  

                        help=('Annual Return 1'))  

  

    parser.add_argument('--ret2', required=False, action='store',  

                        type=float, default=0.0257816485323,  

                        help=('Annual Return 2'))  

  

    parser.add_argument('--riskfreerate', required=False,  

action='store',  

                        type=float, default=0.01,  

                        help=('Risk free rate (decimal) for the Sharpe  

Ratio'))  

  

    if pargs is not None:  

        return parser.parse_args(pargs)  
﻿  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    run()  

  

====================================================================== 

==========  

# 文件: stop-trading\stop-loss-approaches.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  
﻿# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

  

import backtrader as bt  

  

  

class BaseStrategy(bt.Strategy):  

    params = dict(  

        fast_ma=10,  

        slow_ma=20,  

    )  

  

    def __init__(self):  

        # omitting a data implies self.datas[0] (aka self.data and  

self.data0)  

        fast_ma = bt.ind.EMA(period=self.p.fast_ma)  

        slow_ma = bt.ind.EMA(period=self.p.slow_ma)  
﻿        # our entry point  

        self.crossup = bt.ind.CrossUp(fast_ma, slow_ma)  

  

  

class ManualStopOrStopTrail(BaseStrategy):  

    params = dict(  

        stop_loss=0.02,  # price is 2% less than the entry point  

        trail=False,  

    )  

  

    def notify_order(self, order):  

        if not order.status == order.Completed:  

            return  # discard any other notification  

  

        if not self.position:  # we left the market  

            print('SELL@price: {:.2f}'.format(order.executed.price))  

            return  

  

        # We have entered the market  

        print('BUY @price: {:.2f}'.format(order.executed.price))  

  

        if not self.p.trail:  

            stop_price = order.executed.price * (1.0 -  

self.p.stop_loss)  

            self.sell(exectype=bt.Order.Stop, price=stop_price)  

        else:  

            self.sell(exectype=bt.Order.StopTrail,  
﻿trailamount=self.p.trail)  

  

    def next(self):  

        if not self.position and self.crossup > 0:  

            # not in the market and signal triggered  

            self.buy()  

  

  

class ManualStopOrStopTrailCheat(BaseStrategy):  

    params = dict(  

        stop_loss=0.02,  # price is 2% less than the entry point  

        trail=False,  

    )  

  

    def __init__(self):  

        super().__init__()  

        self.broker.set_coc(True)  

  

    def notify_order(self, order):  

        if not order.status == order.Completed:  

            return  # discard any other notification  

  

        if not self.position:  # we left the market  

            print('SELL@price: {:.2f}'.format(order.executed.price))  

            return  

  

        # We have entered the market  
﻿        print('BUY @price: {:.2f}'.format(order.executed.price))  

  

    def next(self):  

        if not self.position and self.crossup > 0:  

            # not in the market and signal triggered  

            self.buy()  

  

            if not self.p.trail:  

                stop_price = self.data.close[0] * (1.0 -  

self.p.stop_loss)  

                self.sell(exectype=bt.Order.Stop, price=stop_price)  

            else:  

                self.sell(exectype=bt.Order.StopTrail,  

                          trailamount=self.p.trail)  

  

  

class AutoStopOrStopTrail(BaseStrategy):  

    params = dict(  

        stop_loss=0.02,  # price is 2% less than the entry point  

        trail=False,  

        buy_limit=False,  

    )  

  

    buy_order = None  # default value for a potential buy_order  

  

    def notify_order(self, order):  

        if order.status == order.Cancelled:  
﻿            print('CANCEL@price: {:.2f} {}'.format(  

                order.executed.price, 'buy' if order.isbuy() else  

'sell'))  

            return  

  

        if not order.status == order.Completed:  

            return  # discard any other notification  

  

        if not self.position:  # we left the market  

            print('SELL@price: {:.2f}'.format(order.executed.price))  

            return  

  

        # We have entered the market  

        print('BUY @price: {:.2f}'.format(order.executed.price))  

  

    def next(self):  

        if not self.position and self.crossup > 0:  

            if self.buy_order:  # something was pending  

                self.cancel(self.buy_order)  

  

            # not in the market and signal triggered  

            if not self.p.buy_limit:  

                self.buy_order = self.buy(transmit=False)  

            else:  

                price = self.data.close[0] * (1.0 - self.p.buy_limit)  

  

                # transmit = False ... await child order before  
﻿transmission  

                self.buy_order = self.buy(price=price,  

exectype=bt.Order.Limit,  

                                          transmit=False)  

  

            # Setting parent=buy_order ... sends both together  

            if not self.p.trail:  

                stop_price = self.data.close[0] * (1.0 -  

self.p.stop_loss)  

                self.sell(exectype=bt.Order.Stop, price=stop_price,  

                          parent=self.buy_order)  

            else:  

                self.sell(exectype=bt.Order.StopTrail,  

                          trailamount=self.p.trail,  

                          parent=self.buy_order)  

  

  

APPROACHES = dict(  

    manual=ManualStopOrStopTrail,  

    manualcheat=ManualStopOrStopTrailCheat,  

    auto=AutoStopOrStopTrail,  

)  

  

  

def runstrat(args=None):  

    args = parse_args(args)  

  
﻿    cerebro = bt.Cerebro()  

  

    # Data feed kwargs  

    kwargs = dict()  

  

    # Parse from/to-date  

    dtfmt, tmfmt = '%Y-%m-%d', 'T%H:%M:%S'  

    for a, d in ((getattr(args, x), x) for x in ['fromdate',  

'todate']):  

        if a:  

            strpfmt = dtfmt + tmfmt * ('T' in a)  

            kwargs[d] = datetime.datetime.strptime(a, strpfmt)  

  

    data0 = bt.feeds.BacktraderCSVData(dataname=args.data0, **kwargs)  

    cerebro.adddata(data0)  

  

    # Broker  

    cerebro.broker = bt.brokers.BackBroker(**eval('dict(' +  

args.broker + ')'))  

  

    # Sizer  

    cerebro.addsizer(bt.sizers.FixedSize, **eval('dict(' + args.sizer  

+ ')'))  

  

    # Strategy  

    StClass = APPROACHES[args.approach]  

    cerebro.addstrategy(StClass, **eval('dict(' + args.strat + ')'))  

  
﻿    # Execute  

    cerebro.run(**eval('dict(' + args.cerebro + ')'))  

  

    if args.plot:  # Plot if requested to  

        cerebro.plot(**eval('dict(' + args.plot + ')'))  

  

  

def parse_args(pargs=None):  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description=(  

            'Stop-Loss Approaches'  

        )  

    )  

  

    parser.add_argument('--data0', default='../../datas/2005-2006-day- 

001.txt',  

                        required=False, help='Data to read in')  

  

    # Strategy to choose  

    parser.add_argument('approach', choices=APPROACHES.keys(),  

                        help='Stop approach to use')  

  

    # Defaults for dates  

    parser.add_argument('--fromdate', required=False, default='',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  
﻿  

    parser.add_argument('--todate', required=False, default='',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--cerebro', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--broker', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--sizer', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--strat', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--plot', required=False, default='',  

                        nargs='?', const='{}',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    return parser.parse_args(pargs)  

  
﻿  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: stoptrail\trail.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  
﻿# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

  

import backtrader as bt  

  

  

class St(bt.Strategy):  

    params = dict(  

        ma=bt.ind.SMA,  

        p1=10,  

        p2=30,  

        stoptype=bt.Order.StopTrail,  

        trailamount=0.0,  

        trailpercent=0.0,  

        limitoffset=0.0,  

    )  

  

    def __init__(self):  

        ma1, ma2 = self.p.ma(period=self.p.p1),  

self.p.ma(period=self.p.p2)  
﻿        self.crup = bt.ind.CrossUp(ma1, ma2)  

        self.order = None  

  

    def next(self):  

        if not self.position:  

            if self.crup:  

                o = self.buy()  

                self.order = None  

                print('*' * 50)  

  

        elif self.order is None:  

            if self.p.stoptype == bt.Order.StopTrailLimit:  

                price = self.data.close[0]  

                plimit = self.data.close[0] + self.p.limitoffset  

            else:  

                price = None  

                plimit = None  

  

            self.order = self.sell(exectype=self.p.stoptype,  

                                   price=price,  

                                   plimit=plimit,  

                                   trailamount=self.p.trailamount,  

                                   trailpercent=self.p.trailpercent)  

  

            if self.p.trailamount:  

                tcheck = self.data.close - self.p.trailamount  

            else:  
﻿                tcheck = self.data.close * (1.0 - self.p.trailpercent)  

            print(','.join(  

                map(str, [self.datetime.date(), self.data.close[0],  

                          self.order.created.price, tcheck])  

                )  

            )  

            print('-' * 10)  

        else:  

            if self.p.trailamount:  

                tcheck = self.data.close - self.p.trailamount  

            else:  

                tcheck = self.data.close * (1.0 - self.p.trailpercent)  

            print(','.join(  

                map(str, [self.datetime.date(), self.data.close[0],  

                          self.order.created.price, tcheck])  

                )  

            )  

  

  

def runstrat(args=None):  

    args = parse_args(args)  

  

    cerebro = bt.Cerebro()  

  

    # Data feed kwargs  

    kwargs = dict()  

  
﻿    # Parse from/to-date  

    dtfmt, tmfmt = '%Y-%m-%d', 'T%H:%M:%S'  

    for a, d in ((getattr(args, x), x) for x in ['fromdate',  

'todate']):  

        if a:  

            strpfmt = dtfmt + tmfmt * ('T' in a)  

            kwargs[d] = datetime.datetime.strptime(a, strpfmt)  

  

    # Data feed  

    data0 = bt.feeds.BacktraderCSVData(dataname=args.data0, **kwargs)  

    cerebro.adddata(data0)  

  

    # Broker  

    cerebro.broker = bt.brokers.BackBroker(**eval('dict(' +  

args.broker + ')'))  

  

    # Sizer  

    cerebro.addsizer(bt.sizers.FixedSize, **eval('dict(' + args.sizer  

+ ')'))  

  

    # Strategy  

    cerebro.addstrategy(St, **eval('dict(' + args.strat + ')'))  

  

    # Execute  

    cerebro.run(**eval('dict(' + args.cerebro + ')'))  

  

    if args.plot:  # Plot if requested to  

        cerebro.plot(**eval('dict(' + args.plot + ')'))  
﻿  

  

def parse_args(pargs=None):  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description=(  

            'StopTrail Sample'  

        )  

    )  

  

    parser.add_argument('--data0', default='../../datas/2005-2006-day- 

001.txt',  

                        required=False, help='Data to read in')  

  

    # Defaults for dates  

    parser.add_argument('--fromdate', required=False, default='',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--todate', required=False, default='',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--cerebro', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--broker', required=False, default='',  
﻿                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--sizer', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--strat', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--plot', required=False, default='',  

                        nargs='?', const='{}',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    return parser.parse_args(pargs)  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: strategy-selection\strategy-selection.txt  

====================================================================== 

==========  

  
﻿#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

  
﻿import backtrader as bt  

  

  

class St0(bt.SignalStrategy):  

    def __init__(self):  

        sma1, sma2 = bt.ind.SMA(period=10), bt.ind.SMA(period=30)  

        crossover = bt.ind.CrossOver(sma1, sma2)  

        self.signal_add(bt.SIGNAL_LONG, crossover)  

  

  

class St1(bt.SignalStrategy):  

    def __init__(self):  

        sma1 = bt.ind.SMA(period=10)  

        crossover = bt.ind.CrossOver(self.data.close, sma1)  

        self.signal_add(bt.SIGNAL_LONG, crossover)  

  

  

class StFetcher(object):  

    _STRATS = [St0, St1]  

  

    def __new__(cls, *args, **kwargs):  

        idx = kwargs.pop('idx')  

  

        obj = cls._STRATS[idx](*args, **kwargs)  

        return obj  

  

  
﻿def runstrat(pargs=None):  

    args = parse_args(pargs)  

  

    cerebro = bt.Cerebro()  

    data = bt.feeds.BacktraderCSVData(dataname=args.data)  

    cerebro.adddata(data)  

  

    cerebro.addanalyzer(bt.analyzers.Returns)  

    cerebro.optstrategy(StFetcher, idx=[0, 1])  

    results = cerebro.run(maxcpus=args.maxcpus,  

optreturn=args.optreturn)  

  

    strats = [x[0] for x in results]  # flatten the result  

    for i, strat in enumerate(strats):  

        rets = strat.analyzers.returns.get_analysis()  

        print('Strat {} Name {}:\n  - analyzer: {}\n'.format(  

            i, strat.__class__.__name__, rets))  

  

  

def parse_args(pargs=None):  

  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='Sample for strategy selection')  

  

    parser.add_argument('--data', required=False,  

                        default='../../datas/2005-2006-day-001.txt',  
﻿                        help='Data to be read in')  

  

    parser.add_argument('--maxcpus', required=False, action='store',  

                        default=None, type=int,  

                        help='Limit the numer of CPUs to use')  

  

    parser.add_argument('--optreturn', required=False,  

action='store_true',  

                        help='Return reduced/mocked strategy object')  

  

    return parser.parse_args(pargs)  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: talib\tablibsartest.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  
﻿#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

  

import backtrader as bt  

  

  

class TALibStrategy(bt.Strategy):  
﻿    def __init__(self):  

        bt.talib.SAR(self.data.high, self.data.low)  

        bt.ind.PSAR()  

  

  

def runstrat(args=None):  

    args = parse_args(args)  

  

    cerebro = bt.Cerebro()  

  

    dkwargs = dict()  

    if args.fromdate:  

        fromdate = datetime.datetime.strptime(args.fromdate,  

'%Y-%m-%d')  

        dkwargs['fromdate'] = fromdate  

  

    if args.todate:  

        todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

        dkwargs['todate'] = todate  

  

    data0 = bt.feeds.YahooFinanceCSVData(dataname=args.data0,  

**dkwargs)  

    cerebro.adddata(data0)  

  

    cerebro.addstrategy(TALibStrategy)  

    cerebro.run(runonce=not args.use_next, stdstats=False)  

    if args.plot:  
﻿        pkwargs = dict(style='candle')  

        if args.plot is not True:  # evals to True but is not True  

            npkwargs = eval('dict(' + args.plot + ')')  # args were  

passed  

            pkwargs.update(npkwargs)  

  

        cerebro.plot(**pkwargs)  

  

  

def parse_args(pargs=None):  

  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='Sample for sizer')  

  

    parser.add_argument('--data0', required=False,  

                        default='../../datas/yhoo-1996-2015.txt',  

                        help='Data to be read in')  

  

    parser.add_argument('--fromdate', required=False,  

                        default='2005-01-01',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', required=False,  

                        default='2006-12-31',  

                        help='Ending date in YYYY-MM-DD format')  

  
﻿    parser.add_argument('--use-next', required=False,  

action='store_true',  

                        help=('Use next (step by step) '  

                              'instead of once (batch)'))  

  

    # Plot options  

    parser.add_argument('--plot', '-p', nargs='?', required=False,  

                        metavar='kwargs', const=True,  

                        help=('Plot the read data applying any kwargs  

passed\n'  

                              '\n'  

                              'For example (escape the quotes if  

needed):\n'  

                              '\n'  

                              '  --plot style="candle" (to plot  

candles)\n'))  

  

    if pargs is not None:  

        return parser.parse_args(pargs)  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  
﻿# 文件: talib\talibtest.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  
﻿                        unicode_literals)  

  

import argparse  

import datetime  

  

import backtrader as bt  

  

  

class TALibStrategy(bt.Strategy):  

    params = (('ind', 'sma'), ('doji', True),)  

  

    INDS = ['sma', 'ema', 'stoc', 'rsi', 'macd', 'bollinger', 'aroon',  

            'ultimate', 'trix', 'kama', 'adxr', 'dema', 'ppo', 'tema',  

            'roc', 'williamsr']  

  

    def __init__(self):  

        if self.p.doji:  

            bt.talib.CDLDOJI(self.data.open, self.data.high,  

                             self.data.low, self.data.close)  

  

        if self.p.ind == 'sma':  

            bt.talib.SMA(self.data.close, timeperiod=25,  

plotname='TA_SMA')  

            bt.indicators.SMA(self.data, period=25)  

        elif self.p.ind == 'ema':  

            bt.talib.EMA(timeperiod=25, plotname='TA_SMA')  

            bt.indicators.EMA(period=25)  
﻿        elif self.p.ind == 'stoc':  

            bt.talib.STOCH(self.data.high, self.data.low,  

self.data.close,  

                           fastk_period=14, slowk_period=3,  

slowd_period=3,  

                           plotname='TA_STOCH')  

  

            bt.indicators.Stochastic(self.data)  

  

        elif self.p.ind == 'macd':  

            bt.talib.MACD(self.data, plotname='TA_MACD')  

            bt.indicators.MACD(self.data)  

            bt.indicators.MACDHisto(self.data)  

        elif self.p.ind == 'bollinger':  

            bt.talib.BBANDS(self.data, timeperiod=25,  

                            plotname='TA_BBANDS')  

            bt.indicators.BollingerBands(self.data, period=25)  

  

        elif self.p.ind == 'rsi':  

            bt.talib.RSI(self.data, plotname='TA_RSI')  

            bt.indicators.RSI(self.data)  

  

        elif self.p.ind == 'aroon':  

            bt.talib.AROON(self.data.high, self.data.low,  

plotname='TA_AROON')  

            bt.indicators.AroonIndicator(self.data)  

  

        elif self.p.ind == 'ultimate':  
﻿            bt.talib.ULTOSC(self.data.high, self.data.low,  

self.data.close,  

                            plotname='TA_ULTOSC')  

            bt.indicators.UltimateOscillator(self.data)  

  

        elif self.p.ind == 'trix':  

            bt.talib.TRIX(self.data, timeperiod=25,   

plotname='TA_TRIX')  

            bt.indicators.Trix(self.data, period=25)  

  

        elif self.p.ind == 'adxr':  

            bt.talib.ADXR(self.data.high, self.data.low,  

self.data.close,  

                          plotname='TA_ADXR')  

            bt.indicators.ADXR(self.data)  

  

        elif self.p.ind == 'kama':  

            bt.talib.KAMA(self.data, timeperiod=25,  

plotname='TA_KAMA')  

            bt.indicators.KAMA(self.data, period=25)  

  

        elif self.p.ind == 'dema':  

            bt.talib.DEMA(self.data, timeperiod=25,  

plotname='TA_DEMA')  

            bt.indicators.DEMA(self.data, period=25)  

  

        elif self.p.ind == 'ppo':  

            bt.talib.PPO(self.data, plotname='TA_PPO')  
﻿            bt.indicators.PPO(self.data, _movav=bt.indicators.SMA)  

  

        elif self.p.ind == 'tema':  

            bt.talib.TEMA(self.data, timeperiod=25,  

plotname='TA_TEMA')  

            bt.indicators.TEMA(self.data, period=25)  

  

        elif self.p.ind == 'roc':  

            bt.talib.ROC(self.data, timeperiod=12, plotname='TA_ROC')  

            bt.talib.ROCP(self.data, timeperiod=12,  

plotname='TA_ROCP')  

            bt.talib.ROCR(self.data, timeperiod=12,  

plotname='TA_ROCR')  

            bt.talib.ROCR100(self.data, timeperiod=12,  

plotname='TA_ROCR100')  

            bt.indicators.ROC(self.data, period=12)  

            bt.indicators.Momentum(self.data, period=12)  

            bt.indicators.MomentumOscillator(self.data, period=12)  

  

        elif self.p.ind == 'williamsr':  

            bt.talib.WILLR(self.data.high, self.data.low,  

self.data.close,  

                           plotname='TA_WILLR')  

            bt.indicators.WilliamsR(self.data)  

  

  

def runstrat(args=None):  

    args = parse_args(args)  
﻿  

    cerebro = bt.Cerebro()  

  

    dkwargs = dict()  

    if args.fromdate:  

        fromdate = datetime.datetime.strptime(args.fromdate,  

'%Y-%m-%d')  

        dkwargs['fromdate'] = fromdate  

  

    if args.todate:  

        todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

        dkwargs['todate'] = todate  

  

    data0 = bt.feeds.YahooFinanceCSVData(dataname=args.data0,  

**dkwargs)  

    cerebro.adddata(data0)  

  

    cerebro.addstrategy(TALibStrategy, ind=args.ind, doji=not  

args.no_doji)  

  

    cerebro.run(runcone=not args.use_next, stdstats=False)  

    if args.plot:  

        pkwargs = dict(style='candle')  

        if args.plot is not True:  # evals to True but is not True  

            npkwargs = eval('dict(' + args.plot + ')')  # args were  

passed  

            pkwargs.update(npkwargs)  

  
﻿        cerebro.plot(**pkwargs)  

  

  

def parse_args(pargs=None):  

  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='Sample for sizer')  

  

    parser.add_argument('--data0', required=False,  

                        default='../../datas/yhoo-1996-2015.txt',  

                        help='Data to be read in')  

  

    parser.add_argument('--fromdate', required=False,  

                        default='2005-01-01',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', required=False,  

                        default='2006-12-31',  

                        help='Ending date in YYYY-MM-DD format')  

  

    parser.add_argument('--ind', required=False, action='store',  

                        default=TALibStrategy.INDS[0],  

                        choices=TALibStrategy.INDS,  

                        help=('Which indicator pair to show  

together'))  

  
﻿    parser.add_argument('--no-doji', required=False,  

action='store_true',  

                        help=('Remove Doji CandleStick pattern  

checker'))  

  

    parser.add_argument('--use-next', required=False,  

action='store_true',  

                        help=('Use next (step by step) '  

                              'instead of once (batch)'))  

  

    # Plot options  

    parser.add_argument('--plot', '-p', nargs='?', required=False,  

                        metavar='kwargs', const=True,  

                        help=('Plot the read data applying any kwargs  

passed\n'  

                              '\n'  

                              'For example (escape the quotes if  

needed):\n'  

                              '\n'  

                              '  --plot style="candle" (to plot  

candles)\n'))  

  

    if pargs is not None:  

        return parser.parse_args(pargs)  

  

    return parser.parse_args()  

  

  
﻿if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: timers\scheduled-min.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  
﻿<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

  

import backtrader as bt  

  

  

class St(bt.Strategy):  

    params = dict(  

        when=bt.timer.SESSION_START,  

        timer=True,  

        cheat=False,  

        offset=datetime.timedelta(),  

        repeat=datetime.timedelta(),  

        weekdays=[],  

        weekcarry=False,  

        monthdays=[],  

        monthcarry=True,  

    )  

  

    def __init__(self):  
﻿        bt.ind.SMA()  

        if self.p.timer:  

            self.add_timer(  

                when=self.p.when,  

                offset=self.p.offset,  

                repeat=self.p.repeat,  

                weekdays=self.p.weekdays,  

                weekcarry=self.p.weekcarry,  

                monthdays=self.p.monthdays,  

                monthcarry=self.p.monthcarry,  

                # tzdata=self.data0,  

            )  

        if self.p.cheat:  

            self.add_timer(  

                when=self.p.when,  

                offset=self.p.offset,  

                repeat=self.p.repeat,  

                weekdays=self.p.weekdays,  

                weekcarry=self.p.weekcarry,  

                monthdays=self.p.monthdays,  

                monthcarry=self.p.monthcarry,  

                tzdata=self.data0,  

                cheat=True,  

            )  

  

        self.order = None  

  
﻿    def prenext(self):  

        self.next()  

  

    def next(self):  

        _, isowk, isowkday = self.datetime.date().isocalendar()  

        txt = '{}, {}, Week {}, Day {}, O {}, H {}, L {}, C  

{}'.format(  

            len(self), self.datetime.datetime(),  

            isowk, isowkday,  

            self.data.open[0], self.data.high[0],  

            self.data.low[0], self.data.close[0])  

  

        print(txt)  

  

    def notify_timer(self, timer, when, *args, **kwargs):  

        print('strategy notify_timer with tid {}, when {} cheat {}'.  

              format(timer.p.tid, when, timer.p.cheat))  

  

        if self.order is None and timer.params.cheat:  

            print('--  {} Create buy order'.format(  

                self.data.datetime.datetime()))  

            self.order = self.buy()  

  

    def notify_order(self, order):  

        if order.status == order.Completed:  

            print('--  {} Buy Exec @ {}'.format(  

                self.data.datetime.datetime(), order.executed.price))  
﻿  

  

def runstrat(args=None):  

    args = parse_args(args)  

    cerebro = bt.Cerebro()  

  

    # Data feed kwargs  

    kwargs = dict(  

        timeframe=bt.TimeFrame.Minutes,  

        compression=5,  

        sessionstart=datetime.time(9, 0),  

        sessionend=datetime.time(17, 30),  

    )  

  

    # Parse from/to-date  

    dtfmt, tmfmt = '%Y-%m-%d', 'T%H:%M:%S'  

    for a, d in ((getattr(args, x), x) for x in ['fromdate',  

'todate']):  

        if a:  

            strpfmt = dtfmt + tmfmt * ('T' in a)  

            kwargs[d] = datetime.datetime.strptime(a, strpfmt)  

  

    # Data feed  

    data0 = bt.feeds.BacktraderCSVData(dataname=args.data0, **kwargs)  

    cerebro.adddata(data0)  

  

    # Broker  
﻿    cerebro.broker = bt.brokers.BackBroker(**eval('dict(' +  

args.broker + ')'))  

  

    # Sizer  

    cerebro.addsizer(bt.sizers.FixedSize, **eval('dict(' + args.sizer  

+ ')'))  

  

    # Strategy  

    cerebro.addstrategy(St, **eval('dict(' + args.strat + ')'))  

  

    # Execute  

    cerebro.run(**eval('dict(' + args.cerebro + ')'))  

  

    if args.plot:  # Plot if requested to  

        cerebro.plot(**eval('dict(' + args.plot + ')'))  

  

  

def parse_args(pargs=None):  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description=(  

            'Timer Test Intraday'  

        )  

    )  

  

    parser.add_argument('--data0', default='../../datas/2006-min- 

005.txt',  

                        required=False, help='Data to read in')  
﻿  

    # Defaults for dates  

    parser.add_argument('--fromdate', required=False, default='',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--todate', required=False, default='',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--cerebro', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--broker', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--sizer', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--strat', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--plot', required=False, default='',  

                        nargs='?', const='{}',  
﻿                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    return parser.parse_args(pargs)  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: timers\scheduled.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  
﻿# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

  

import backtrader as bt  

  

  

class St(bt.Strategy):  

    params = dict(  

        when=bt.timer.SESSION_START,  

        timer=True,  

        cheat=False,  

        offset=datetime.timedelta(),  

        repeat=datetime.timedelta(),  

        weekdays=[],  
﻿    )  

  

    def __init__(self):  

        bt.ind.SMA()  

        if self.p.timer:  

            self.add_timer(  

                when=self.p.when,  

                offset=self.p.offset,  

                repeat=self.p.repeat,  

                weekdays=self.p.weekdays,  

            )  

        if self.p.cheat:  

            self.add_timer(  

                when=self.p.when,  

                offset=self.p.offset,  

                repeat=self.p.repeat,  

                cheat=True,  

            )  

  

        self.order = None  

  

    def prenext(self):  

        self.next()  

  

    def next(self):  

        _, isowk, isowkday = self.datetime.date().isocalendar()  

        txt = '{}, {}, Week {}, Day {}, O {}, H {}, L {}, C  
﻿{}'.format(  

            len(self), self.datetime.datetime(),  

            isowk, isowkday,  

            self.data.open[0], self.data.high[0],  

            self.data.low[0], self.data.close[0])  

  

        print(txt)  

  

    def notify_timer(self, timer, when, *args, **kwargs):  

        print('strategy notify_timer with tid {}, when {} cheat {}'.  

              format(timer.p.tid, when, timer.p.cheat))  

  

        if self.order is None and timer.p.cheat:  

            print('--  {} Create buy  

order'.format(self.data.datetime.date()))  

            self.order = self.buy()  

  

    def notify_order(self, order):  

        if order.status == order.Completed:  

            print('--  {} Buy Exec @ {}'.format(  

                self.data.datetime.date(), order.executed.price))  

  

  

def runstrat(args=None):  

    args = parse_args(args)  

  

    cerebro = bt.Cerebro()  
﻿  

    # Data feed kwargs  

    kwargs = dict(  

        timeframe=bt.TimeFrame.Days,  

        compression=1,  

        sessionstart=datetime.time(9, 0),  

        sessionend=datetime.time(17, 30),  

    )  

  

    # Parse from/to-date  

    dtfmt, tmfmt = '%Y-%m-%d', 'T%H:%M:%S'  

    for a, d in ((getattr(args, x), x) for x in ['fromdate',  

'todate']):  

        if a:  

            strpfmt = dtfmt + tmfmt * ('T' in a)  

            kwargs[d] = datetime.datetime.strptime(a, strpfmt)  

  

    # Data feed  

    data0 = bt.feeds.BacktraderCSVData(dataname=args.data0, **kwargs)  

    cerebro.adddata(data0)  

  

    # Broker  

    cerebro.broker = bt.brokers.BackBroker(**eval('dict(' +  

args.broker + ')'))  

  

    # Sizer  

    cerebro.addsizer(bt.sizers.FixedSize, **eval('dict(' + args.sizer  

+ ')'))  
﻿  

    # Strategy  

    cerebro.addstrategy(St, **eval('dict(' + args.strat + ')'))  

  

    # Execute  

    cerebro.run(**eval('dict(' + args.cerebro + ')'))  

  

    if args.plot:  # Plot if requested to  

        cerebro.plot(**eval('dict(' + args.plot + ')'))  

  

  

def parse_args(pargs=None):  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description=(  

            'Sample Skeleton'  

        )  

    )  

  

    parser.add_argument('--data0', default='../../datas/2005-2006-day- 

001.txt',  

                        required=False, help='Data to read in')  

  

    # Defaults for dates  

    parser.add_argument('--fromdate', required=False, default='',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  
﻿  

    parser.add_argument('--todate', required=False, default='',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--cerebro', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--broker', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--sizer', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--strat', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--plot', required=False, default='',  

                        nargs='?', const='{}',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    return parser.parse_args(pargs)  

  
﻿  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: tradingcalendar\tcal-intra.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  
﻿# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

  

import backtrader as bt  

  

  

class NYSE_2016(bt.TradingCalendar):  

    params = dict(  

        holidays=[  

            datetime.date(2016, 1, 1),  

            datetime.date(2016, 1, 18),  

            datetime.date(2016, 2, 15),  

            datetime.date(2016, 3, 25),  

            datetime.date(2016, 5, 30),  

            datetime.date(2016, 7, 4),  

            datetime.date(2016, 9, 5),  

            datetime.date(2016, 11, 24),  

            datetime.date(2016, 12, 26),  

        ],  
﻿        earlydays=[  

             (datetime.date(2016, 11, 25),  

             datetime.time(9, 30), datetime.time(13, 1))  

        ],  

        open=datetime.time(9, 30),  

        close=datetime.time(16, 0),  

    )  

  

  

class St(bt.Strategy):  

    params = dict(  

    )  

  

    def __init__(self):  

        pass  

  

    def prenext(self):  

        self.next()  

  

    def next(self):  

        print('Strategy len {} datetime {}'.format(  

            len(self), self.datetime.datetime()), end=' ')  

  

        print('Data0 len {} datetime {}'.format(  

            len(self.data0), self.data0.datetime.datetime()), end=' ')  

  

        if len(self.data1):  
﻿            print('Data1 len {} datetime {}'.format(  

                len(self.data1), self.data1.datetime.datetime()))  

        else:  

            print()  

  

  

def runstrat(args=None):  

    args = parse_args(args)  

  

    cerebro = bt.Cerebro()  

  

    # Data feed kwargs  

    # kwargs = dict(tz='US/Eastern')  

    # import pytz  

    # tz = tzinput = pytz.timezone('Europe/Berlin')  

    tzinput = 'Europe/Berlin'  

    # tz = tzinput  

    tz = 'US/Eastern'  

    kwargs = dict(tzinput=tzinput, tz=tz)  

  

    # Parse from/to-date  

    dtfmt, tmfmt = '%Y-%m-%d', 'T%H:%M:%S'  

    for a, d in ((getattr(args, x), x) for x in ['fromdate',  

'todate']):  

        if a:  

            strpfmt = dtfmt + tmfmt * ('T' in a)  

            kwargs[d] = datetime.datetime.strptime(a, strpfmt)  
﻿  

    # Data feed  

    data0 = bt.feeds.BacktraderCSVData(dataname=args.data0, **kwargs)  

    cerebro.adddata(data0)  

  

    d1 = cerebro.resampledata(data0,  

                              timeframe=getattr(bt.TimeFrame,  

args.timeframe))  

    # d1.plotinfo.plotmaster = data0  

    # d1.plotinfo.sameaxis = False  

  

    if args.pandascal:  

        cerebro.addcalendar(args.pandascal)  

    elif args.owncal:  

        cerebro.addcalendar(NYSE_2016())  # or NYSE_2016() to pass an  

instance  

  

    # Broker  

    cerebro.broker = bt.brokers.BackBroker(**eval('dict(' +  

args.broker + ')'))  

  

    # Sizer  

    cerebro.addsizer(bt.sizers.FixedSize, **eval('dict(' + args.sizer  

+ ')'))  

  

    # Strategy  

    cerebro.addstrategy(St, **eval('dict(' + args.strat + ')'))  

  
﻿    # Execute  

    cerebro.run(**eval('dict(' + args.cerebro + ')'))  

  

    if args.plot:  # Plot if requested to  

        cerebro.plot(**eval('dict(' + args.plot + ')'))  

  

  

def parse_args(pargs=None):  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description=(  

            'Trading Calendar Sample'  

        )  

    )  

  

    parser.add_argument('--data0', default='yhoo-2016-11.csv',  

                        required=False, help='Data to read in')  

  

    # Defaults for dates  

    parser.add_argument('--fromdate', required=False, default='2016- 

01-01',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--todate', required=False, default='2016-12- 

31',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  
﻿  

    parser.add_argument('--cerebro', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--broker', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--sizer', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--strat', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--plot', required=False, default='',  

                        nargs='?', const='{}',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    pgroup = parser.add_mutually_exclusive_group(required=False)  

    pgroup.add_argument('--pandascal', required=False, action='store',  

                        default='', help='Name of trading calendar to  

use')  

  

    pgroup.add_argument('--owncal', required=False,  

action='store_true',  
﻿                        help='Apply custom NYSE 2016 calendar')  

  

    parser.add_argument('--timeframe', required=False, action='store',  

                        default='Days', choices=['Days'],  

                        help='Timeframe to resample to')  

  

    return parser.parse_args(pargs)  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: tradingcalendar\tcal.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  
﻿# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

  

import backtrader as bt  

  

  

class NYSE_2016(bt.TradingCalendar):  

    params = dict(  

        holidays=[  

            datetime.date(2016, 1, 1),  

            datetime.date(2016, 1, 18),  
﻿            datetime.date(2016, 2, 15),  

            datetime.date(2016, 3, 25),  

            datetime.date(2016, 5, 30),  

            datetime.date(2016, 7, 4),  

            datetime.date(2016, 9, 5),  

            datetime.date(2016, 11, 24),  

            datetime.date(2016, 12, 26),  

        ]  

    )  

  

  

class St(bt.Strategy):  

    params = dict(  

    )  

  

    def __init__(self):  

        pass  

  

    def start(self):  

        self.t0 = datetime.datetime.utcnow()  

  

    def stop(self):  

        t1 = datetime.datetime.utcnow()  

        print('Duration:', t1 - self.t0)  

  

    def prenext(self):  

        self.next()  
﻿  

    def next(self):  

        print('Strategy len {} datetime {}'.format(  

            len(self), self.datetime.date()), end=' ')  

  

        print('Data0 len {} datetime {}'.format(  

            len(self.data0), self.data0.datetime.date()), end=' ')  

  

        if len(self.data1):  

            print('Data1 len {} datetime {}'.format(  

                len(self.data1), self.data1.datetime.date()))  

        else:  

            print()  

  

  

def runstrat(args=None):  

    args = parse_args(args)  

  

    cerebro = bt.Cerebro()  

  

    # Data feed kwargs  

    kwargs = dict()  

  

    # Parse from/to-date  

    dtfmt, tmfmt = '%Y-%m-%d', 'T%H:%M:%S'  

    for a, d in ((getattr(args, x), x) for x in ['fromdate',  

'todate']):  
﻿        if a:  

            strpfmt = dtfmt + tmfmt * ('T' in a)  

            kwargs[d] = datetime.datetime.strptime(a, strpfmt)  

  

    YahooData = bt.feeds.YahooFinanceData  

    if args.offline:  

        YahooData = bt.feeds.YahooFinanceCSVData  # change to read  

file  

  

    # Data feed  

    data0 = YahooData(dataname=args.data0, **kwargs)  

    cerebro.adddata(data0)  

  

    d1 = cerebro.resampledata(data0,  

                              timeframe=getattr(bt.TimeFrame,  

args.timeframe))  

    d1.plotinfo.plotmaster = data0  

    d1.plotinfo.sameaxis = True  

  

    if args.pandascal:  

        cerebro.addcalendar(args.pandascal)  

    elif args.owncal:  

        cerebro.addcalendar(NYSE_2016)  

  

    # Broker  

    cerebro.broker = bt.brokers.BackBroker(**eval('dict(' +  

args.broker + ')'))  

  
﻿    # Sizer  

    cerebro.addsizer(bt.sizers.FixedSize, **eval('dict(' + args.sizer  

+ ')'))  

  

    # Strategy  

    cerebro.addstrategy(St, **eval('dict(' + args.strat + ')'))  

  

    # Execute  

    cerebro.run(**eval('dict(' + args.cerebro + ')'))  

  

    if args.plot:  # Plot if requested to  

        cerebro.plot(**eval('dict(' + args.plot + ')'))  

  

  

def parse_args(pargs=None):  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description=(  

            'Trading Calendar Sample'  

        )  

    )  

  

    parser.add_argument('--data0', default='YHOO',  

                        required=False, help='Data to read in')  

  

    parser.add_argument('--offline', required=False,  

action='store_true',  
﻿                        help='Read from disk with same name as  

ticker')  

  

    # Defaults for dates  

    parser.add_argument('--fromdate', required=False, default='2016- 

01-01',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--todate', required=False, default='2016-12- 

31',  

                        help='Date[time] in YYYY-MM-DD[THH:MM:SS]  

format')  

  

    parser.add_argument('--cerebro', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--broker', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--sizer', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    parser.add_argument('--strat', required=False, default='',  

                        metavar='kwargs', help='kwargs in key=value  

format')  
﻿  

    parser.add_argument('--plot', required=False, default='',  

                        nargs='?', const='{}',  

                        metavar='kwargs', help='kwargs in key=value  

format')  

  

    pgroup = parser.add_mutually_exclusive_group(required=False)  

    pgroup.add_argument('--pandascal', required=False, action='store',  

                        default='', help='Name of trading calendar to  

use')  

  

    pgroup.add_argument('--owncal', required=False,  

action='store_true',  

                        help='Apply custom NYSE 2016 calendar')  

  

    parser.add_argument('--timeframe', required=False, action='store',  

                        default='Weeks', choices=['Weeks', 'Months',  

'Years'],  

                        help='Timeframe to resample to')  

  

    return parser.parse_args(pargs)  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  
﻿# 文件: vctest\vctest.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  
﻿                        unicode_literals)  

  

import argparse  

import datetime  

  

# The above could be sent to an independent module  

import backtrader as bt  

from backtrader.utils import flushfile  # win32 quick stdout flushing  

from backtrader.utils.py3 import string_types  

  

  

class TestStrategy(bt.Strategy):  

    params = dict(  

        smaperiod=5,  

        trade=False,  

        stake=10,  

        exectype=bt.Order.Market,  

        stopafter=0,  

        valid=None,  

        cancel=0,  

        donotsell=False,  

        price=None,  

        pstoplimit=None,  

    )  

  

    def __init__(self):  

        # To control operation entries  
﻿        self.orderid = list()  

        self.order = None  

  

        self.counttostop = 0  

        self.datastatus = 0  

  

        # Create SMA on 2nd data  

        self.sma = bt.indicators.MovAv.SMA(self.data,  

period=self.p.smaperiod)  

  

        print('--------------------------------------------------')  

        print('Strategy Created')  

        print('--------------------------------------------------')  

  

    def notify_data(self, data, status, *args, **kwargs):  

        print('*' * 5, 'DATA NOTIF:', data._getstatusname(status),  

*args)  

        if status == data.LIVE:  

            self.counttostop = self.p.stopafter  

            self.datastatus = 1  

  

    def notify_store(self, msg, *args, **kwargs):  

        print('*' * 5, 'STORE NOTIF:', msg)  

  

    def notify_order(self, order):  

        if order.status in [order.Completed, order.Cancelled,  

order.Rejected]:  

            self.order = None  
﻿  

        print('-' * 50, 'ORDER BEGIN', datetime.datetime.now())  

        print(order)  

        print('-' * 50, 'ORDER END')  

  

    def notify_trade(self, trade):  

        print('-' * 50, 'TRADE BEGIN', datetime.datetime.now())  

        print(trade)  

        print('-' * 50, 'TRADE END')  

  

    def prenext(self):  

        self.next(frompre=True)  

  

    def next(self, frompre=False):  

        txt = list()  

        txt.append('%04d' % len(self))  

        dtfmt = '%Y-%m-%dT%H:%M:%S.%f'  

        txt.append('%s' %  

self.data.datetime.datetime(0).strftime(dtfmt))  

        txt.append('{}'.format(self.data.open[0]))  

        txt.append('{}'.format(self.data.high[0]))  

        txt.append('{}'.format(self.data.low[0]))  

        txt.append('{}'.format(self.data.close[0]))  

        txt.append('{}'.format(self.data.volume[0]))  

        txt.append('{}'.format(self.data.openinterest[0]))  

        txt.append('{}'.format(self.sma[0]))  

        print(', '.join(txt))  
﻿  

        if len(self.datas) > 1:  

            txt = list()  

            txt.append('%04d' % len(self))  

            dtfmt = '%Y-%m-%dT%H:%M:%S.%f'  

            txt.append('%s' %  

self.data1.datetime.datetime(0).strftime(dtfmt))  

            txt.append('{}'.format(self.data1.open[0]))  

            txt.append('{}'.format(self.data1.high[0]))  

            txt.append('{}'.format(self.data1.low[0]))  

            txt.append('{}'.format(self.data1.close[0]))  

            txt.append('{}'.format(self.data1.volume[0]))  

            txt.append('{}'.format(self.data1.openinterest[0]))  

            txt.append('{}'.format(float('NaN')))  

            print(', '.join(txt))  

  

        if self.counttostop:  # stop after x live lines  

            self.counttostop -= 1  

            if not self.counttostop:  

                self.env.runstop()  

                return  

  

        if not self.p.trade:  

            return  

  

        # if True and len(self.orderid) < 1:  

        if self.datastatus and not self.position and len(self.orderid)  
﻿< 1:  

            self.order = self.buy(size=self.p.stake,  

                                  exectype=self.p.exectype,  

                                  price=self.p.price,  

                                  plimit=self.p.pstoplimit,  

                                  valid=self.p.valid)  

  

            self.orderid.append(self.order)  

        elif self.position.size > 0 and not self.p.donotsell:  

            if self.order is None:  

                size = self.p.stake // 2  

                if not size:  

                    size = self.position.size  # use the remaining  

                self.order = self.sell(size=size,  

exectype=bt.Order.Market)  

  

        elif self.order is not None and self.p.cancel:  

            if self.datastatus > self.p.cancel:  

                self.cancel(self.order)  

  

        if self.datastatus:  

            self.datastatus += 1  

  

    def start(self):  

        header = ['Datetime', 'Open', 'High', 'Low', 'Close',  

'Volume',  

                  'OpenInterest', 'SMA']  
﻿        print(', '.join(header))  

  

        self.done = False  

  

  

def runstrategy():  

    args = parse_args()  

  

    # Create a cerebro  

    cerebro = bt.Cerebro()  

  

    storekwargs = dict()  

  

    if not args.nostore:  

        vcstore = bt.stores.VCStore(**storekwargs)  

  

    if args.broker:  

        brokerargs = dict(account=args.account, **storekwargs)  

        if not args.nostore:  

            broker = vcstore.getbroker(**brokerargs)  

        else:  

            broker = bt.brokers.VCBroker(**brokerargs)  

  

        cerebro.setbroker(broker)  

  

    timeframe = bt.TimeFrame.TFrame(args.timeframe)  

    if args.resample or args.replay:  
﻿        datatf = bt.TimeFrame.Ticks  

        datacomp = 1  

    else:  

        datatf = timeframe  

        datacomp = args.compression  

  

    fromdate = None  

    if args.fromdate:  

        dtformat = '%Y-%m-%d' + ('T%H:%M:%S' * ('T' in args.fromdate))  

        fromdate = datetime.datetime.strptime(args.fromdate, dtformat)  

  

    todate = None  

    if args.todate:  

        dtformat = '%Y-%m-%d' + ('T%H:%M:%S' * ('T' in args.todate))  

        todate = datetime.datetime.strptime(args.todate, dtformat)  

  

    VCDataFactory = vcstore.getdata if not args.nostore else  

bt.feeds.VCData  

  

    datakwargs = dict(  

        timeframe=datatf, compression=datacomp,  

        fromdate=fromdate, todate=todate,  

        historical=args.historical,  

        qcheck=args.qcheck,  

        tz=args.timezone  

    )  

  
﻿    if args.nostore and not args.broker:   # neither store nor broker  

        datakwargs.update(storekwargs)  # pass the store args over the  

data  

  

    data0 = VCDataFactory(dataname=args.data0,  

tradename=args.tradename,  

                          **datakwargs)  

  

    data1 = None  

    if args.data1 is not None:  

        data1 = VCDataFactory(dataname=args.data1, **datakwargs)  

  

    rekwargs = dict(  

        timeframe=timeframe, compression=args.compression,  

        bar2edge=not args.no_bar2edge,  

        adjbartime=not args.no_adjbartime,  

        rightedge=not args.no_rightedge,  

    )  

  

    if args.replay:  

        cerebro.replaydata(data0, **rekwargs)  

  

        if data1 is not None:  

            cerebro.replaydata(data1, **rekwargs)  

  

    elif args.resample:  

        cerebro.resampledata(data0, **rekwargs)  
﻿  

        if data1 is not None:  

            cerebro.resampledata(data1, **rekwargs)  

  

    else:  

        cerebro.adddata(data0)  

        if data1 is not None:  

            cerebro.adddata(data1)  

  

    if args.valid is None:  

        valid = None  

    else:  

        try:  

            valid = float(args.valid)  

        except:  

            dtformat = '%Y-%m-%d' + ('T%H:%M:%S' * ('T' in  

args.valid))  

            valid = datetime.datetime.strptime(args.valid, dtformat)  

        else:  

            valid = datetime.timedelta(seconds=args.valid)  

  

    # Add the strategy  

    cerebro.addstrategy(TestStrategy,  

                        smaperiod=args.smaperiod,  

                        trade=args.trade,  

                        exectype=bt.Order.ExecType(args.exectype),  

                        stake=args.stake,  
﻿                        stopafter=args.stopafter,  

                        valid=valid,  

                        cancel=args.cancel,  

                        donotsell=args.donotsell,  

                        price=args.price,  

                        pstoplimit=args.pstoplimit)  

  

    # Live data ... avoid long data accumulation by switching to  

"exactbars"  

    cerebro.run(exactbars=args.exactbars)  

  

    if args.plot and args.exactbars < 1:  # plot if possible  

        cerebro.plot()  

  

  

def parse_args():  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='Test Visual Chart 6 integration')  

  

    parser.add_argument('--exactbars', default=1, type=int,  

                        required=False, action='store',  

                        help='exactbars level, use 0/-1/-2 to enable  

plotting')  

  

    parser.add_argument('--plot',  

                        required=False, action='store_true',  
﻿                        help='Plot if possible')  

  

    parser.add_argument('--stopafter', default=0, type=int,  

                        required=False, action='store',  

                        help='Stop after x lines of LIVE data')  

  

    parser.add_argument('--nostore',  

                        required=False, action='store_true',  

                        help='Do not Use the store pattern')  

  

    parser.add_argument('--qcheck', default=0.5, type=float,  

                        required=False, action='store',  

                        help=('Timeout for periodic '  

                              'notification/resampling/replaying  

check'))  

  

    parser.add_argument('--no-timeoffset',  

                        required=False, action='store_true',  

                        help=('Do not Use TWS/System time offset for  

non '  

                              'timestamped prices and to align  

resampling'))  

  

    parser.add_argument('--data0', default=None,  

                        required=True, action='store',  

                        help='data 0 into the system')  

  

    parser.add_argument('--tradename', default=None,  
﻿                        required=False, action='store',  

                        help='Actual Trading Name of the asset')  

  

    parser.add_argument('--data1', default=None,  

                        required=False, action='store',  

                        help='data 1 into the system')  

  

    parser.add_argument('--timezone', default=None,  

                        required=False, action='store',  

                        help='timezone to get time output into (pytz  

names)')  

  

    parser.add_argument('--historical',  

                        required=False, action='store_true',  

                        help='do only historical download')  

  

    parser.add_argument('--fromdate',  

                        required=False, action='store',  

                        help=('Starting date for historical download '  

                              'with format: YYYY-MM-DD[THH:MM:SS]'))  

  

    parser.add_argument('--todate',  

                        required=False, action='store',  

                        help=('End date for historical download '  

                              'with format: YYYY-MM-DD[THH:MM:SS]'))  

  

    parser.add_argument('--smaperiod', default=5, type=int,  
﻿                        required=False, action='store',  

                        help='Period to apply to the Simple Moving  

Average')  

  

    pgroup = parser.add_mutually_exclusive_group(required=False)  

  

    pgroup.add_argument('--replay',  

                        required=False, action='store_true',  

                        help='replay to chosen timeframe')  

  

    pgroup.add_argument('--resample',  

                        required=False, action='store_true',  

                        help='resample to chosen timeframe')  

  

    parser.add_argument('--timeframe', default=bt.TimeFrame.Names[0],  

                        choices=bt.TimeFrame.Names,  

                        required=False, action='store',  

                        help='TimeFrame for Resample/Replay')  

  

    parser.add_argument('--compression', default=1, type=int,  

                        required=False, action='store',  

                        help='Compression for Resample/Replay')  

  

    parser.add_argument('--no-bar2edge',  

                        required=False, action='store_true',  

                        help='no bar2edge for resample/replay')  

  
﻿    parser.add_argument('--no-adjbartime',  

                        required=False, action='store_true',  

                        help='no adjbartime for resample/replay')  

  

    parser.add_argument('--no-rightedge',  

                        required=False, action='store_true',  

                        help='no rightedge for resample/replay')  

  

    parser.add_argument('--broker',  

                        required=False, action='store_true',  

                        help='Use VisualChart as broker')  

  

    parser.add_argument('--account', default=None,  

                        required=False, action='store',  

                        help='Choose broker account (else first)')  

  

    parser.add_argument('--trade',  

                        required=False, action='store_true',  

                        help='Do Sample Buy/Sell operations')  

  

    parser.add_argument('--donotsell',  

                        required=False, action='store_true',  

                        help='Do not sell after a buy')  

  

    parser.add_argument('--exectype', default=bt.Order.ExecTypes[0],  

                        choices=bt.Order.ExecTypes,  

                        required=False, action='store',  
﻿                        help='Execution to Use when opening position')  

  

    parser.add_argument('--price', default=None, type=float,  

                        required=False, action='store',  

                        help='Price in Limit orders or Stop Trigger  

Price')  

  

    parser.add_argument('--pstoplimit', default=None, type=float,  

                        required=False, action='store',  

                        help='Price for the limit in StopLimit')  

  

    parser.add_argument('--stake', default=10, type=int,  

                        required=False, action='store',  

                        help='Stake to use in buy operations')  

  

    parser.add_argument('--valid', default=None,  

                        required=False, action='store',  

                        help='Seconds or YYYY-MM-DD')  

  

    parser.add_argument('--cancel', default=0, type=int,  

                        required=False, action='store',  

                        help=('Cancel a buy order after n bars in  

operation,'  

                              ' to be combined with orders like  

Limit'))  

  

    return parser.parse_args()  

  
﻿  

if __name__ == '__main__':  

    runstrategy()  

  

====================================================================== 

==========  

# 文件: volumefilling\volumefilling.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  
﻿# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

import os.path  

import time  

import sys  

  

  

import backtrader as bt  

  

  

class St(bt.Strategy):  

    params = (  

         ('stakeperc', 10.0),  

         ('opbreak', 10),  

    )  

  

    def notify_order(self, order):  

        print('-- NOTIFY ORDER BEGIN')  

        print(order)  
﻿        print('-- NOTIFY ORDER END')  

        print('-- ORDER REMSIZE:', order.executed.remsize)  

  

        if order.status == order.Completed:  

            print('++ ORDER COMPLETED at data.len:', len(order.data))  

            self.doop = -self.p.opbreak  

  

    def __init__(self):  

        pass  

  

    def start(self):  

        self.callcounter = 0  

        txtfields = list()  

        txtfields.append('Len')  

        txtfields.append('Datetime')  

        txtfields.append('Open')  

        txtfields.append('High')  

        txtfields.append('Low')  

        txtfields.append('Close')  

        txtfields.append('Volume')  

        txtfields.append('OpenInterest')  

        print(','.join(txtfields))  

  

        self.doop = 0  

  

    def next(self):  

        txtfields = list()  
﻿        txtfields.append('%04d' % len(self))  

        txtfields.append(self.data0.datetime.date(0).isoformat())  

        txtfields.append('%.2f' % self.data0.open[0])  

        txtfields.append('%.2f' % self.data0.high[0])  

        txtfields.append('%.2f' % self.data0.low[0])  

        txtfields.append('%.2f' % self.data0.close[0])  

        txtfields.append('%.2f' % self.data0.volume[0])  

        txtfields.append('%.2f' % self.data0.openinterest[0])  

        print(','.join(txtfields))  

  

        # Single order  

        if self.doop == 0:  

            if not self.position.size:  

                stakevol = (self.data0.volume[0] * self.p.stakeperc)  

// 100  

                print('++ STAKE VOLUME:', stakevol)  

                self.buy(size=stakevol)  

  

            else:  

                self.close()  

  

        self.doop += 1  

  

  

FILLERS = {  

    'FixedSize': bt.broker.fillers.FixedSize,  

    'FixedBarPerc': bt.broker.fillers.FixedBarPerc,  
﻿    'BarPointPerc': bt.broker.fillers.BarPointPerc,  

}  

  

  

def runstrat():  

    args = parse_args()  

  

    datakwargs = dict()  

    if args.fromdate:  

        fromdate = datetime.datetime.strptime(args.fromdate,  

'%Y-%m-%d')  

        datakwargs['fromdate'] = fromdate  

  

    if args.todate:  

        todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

        datakwargs['todate'] = todate  

  

    data = bt.feeds.BacktraderCSVData(dataname=args.data,  

**datakwargs)  

  

    cerebro = bt.Cerebro()  

    cerebro.adddata(data)  

  

    cerebro.broker.set_cash(args.cash)  

    if args.filler is not None:  

        fillerkwargs = dict()  

        if args.filler_args is not None:  
﻿            fillerkwargs = eval('dict(' + args.filler_args + ')')  

  

        filler = FILLERS[args.filler](**fillerkwargs)  

        cerebro.broker.set_filler(filler)  

  

    cerebro.addstrategy(St, stakeperc=args.stakeperc,  

opbreak=args.opbreak)  

  

    cerebro.run()  

    if args.plot:  

        cerebro.plot(style='bar')  

  

  

def parse_args():  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='Volume Filling Sample')  

  

    parser.add_argument('--data', required=False,  

                        default='../../datas/2006-volume-day-001.txt',  

                        help='Data to be read in')  

  

    parser.add_argument('--cash', required=False, action='store',  

                        default=500e6, type=float,  

                        help=('Starting cash'))  

  

    parser.add_argument('--filler', required=False, action='store',  
﻿                        default=None, choices=FILLERS.keys(),  

                        help=('Apply a volume filler for the  

execution'))  

  

    parser.add_argument('--filler-args', required=False,  

action='store',  

                        default=None,  

                        help=('kwargs for the filler with format:\n'  

                              '\n'  

                              'arg1=val1,arg2=val2...'))  

  

    parser.add_argument('--stakeperc', required=False, action='store',  

                        type=float, default=10.0,  

                        help=('Percentage of 1st bar to use for  

stake'))  

  

    parser.add_argument('--opbreak', required=False, action='store',  

                        type=int, default=10,  

                        help=('Bars to wait for new op after  

completing '  

                              'another'))  

  

    parser.add_argument('--fromdate', '-f', required=False,  

default=None,  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', '-t', required=False,  

default=None,  
﻿                        help='Ending date in YYYY-MM-DD format')  

  

    parser.add_argument('--plot', required=False, action='store_true',  

                        help=('Plot the result'))  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: vwr\vwr.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  
﻿#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

  

import backtrader as bt  

  

TFRAMES = dict(  

    days=bt.TimeFrame.Days,  

    weeks=bt.TimeFrame.Weeks,  

    months=bt.TimeFrame.Months,  

    years=bt.TimeFrame.Years)  

  

  
﻿def runstrat(pargs=None):  

    args = parse_args(pargs)  

  

    # Create a cerebro  

    cerebro = bt.Cerebro()  

  

    if args.cash is not None:  

        cerebro.broker.set_cash(args.cash)  

  

    dkwargs = dict()  

    # Get the dates from the args  

    if args.fromdate is not None:  

        fromdate = datetime.datetime.strptime(args.fromdate,  

'%Y-%m-%d')  

        dkwargs['fromdate'] = fromdate  

    if args.todate is not None:  

        todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

        dkwargs['todate'] = todate  

  

    # Create the 1st data  

    data = bt.feeds.BacktraderCSVData(dataname=args.data, **dkwargs)  

    cerebro.adddata(data)  # Add the data to cerebro  

  

    cerebro.addstrategy(bt.strategies.SMA_CrossOver)  # Add the  

strategy  

  

    lrkwargs = dict()  
﻿    if args.tframe is not None:  

        lrkwargs['timeframe'] = TFRAMES[args.tframe]  

  

    if args.tann is not None:  

        lrkwargs['tann'] = args.tann  

  

    cerebro.addanalyzer(bt.analyzers.Returns, **lrkwargs)  # Returns  

  

    vwrkwargs = dict()  

    if args.tframe is not None:  

        vwrkwargs['timeframe'] = TFRAMES[args.tframe]  

  

    if args.tann is not None:  

        vwrkwargs['tann'] = args.tann  

  

    if args.sigma_max is not None:  

        vwrkwargs['sigma_max'] = args.sigma_max  

  

    if args.tau is not None:  

        vwrkwargs['tau'] = args.tau  

  

    cerebro.addanalyzer(bt.analyzers.SQN)  # VWR Analyzer  

    cerebro.addanalyzer(bt.analyzers.SharpeRatio_A)  # VWR Analyzer  

    cerebro.addanalyzer(bt.analyzers.VWR, **vwrkwargs)  # VWR Analyzer  

    # Sample time return analyzers  

    cerebro.addanalyzer(bt.analyzers.TimeReturn,  

                        timeframe=bt.TimeFrame.Months)  
﻿    cerebro.addanalyzer(bt.analyzers.TimeReturn,  

                        timeframe=bt.TimeFrame.Years)  

  

    # Add a writer to get output  

    cerebro.addwriter(bt.WriterFile, csv=args.writercsv, rounding=4)  

  

    cerebro.run()  # And run it  

  

    # Plot if requested  

    if args.plot:  

        pkwargs = dict(style='bar')  

        if args.plot is not True:  # evals to True but is not True  

            npkwargs = eval('dict(' + args.plot + ')')  # args were  

passed  

            pkwargs.update(npkwargs)  

  

        cerebro.plot(**pkwargs)  

  

  

def parse_args(pargs=None):  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='VWR')  

  

    parser.add_argument('--data', '-d',  

                        default='../../datas/2005-2006-day-001.txt',  

                        help='data to add to the system')  
﻿  

    parser.add_argument('--cash', default=None, type=float,  

required=False,  

                        help='Starting Cash')  

  

    parser.add_argument('--fromdate', '-f',  

                        default=None,  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', '-t',  

                        default=None,  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--writercsv', '-wcsv', action='store_true',  

                        help='Tell the writer to produce a csv  

stream')  

  

    parser.add_argument('--tframe', '--timeframe', default=None,  

                        required=False, choices=TFRAMES.keys(),  

                        help='TimeFrame for the Returns/Sharpe  

calculations')  

  

    parser.add_argument('--sigma-max', required=False, action='store',  

                        type=float, default=None,  

                        help='VWR Sigma Max')  

  

    parser.add_argument('--tau', required=False, action='store',  

                        type=float, default=None,  
﻿                        help='VWR tau factor')  

  

    parser.add_argument('--tann', required=False, action='store',  

                        type=float, default=None,  

                        help=('Annualization factor'))  

  

    parser.add_argument('--stddev-sample', required=False,  

action='store_true',  

                        help='Consider Bessels correction for  

stddeviation')  

  

    # Plot options  

    parser.add_argument('--plot', '-p', nargs='?', required=False,  

                        metavar='kwargs', const=True,  

                        help=('Plot the read data applying any kwargs  

passed\n'  

                              '\n'  

                              'For example:\n'  

                              '\n'  

                              '  --plot style="candle" (to plot  

candles)\n'))  

  

    if pargs is not None:  

        return parser.parse_args(pargs)  

  

    return parser.parse_args()  

  

  
﻿if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: weekdays-filler\weekdaysaligner.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  
﻿<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

  

import backtrader as bt  

import backtrader.feeds as btfeeds  

import backtrader.indicators as btind  

import backtrader.utils.flushfile  

  

# from wkdaysfiller import WeekDaysFiller  

from weekdaysfiller import WeekDaysFiller  

  

  

class St(bt.Strategy):  

    params = (('sma', 0),)  

  

    def __init__(self):  

        if self.p.sma:  

            btind.SMA(self.data0, period=self.p.sma)  

            btind.SMA(self.data1, period=self.p.sma)  

  
﻿    def next(self):  

        dtequal = (self.data0.datetime.datetime() ==  

                   self.data1.datetime.datetime())  

  

        txt = ''  

        txt += '%04d, %5s' % (len(self), str(dtequal))  

        txt += ', data0, %s' %  

self.data0.datetime.datetime().isoformat()  

        txt += ', %s, data1' %  

self.data1.datetime.datetime().isoformat()  

        print(txt)  

  

  

def runstrat():  

    args = parse_args()  

  

    fromdate = datetime.datetime.strptime(args.fromdate, '%Y-%m-%d')  

    todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

  

    cerebro = bt.Cerebro(stdstats=False)  

  

    DataFeed = btfeeds.YahooFinanceCSVData  

    if args.online:  

        DataFeed = btfeeds.YahooFinanceData  

  

    data0 = DataFeed(dataname=args.data0, fromdate=fromdate,  

todate=todate)  

  
﻿    if args.data1:  

        data1 = DataFeed(dataname=args.data1, fromdate=fromdate,  

todate=todate)  

    else:  

        data1 = data0.clone()  

  

    if args.filler or args.filler0:  

        data0.addfilter(WeekDaysFiller, fillclose=args.fillclose)  

  

    if args.filler or args.filler1:  

        data1.addfilter(WeekDaysFiller, fillclose=args.fillclose)  

  

    cerebro.adddata(data0)  

    cerebro.adddata(data1)  

  

    cerebro.addstrategy(St, sma=args.sma)  

    cerebro.run(runonce=True, preload=True)  

  

    if args.plot:  

        cerebro.plot(style='bar')  

  

  

def parse_args():  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='Sample for aligning with trade ')  

  
﻿    parser.add_argument('--online', required=False,  

action='store_true',  

                        help='Fetch data online from Yahoo')  

  

    parser.add_argument('--data0', required=True, help='Data 0 to be  

read in')  

    parser.add_argument('--data1', required=False, help='Data 1 to be  

read in')  

  

    parser.add_argument('--sma', required=False, default=0, type=int,  

                        help='Add a sma to the datas')  

  

    parser.add_argument('--fillclose', required=False,  

action='store_true',  

                        help='Fill with Close price instead of NaN')  

  

    parser.add_argument('--filler', required=False,  

action='store_true',  

                        help='Add Filler to Datas 0 and 1')  

  

    parser.add_argument('--filler0', required=False,  

action='store_true',  

                        help='Add Filler to Data 0')  

  

    parser.add_argument('--filler1', required=False,  

action='store_true',  

                        help='Add Filler to Data 1')  

  

    parser.add_argument('--fromdate', '-f', default='2012-01-01',  
﻿                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', '-t', default='2012-12-31',  

                        help='Ending date in YYYY-MM-DD format')  

  

    parser.add_argument('--plot', required=False, action='store_true',  

                        help='Do plot')  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrat()  

  

====================================================================== 

==========  

# 文件: weekdays-filler\weekdaysfiller.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  
﻿# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import datetime  

  

  

class WeekDaysFiller(object):  

    '''Bar Filler to add missing calendar days to trading days'''  

    # kickstart value for date comparisons  

    ONEDAY = datetime.timedelta(days=1)  

    lastdt = datetime.date.max - ONEDAY  

  
﻿    def __init__(self, data, fillclose=False):  

        self.fillclose = fillclose  

        self.voidbar = [float('Nan')] * data.size()  # init a void bar  

  

    def __call__(self, data):  

        '''Empty bars (NaN) or with last close price are added for  

weekdays with no  

        data  

  

        Params:  

          - data: the data source to filter/process  

  

        Returns:  

          - True (always): bars are removed (even if put back on the  

stack)  

  

        '''  

        dt = data.datetime.date()  # current date in int format  

        lastdt = self.lastdt + self.ONEDAY  # move last seen data once  

forward  

  

        while lastdt < dt:  # loop over gap bars  

            if lastdt.isoweekday() < 6:  # Mon-Fri  

                # Fill in date and add new bar to the stack  

                if self.fillclose:  

                    self.voidbar = [self.lastclose] * data.size()  

                dtime = datetime.datetime.combine(lastdt,  

data.p.sessionend)  
﻿                self.voidbar[-1] = data.date2num(dtime)  

                data._add2stack(self.voidbar[:])  

  

            lastdt += self.ONEDAY  # move lastdt forward  

  

        self.lastdt = dt  # keep a record of the last seen date  

  

        self.lastclose = data.close[0]  

        data._save2stack(erase=True)  # dt bar to the stack and out of  

stream  

        return True  # bars are on the stack (new and original)  

  

====================================================================== 

==========  

# 文件: writer-test\writer-test.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  
﻿# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  

from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

  

# The above could be sent to an independent module  

import backtrader as bt  

import backtrader.feeds as btfeeds  

import backtrader.indicators as btind  

from backtrader.analyzers import SQN  

  

  

class LongShortStrategy(bt.Strategy):  
﻿    '''This strategy buys/sells upong the close price crossing  

    upwards/downwards a Simple Moving Average.  

  

    It can be a long-only strategy by setting the param "onlylong" to  

True  

    '''  

    params = dict(  

        period=15,  

        stake=1,  

        printout=False,  

        onlylong=False,  

        csvcross=False,  

    )  

  

    def start(self):  

        pass  

  

    def stop(self):  

        pass  

  

    def log(self, txt, dt=None):  

        if self.p.printout:  

            dt = dt or self.data.datetime[0]  

            dt = bt.num2date(dt)  

            print('%s, %s' % (dt.isoformat(), txt))  

  

    def __init__(self):  
﻿        # To control operation entries  

        self.orderid = None  

  

        # Create SMA on 2nd data  

        sma = btind.MovAv.SMA(self.data, period=self.p.period)  

        # Create a CrossOver Signal from close an moving average  

        self.signal = btind.CrossOver(self.data.close, sma)  

        self.signal.csv = self.p.csvcross  

  

    def next(self):  

        if self.orderid:  

            return  # if an order is active, no new orders are allowed  

  

        if self.signal > 0.0:  # cross upwards  

            if self.position:  

                self.log('CLOSE SHORT , %.2f' % self.data.close[0])  

                self.close()  

  

            self.log('BUY CREATE , %.2f' % self.data.close[0])  

            self.buy(size=self.p.stake)  

  

        elif self.signal < 0.0:  

            if self.position:  

                self.log('CLOSE LONG , %.2f' % self.data.close[0])  

                self.close()  

  

            if not self.p.onlylong:  
﻿                self.log('SELL CREATE , %.2f' % self.data.close[0])  

                self.sell(size=self.p.stake)  

  

    def notify_order(self, order):  

        if order.status in [bt.Order.Submitted, bt.Order.Accepted]:  

            return  # Await further notifications  

  

        if order.status == order.Completed:  

            if order.isbuy():  

                buytxt = 'BUY COMPLETE, %.2f' % order.executed.price  

                self.log(buytxt, order.executed.dt)  

            else:  

                selltxt = 'SELL COMPLETE, %.2f' % order.executed.price  

                self.log(selltxt, order.executed.dt)  

  

        elif order.status in [order.Expired, order.Canceled,  

order.Margin]:  

            self.log('%s ,' % order.Status[order.status])  

            pass  # Simply log  

  

        # Allow new orders  

        self.orderid = None  

  

    def notify_trade(self, trade):  

        if trade.isclosed:  

            self.log('TRADE PROFIT, GROSS %.2f, NET %.2f' %  

                      (trade.pnl, trade.pnlcomm))  
﻿  

        elif trade.justopened:  

            self.log('TRADE OPENED, SIZE %2d' % trade.size)  

  

  

def runstrategy():  

    args = parse_args()  

  

    # Create a cerebro  

    cerebro = bt.Cerebro()  

  

    # Get the dates from the args  

    fromdate = datetime.datetime.strptime(args.fromdate, '%Y-%m-%d')  

    todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

  

    # Create the 1st data  

    data = btfeeds.BacktraderCSVData(  

        dataname=args.data,  

        fromdate=fromdate,  

        todate=todate)  

  

    # Add the 1st data to cerebro  

    cerebro.adddata(data)  

  

    # Add the strategy  

    cerebro.addstrategy(LongShortStrategy,  

                        period=args.period,  
﻿                        onlylong=args.onlylong,  

                        csvcross=args.csvcross,  

                        stake=args.stake)  

  

    # Add the commission - only stocks like a for each operation  

    cerebro.broker.setcash(args.cash)  

  

    # Add the commission - only stocks like a for each operation  

    cerebro.broker.setcommission(commission=args.comm,  

                                 mult=args.mult,  

                                 margin=args.margin)  

  

    cerebro.addanalyzer(SQN)  

  

    cerebro.addwriter(bt.WriterFile, csv=args.writercsv, rounding=2)  

  

    # And run it  

    cerebro.run()  

  

    # Plot if requested  

    if args.plot:  

        cerebro.plot(numfigs=args.numfigs, volume=False, zdown=False)  

  

  

def parse_args():  

    parser = argparse.ArgumentParser(description='MultiData Strategy')  

  
﻿    parser.add_argument('--data', '-d',  

                        default='../../datas/2006-day-001.txt',  

                        help='data to add to the system')  

  

    parser.add_argument('--fromdate', '-f',  

                        default='2006-01-01',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', '-t',  

                        default='2006-12-31',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--period', default=15, type=int,  

                        help='Period to apply to the Simple Moving  

Average')  

  

    parser.add_argument('--onlylong', '-ol', action='store_true',  

                        help='Do only long operations')  

  

    parser.add_argument('--writercsv', '-wcsv', action='store_true',  

                        help='Tell the writer to produce a csv  

stream')  

  

    parser.add_argument('--csvcross', action='store_true',  

                        help='Output the CrossOver signals to CSV')  

  

    parser.add_argument('--cash', default=100000, type=int,  
﻿                        help='Starting Cash')  

  

    parser.add_argument('--comm', default=2, type=float,  

                        help='Commission for operation')  

  

    parser.add_argument('--mult', default=10, type=int,  

                        help='Multiplier for futures')  

  

    parser.add_argument('--margin', default=2000.0, type=float,  

                        help='Margin for each future')  

  

    parser.add_argument('--stake', default=1, type=int,  

                        help='Stake to apply in each operation')  

  

    parser.add_argument('--plot', '-p', action='store_true',  

                        help='Plot the read data')  

  

    parser.add_argument('--numfigs', '-n', default=1,  

                        help='Plot using numfigs figures')  

  

    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrategy()  

  

====================================================================== 
﻿==========  

# 文件: yahoo-test\yahoo-test.txt  

====================================================================== 

==========  

  

#!/usr/bin/env python  

# -*- coding: utf-8; py-indent-offset:4 -*-  

###################################################################### 

#########  

#  

# Copyright (C) 2015-2023 Daniel Rodriguez  

#  

# This program is free software: you can redistribute it and/or modify  

# it under the terms of the GNU General Public License as published by  

# the Free Software Foundation, either version 3 of the License, or  

# (at your option) any later version.  

#  

# This program is distributed in the hope that it will be useful,  

# but WITHOUT ANY WARRANTY; without even the implied warranty of  

# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  

# GNU General Public License for more details.  

#  

# You should have received a copy of the GNU General Public License  

# along with this program.  If not, see  

<http://www.gnu.org/licenses/>.  

#  

###################################################################### 

#########  
﻿from __future__ import (absolute_import, division, print_function,  

                        unicode_literals)  

  

import argparse  

import datetime  

  

import backtrader as bt  

import backtrader.indicators as btind  

import backtrader.feeds as btfeeds  

import backtrader.filters as btfilters  

  

  

def runstrat():  

    args = parse_args()  

  

    # Create a cerebro entity  

    cerebro = bt.Cerebro(stdstats=False)  

  

    # Add a strategy  

    cerebro.addstrategy(bt.Strategy)  

  

    # Get the dates from the args  

    fromdate = datetime.datetime.strptime(args.fromdate, '%Y-%m-%d')  

    todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')  

  

    data = btfeeds.YahooFinanceData(  

        dataname=args.data,  
﻿        fromdate=fromdate,  

        todate=todate)  

  

    # Add the resample data instead of the original  

    cerebro.adddata(data)  

  

    # Add a simple moving average if requirested  

    cerebro.addindicator(btind.SMA, period=args.period)  

  

    # Add a writer with CSV  

    if args.writer:  

        cerebro.addwriter(bt.WriterFile, csv=args.wrcsv)  

  

    # Run over everything  

    cerebro.run()  

  

    # Plot if requested  

    if args.plot:  

        cerebro.plot(style='bar', numfigs=args.numfigs, volume=False)  

  

  

def parse_args():  

    parser = argparse.ArgumentParser(  

        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  

        description='Calendar Days Filter Sample')  

  

    parser.add_argument('--data', '-d',  
﻿                        default='YHOO',  

                        help='Ticker to download from Yahoo')  

  

    parser.add_argument('--fromdate', '-f',  

                        default='2006-01-01',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--todate', '-t',  

                        default='2006-12-31',  

                        help='Starting date in YYYY-MM-DD format')  

  

    parser.add_argument('--period', default=15, type=int,  

                        help='Period to apply to the Simple Moving  

Average')  

  

    parser.add_argument('--writer', '-w', action='store_true',  

                        help='Add a writer to cerebro')  

  

    parser.add_argument('--wrcsv', '-wc', action='store_true',  

                        help='Enable CSV Output in the writer')  

  

    parser.add_argument('--plot', '-p', action='store_true',  

                        help='Plot the read data')  

  

    parser.add_argument('--numfigs', '-n', default=1, type=int,  

                        help='Plot using numfigs figures')  

  
﻿    return parser.parse_args()  

  

  

if __name__ == '__main__':  

    runstrat()  
