  

🔗 原文链接： https://www.poloxue.com/backtrader/...  

⏰ 剪存时间：2025-03- 15 15:55:11 (UTC+8)  

✂️ 本文档由 飞书剪存 一键生成  

在 backtrader 中运行的策略主要处理数据源和指标。数据源添加到 Cerebro 实例中， 

并最终成为策略的输入（解析并作为实例的属性提供），而指标由策略本身声明和管理。  

到目前为止，所有 backtrader 示例图表都绘制了三件看似理所当然的东西，因为它们 

在任何地方都没有声明：  

•   现金和价值（经纪人中的资金情况）  

•   交易（即操作）  

•   买/卖订单  

它们是观察器，存在于子模块 backtrader.observers 中。因为 Cerebro 支持一个参数 

来自动将它们（或不将它们）添加到策略中： stdstats                       （默认：True）。  

如果遵循默认设置，Cerebro 将执行以下等效用户代码：  

Python  
import backtrader as bt  
cerebro = bt.Cerebro()  # 默认参数：stdstats=True  
cerebro.addobserver(bt.observers.Broker)  
cerebro.addobserver(bt.observers.Trades)  
cerebro.addobserver(bt.observers.BuySell)  

让我们看看通常带有这三个默认观察器的图表（即使没有发出订单，因此没有交易发 

生，现金和投资组合价值没有变化）：  

Python  
from __future__ import (absolute_import, division, print_function,  
unicode_literals)  
import backtrader as bt  
import backtrader.feeds as btfeeds  
if __name__ ==  '__main__':  
    cerebro = bt.Cerebro(stdstats=False)  
    cerebro.addstrategy(bt.Strategy)  
    data = bt.feeds .BacktraderCSVData(dataname='../../datas/2006- 
day-001.txt')  
    cerebro.adddata(data)  
    cerebro.run()  
    cerebro.plot()  

现在让我们在创建 Cerebro 实例时将 stdstats  的值更改为 False                 （也可以在调用  

  
﻿  

run  时完成）：  

Python  
cerebro = bt.Cerebro(stdstats=False)  

图表现在有所不同。  

访问观察器 #  

如上所示，观察器在默认情况下已经存在并收集信息，这些信息可用于统计目的，因 

此可以通过策略的一个名为 stats  的属性访问观察器。  

这只是一个占位符。如果我们回顾上面列出的添加一个默认观察器的代码：  

Python  
cerebro.addobserver(backtrader.observers.Broker)  

显而易见的问题是如何访问 Broker 观察器。下面是如何在策略的 next 方法中完成的 

示例：  

Python  
class MyStrategy(bt.Strategy):  
    def next(self):  
        if self.stats.broker.value[0] < 1000.0:  
           print('WHITE FLAG ... I LOST TOO MUCH')  
        elif self.stats.broker.value[0] > 10000000.0:  
           print('TIME FOR THE VIRGIN ISLANDS ....!!!')  

Broker 观察器就像数据、指标和策略本身一样也是一个线条对象。在这种情况下， 

Broker 有两条线：  

•   cash  

•   value  

观察器的实现 #  

实现非常类似于指标：  

Python  
class Broker(Observer):  
    alias = ('CashValue',)  
    lines = ('cash', 'value')  
    plotinfo = dict(plot=True, subplot=True)  
    def next(self):  

  
﻿  

        self.lines.cash[0] = self._owner .broker.getcash()  
        self.lines.value[0] = value =  
self._owner .broker.getvalue()  

步骤：  

1.  从 Observer   （而不是 Indicator ）派生  

2.  根据需要声明线条和参数（Broker 有两条线但没有参数）  

3.  将有一个自动属性 _owner  ，即持有观察器的策略  

观察器在以下情况下开始运行：  

•   所有指标都已计算完毕  

•   策略的 next 方法已执行完毕  

这意味着在周期结束时… 它们观察已发生的情况。在 Broker 的情况下，它只是盲目 

地记录每个时间点的经纪人现金和投资组合价值。  

将观察器添加到策略 #  

如上所述，Cerebro 使用 stdstats 参数决定是否添加三个默认观察器，从而减轻最 

终用户的工作负担。  

可以将其他观察器添加到混合中，无论是与 stdstats 一起使用还是移除它们。  

让我们来看一个通常的策略，当收盘价高于简单移动平均线时买入，相反则卖出。  

有一个“添加” ：  

•   DrawDown  ，这是 backtrader 生态系统中已经存在的观察器  

Python  
from __future__ import (absolute_import, division, print_function,  
unicode_literals)  
import argparse  
import datetime  
import os.path  
import time  
import sys  
import backtrader as bt  
import backtrader.feeds as btfeeds  
import backtrader.indicators as btind  
class MyStrategy(bt.Strategy):  
    params = (('smaperiod', 15),)  
    def log(self, txt, dt=None):  
         ''' 记录此策略的日志功能  '''        dt = dt or  

  
﻿  

self.data.datetime[0]  
        if isinstance(dt, float):  
            dt = bt.num2date(dt)  
        print('%s, %s' % (dt.isoformat(), txt))  
    def __init__(self):  
        # 主数据上的简单移动平均线        sma =  
btind.SMA(period=self.p.smaperiod)  
        # 交叉（1：向上，-1：向下）收盘价/移动平均线         
self.buysell = btind.CrossOver(self.data.close, sma, plot=True)  
        # 哨兵为 None：允许新订单        self.order = None  
    def next(self):  
        # 访问 -1，因为 drawdown[0] 将在“next”之后计算         
self.log('DrawDown: %.2f' % self.stats.drawdown.drawdown[-1])  
        self.log('MaxDrawDown: %.2f' %  
self.stats.drawdown.maxdrawdown[-1])  
        # 检查我们是否在市场中        if self.position:  
            if self.buysell < 0:  
                self.log('SELL CREATE, %.2f' % self.data.close[0])  
                self.sell()  
        elif self.buysell > 0:  
            self.log('BUY CREATE, %.2f' % self.data.close[0])  
            self.buy()  
def runstrat():  
    cerebro = bt.Cerebro()  
    data = bt.feeds .BacktraderCSVData(dataname='../../datas/2006- 
day-001.txt')  
    cerebro.adddata(data)  
    cerebro.addobserver(bt.observers.DrawDown)  
    cerebro.addstrategy(MyStrategy)  
    cerebro.run()  
    cerebro.plot()  
if __name__ ==  '__main__':  
    runstrat()  

视觉输出显示了回撤的演变：  

部分文本输出：  

Plaintext  
...  
2006-12-14T23:59:59+00:00, MaxDrawDown: 2.62  
2006-12-15T23:59:59+00:00, DrawDown: 0.22  
2006-12-15T23:59:59+00:00, MaxDrawDown: 2.62  
2006-12-18T23:59:59+00:00, DrawDown: 0.00  

  
﻿  

2006-12-18T23:59:59+00:00, MaxDrawDown: 2.62  
...  

注意  

如文本输出和代码所示， DrawDown 观察器实际上有两条线：  

•   drawdown  

•   maxdrawdown  

选择不绘制 maxdrawdown 线，但它仍然可供用户使用。  

实际上， maxdrawdown  的最后一个值也可以通过一个直接属性（不是线条）获取，名 

称为 maxdd  。  

开发观察器 #  

上面展示了  Broker  观察器的实现。要生成有意义的观察器，实现可以使用以下信息：  

•   self._owner 是当前正在执行的策略  

因此策略中的任何内容对观察器都是可用的。  

策略中可能有用的默认内部内容：  

•   broker -> 属性，提供对策略创建订单的经纪人实例的访问。正如在 Broker  中所 

见，通过调用 getcash 和 getvalue 方法收集现金和投资组合价值。  

•   _orderspending -> 列表，策略创建的订单并且经纪人已通知策略一个事件。  

BuySell 观察器遍历列表，查找已执行的订单（全部或部分），以便为给定时间点创建 

一个平均执行价格（索引 0）。  

•   _tradespending  ->  交易列表（已完成的买/卖或卖/买对），由买/卖订单编译而成。 

观察器显然可以通过 self._owner.stats 路径访问其他观察器。  

自定义 OrderObserver #  

标准的 BuySell 观察器只关心已执行的操作。我们可以创建一个观察器，显示订单何 

时创建以及它们是否过期。  

为了可见性，显示将不会与价格一起绘制，而是在一个单独的轴上。  

Python  
from __future__ import (absolute_import, division, print_function,  
unicode_literals)  
import math  
import  
 backtrader as bt  

  
﻿  

class OrderObserver(bt.observer.Observer):  
    lines = ('created', 'expired',)  
    plotinfo = dict(plot=True, subplot=True, plotlinelabels=True)  
    plotlines = dict(  
        created=dict(marker='*', markersize=8.0, color='lime',  
fillstyle='full'),  
        expired=dict(marker='s', markersize=8.0, color='red',  
fillstyle='full')  
    )  
    def next(self):  
        for order in self._owner ._orderspending:  
            if order.data is not self.data:  
                continue  
            if not order.isbuy():  
                continue  
            # 只关心“买入”订单，因为策略中的卖出订单是市场订单并会立即 

执行  
            if order .status in [bt.Order.Accepted,  
bt.Order.Submitted]:  
                self.lines.created[0] = order.created.price  
            elif order.status in [bt.Order.Expired]:  
                self.lines.expired[0] = order.created.price  

自定义观察器只关心买入订单，因为这是一个只买入以尝试获利的策略。卖出订单是 

市场订单，将立即执行。  

更新后的策略 #  

Python  
from __future__ import (absolute_import, division, print_function,  
unicode_literals)  
import datetime  
import backtrader as bt  
import backtrader.feeds as btfeeds  
import backtrader.indicators as btind  
from orderobserver import OrderObserver  
class MyStrategy(bt.Strategy):  
    params = (  
        ('smaperiod', 15),  
        ('limitperc', 1.0),  
        ('valid', 7),  
    )  
    def log(self, txt, dt=None):  

  
﻿  

         ''' 记录此策略的日志功能  '''        dt = dt or  
self.data.datetime[0]  
        if isinstance(dt, float):  
            dt = bt.num2date(dt)  
        print('%s, %s' % (dt.isoformat(), txt))  
    def notify_order(self, order):  
        if order.status in [order.Submitted, order.Accepted]:  
            # 买入/卖出订单已提交/接受至/由经纪人 - 无需执行任何操作             
self.log('ORDER ACCEPTED/SUBMITTED', dt=order.created.dt)  
            self.order = order  
            return  
        if order.status in [order.Expired]:  
            self.log('BUY EXPIRED')  
        elif order.status in [order.Completed]:  
            if order.isbuy():  
                self.log(  
                     'BUY EXECUTED, Price: %.2f, Cost: %.2f,  
Comm %.2f' %                    (order.executed.price,  
                     order.executed.value,  
                     order.executed.comm))  
            else:  # 卖出                self.log('SELL EXECUTED,  
Price: %.2f, Cost: %.2f, Comm %.2f' %                          
(order.executed.price,  
                          order.executed.value,  
                          order.executed.comm))  
        # 哨兵为 None：允许新订单        self.order = None  
    def __init__(self):  
        # 主数据上的简单移动平均线        sma =  
btind.SMA(period=self.p.smaperiod)  

        # 交叉（1：向上，-1：向下）收盘价/移动平均线         
self.buysell = btind.CrossOver(self.data.close, sma, plot=True)  

        # 哨兵为 None：允许新订单        self.order = None  
    def next(self):  
        if self.order:  

            # 待处理订单 ...不做任何事            return  

        # 检查我们是否在市场中        if self.position:  
            if self.buysell < 0:  
                self.log('SELL CREATE, %.2f' % self.data.close[0])  
                self.sell()  
        elif self.buysell > 0:  
            plimit = self.data.close[0] * (1.0 - self.p.limitperc  
/ 100.0)  
            valid = self.data.datetime.date(0) +  

  
﻿  

datetime.timedelta(days=self.p.valid)  
            self.log('BUY CREATE, %.2f' % plimit)  
            self.buy(exectype=bt.Order.Limit, price=plimit,  
valid=valid)  
def runstrat():  
    cerebro = bt.Cerebro()  
    data = bt.feeds .BacktraderCSVData(dataname='../../datas/2006- 
day-001.txt')  
    cerebro.adddata(data)  
    cerebro.addobserver(OrderObserver)  
    cerebro.addstrategy(MyStrategy)  
    cerebro.run()  
    cerebro.plot()  
if __name__ ==  '__main__':  
    runstrat()  

结果图表显示多个订单已过期，可以在新子图（红色方块）中看到。此外，我们还可 

以看到“创建”和“执行”之间的几个天数。  

保存/保持统计数据 #  

截至目前，backtrader 尚未实现任何机制来跟踪观察器的值并将其存储到文件中。最 

好的方法是：  

•   在策略的 start 方法中打开一个文件  

•   在策略的 next 方法中写下值  

考虑 DrawDown 观察器，可以这样做：  

Python  
class MyStrategy(bt.Strategy):  
    def start(self):  
        self.mystats = open('mystats.csv', 'wb')  
        self.mystats.write( 'datetime,drawdown, maxdrawdown\n')  
    def next(self):  
         
self.mystats.write(self.data.datetime.date(0).strftime('%Y-%m- 
%d'))  
        self.mystats.write( ',%.2f' %  
self.stats.drawdown.drawdown[-1])  
        self.mystats.write( ',%.2f' %  
self.stats.drawdown.maxdrawdown[-1])  
        self.mystats.write( '\n')  

  
﻿  

要保存索引 0 的值，一旦所有观察器都被处理完，可以将自定义观察器作为系统的最 

后一个观察器添加，以将值写入 CSV 文件。  

注意，Writer 功能可以自动执行此任务。  

🔗 原文链接： https://www.poloxue.com/backtrader/...  

⏰ 剪存时间：2025-03- 15 15:55:23 (UTC+8)  

✂️ 本文档由 飞书剪存 一键生成  

Ticket #89 是关于添加基准测试以对比一个资产的表现。这个功能非常实用，因为有 

些策略即使盈利也可能低于单纯追踪资产的收益。  

backtrader 包含两种不同类型的对象可以帮助进行追踪：  

•  观察器  

•  分析器  

在分析器领域，已经有一个 TimeReturn 对象，用于跟踪整个投资组合价值的回报演 

变（包括现金）。  

这显然也可以是一个观察器，所以在添加一些基准测试时，也对如何将观察器和分析 

器组合在一起进行了工作，这两者旨在跟踪相同的内容。  

注意  

观察器和分析器之间的主要区别在于观察器的线条特性，观察器记录每个值，这使得 

它们适合绘图和实时查询。当然，这会消耗内存。  

另一方面，分析器通过 get_analysis 返回一组结果，并且实现可能直到运行结束时 

才会提供任何结果。  

observers -基准测试  

分析器 - 基准测试 #  

标准的 TimeReturn 分析器已扩展为支持跟踪数据源。涉及的两个主要参数：  

•  timeframe  （默认：无） 如果为 None，将报告整个回测期间的总回报。  

•  data  （默认：无） 要跟踪的参考资产，而不是投资组合价值。  

注意  

此数据必须已通过 adddata  、  resampledata 或  replaydata 添加到 cerebro 实例中。  

更多详细信息和参数请参阅：分析器参考。  

因此，可以像这样按年度跟踪投资组合的回报：  

  
﻿  

Python  
import backtrader as bt  
cerebro = bt.Cerebro()  
cerebro.addanalyzer(bt.analyzers.TimeReturn,  
timeframe=bt.TimeFrame.Years)  
# 添加数据、策略等 ...  
results = cerebro.run()  
strat0 = results[0]  

# 如果没有指定名称，则名称为类名的小写形式 tret_analyzer =  
strat0.analyzers.getbyname( 'timereturn')  
print(tret_analyzer.get_analysis())  

如果我们想跟踪一个数据的回报：  

Python  
import backtrader as bt  
cerebro = bt.Cerebro()  
data = bt.feeds .OneOfTheFeeds(dataname='abcde', ...)  
cerebro.adddata(data)  
cerebro.addanalyzer(bt.analyzers.TimeReturn,  
timeframe=bt.TimeFrame.Years, data=data)  

# 添加策略等 ...  
results = cerebro.run()  
strat0 = results[0]  

# 如果没有指定名称，则名称为类名的小写形式 tret_analyzer =  
strat0.analyzers.getbyname( 'timereturn')  
print(tret_analyzer.get_analysis())  

如果要同时跟踪两者，最好为分析器指定名称：  

Python  
import backtrader as bt  
cerebro = bt.Cerebro()  
data = bt.feeds .OneOfTheFeeds(dataname='abcde', ...)  
cerebro.adddata(data)  
cerebro.addanalyzer(bt.analyzers.TimeReturn,  
timeframe=bt.TimeFrame.Years, data=data, _name='datareturns')  
cerebro.addanalyzer(bt.analyzers.TimeReturn,  
timeframe=bt.TimeFrame.Years, _name='timereturns')  
# 添加策略等 ...  
results = cerebro.run()  
strat0 = results[0]  
# 获取分析结果 tret_analyzer =  

  
﻿  

strat0.analyzers.getbyname( 'timereturns')  
print(tret_analyzer.get_analysis())  
tdata_analyzer = strat0.analyzers.getbyname('datareturns')  
print(tdata_analyzer.get_analysis())  

观察器 - 基准测试 #  

感谢能够在观察器中使用分析器的底层机制，添加了两个新观察器：  

•   TimeReturn  

•   Benchmark  

两者都使用 bt.analyzers.TimeReturn 分析器来收集结果。  

与上述代码片段相比，以下是一个完整的示例，以展示它们的功能。  

观察 TimeReturn #  

执行：  

Bash  
$ ./observer-benchmark.py --plot --timereturn --timeframe  
notimeframe  

注意执行选项：  

•   --timereturn 告诉示例仅执行此操作。  

•   --timeframe notimeframe  告诉分析器考虑整个数据集而不考虑时间框架边界。  

最后绘制的值是 -0.26 。  

起始现金（从图表中显而易见）为  50K  货币单位，策略最终以  36,970  货币单位收尾， 

因此价值减少了 -26% 。  

观察基准测试 #  

因为基准测试还会显示 timereturn 结果，让我们在激活基准测试的情况下运行相同 

的操作：  

Bash  
$ ./observer-benchmark.py --plot --timeframe notimeframe  

结果显示：  

策略表现优于资产：-0.26 对 -0.33  

  
﻿  

这不应该是庆祝的理由，但至少很清楚策略并不比资产差。  

按年度跟踪的情况：  

Bash  
$ ./observer-benchmark.py --plot --timeframe years  

注意：  

策略的最后一个值略有变化，从 -0.26 变为 -0.27  

而资产的最后一个值则显示为 -0.35          （相对于上面的 -0.33）  

原因是在从 2005 年到 2006 年的过渡中，策略和基准资产在 2005 年初几乎处于起始 

水平。  

切换到周时间框架时，整个图像发生了变化：  

Bash  
$ ./observer-benchmark.py --plot --timeframe weeks  

现在：  

基准观察器显示出更加紧张的情况。事物上下波动，因为现在正在跟踪投资组合和数 

据的每周回报。  

由于在年底的最后一周没有进行任何交易，且资产几乎没有移动，最后显示的值为  

0.00 （最后一周之前的最后收盘价为 25.54 ，而样本数据收盘于 25.55 ，差异首先在小 

数点后第四位显现）。  

观察基准测试 - 另一个数据 #  

示例允许对比不同的数据。默认情况下使用  --benchdata1 基准对比 Oracle。考虑整 

个数据集时使用  --timeframe notimeframe  ：  

Bash  
$ ./observer-benchmark.py --plot --timeframe notimeframe -- 
benchdata1  

结果显示：  

策略的结果未随 notimeframe 变化，仍为 -26%         （-0.26）  

但当与另一个数据进行基准对比时，该数据在同一期间内有 +23%                      （0.23）  的增长  

要么需要更改策略，要么需要交易另一个更好的资产。  

结论 #  

  
﻿  

现在有两种方式，使用相同的底层代码/计算，来跟踪 TimeReturn 和 Benchmark  ：  

•   观察器（ TimeReturn 和 Benchmark ）  

•   分析器（ TimeReturn 和带有 data 参数的 TimeReturn ）  

当然，基准测试并不保证利润，只是比较。  

示例代码 #  

Bash  
$ ./observer-benchmark.py --help  
usage: observer-benchmark.py [-h] [--data0 DATA0] [--data1 DATA1]                              
[--benchdata1] [--fromdate FROMDATE]                              
[--todate TODATE] [--printout] [--cash CASH]                              
[--period PERIOD] [--stake STAKE] [--timereturn]                              
[--timeframe {months,days,notimeframe,years,None,weeks}]                              
[--plot [kwargs]]  
Benchmark/TimeReturn Observers Sample  
optional arguments:  
  -h, --help            show this help message and exit  
  --data0 DATA0         Data0 to be read in (default:  
                         ../../datas/yhoo-1996-2015.txt)  --data1  
DATA1         Data1 to be read in (default:  
                         ../../datas/orcl-1995-2014.txt)  -- 
benchdata1          Benchmark against data1 (default: False)  -- 
fromdate FROMDATE   Starting date in YYYY-MM-DD format (default:  
                        2005-01-01)  --todate TODATE       Ending  
date in YYYY-MM-DD format (default: 2006-12-31)  --printout             
Print data lines (default: False)  --cash CASH           Cash to  
start with (default: 50000)  --period PERIOD       Period for the  
crossover moving average (default: 30)  --stake STAKE          
Stake to apply for the buy operations (default: 1000)  -- 
timereturn          Use TimeReturn observer instead of Benchmark  
(default:  
                        None)  --timeframe  
{months,days,notimeframe,years,None,weeks}                         
TimeFrame to apply to the Observer (default: None)  --plot  
[kwargs], -p [kwargs]                        Plot the read data  
applying any kwargs passed For  
                        example: --plot style="candle" (to plot  
candles)                        (default: None)  

示例代码：  

  
﻿  

Python  
from __future__ import (absolute_import, division, print_function,  
unicode_literals)  
import argparse  
import datetime  
import random  
import backtrader as bt  
class St(bt.Strategy):  
    params = (  
        ('period',   
10),  
        ('printout', False),  
        ('stake', 1000),  
    )  
    def __init__(self):  
        sma = bt.indicators.SMA(self.data, period=self.p.period)  
        self.crossover = bt.indicators.CrossOver(self.data, sma)  
    def start(self):  
        if self.p.printout:  
            txtfields = list()  
            txtfields.append('Len')  
            txtfields.append('Datetime')  
            txtfields.append('Open')  
            txtfields.append('High')  
            txtfields.append('Low')  
            txtfields.append('Close')  
            txtfields.append('Volume')  
            txtfields.append('OpenInterest')  
            print(','.join(txtfields))  
    def next(self):  
        if self.p.printout:  

            # 仅打印第一个数据 ... 只是检查运行情况             
txtfields = list()  
            txtfields.append('%04d' % len(self))  
             
txtfields.append(self.data.datetime.datetime(0).isoformat())  
            txtfields.append('%.2f' % self.data0.open[0])  
            txtfields.append('%.2f' % self.data0.high[0])  
            txtfields.append('%.2f' % self.data0.low[0])  
            txtfields.append('%.2f' % self.data0.close[0])  
            txtfields.append('%.2f' % self.data0.volume[0])  
            txtfields.append('%.2f' % self.data0.openinterest[0])  
            print(','.join(txtfields))  
        if self.position:  

  
﻿  

            if self.crossover < 0.0:  
                if self.p.printout:  
                    print('CLOSE {} @%{}'.format(self .p.stake,  
self.data.close[0]))  
                self.close()  
        else:  
            if self.crossover > 0.0:  
                self.buy(size=self.p.stake)  
                if self.p.printout:  
                    print('BUY   {} @%{}'.format(self .p.stake,  
self.data.close[0]))  
TIMEFRAMES = {  
    None: None,  
     'days': bt.TimeFrame.Days,  
     'weeks': bt.TimeFrame.Weeks,  
     'months': bt.TimeFrame.Months,  
     'years': bt.TimeFrame.Years,  
     'notimeframe': bt.TimeFrame.NoTimeFrame,  
}  
def runstrat(args=None):  
    args = parse_args(args)  
    cerebro = bt.Cerebro()  
    cerebro.broker.set_cash(args.cash)  
    dkwargs = dict()  
    if args.fromdate:  
        fromdate = datetime.datetime.strptime(args.fromdate,  '%Y- 
%m-%d')  
        dkwargs['fromdate'] = fromdate  
    if args.todate:  
        todate = datetime.datetime.strptime(args.todate,  '%Y-%m- 
%d')  
        dkwargs['todate'] = todate  
    data0 = bt.feeds .YahooFinanceCSVData(dataname=args.data0,  
**dkwargs)  
    cerebro.adddata(data0, name='Data0')  
    cerebro.addstrategy(St, period=args.period, stake=args.stake,  
printout=args.printout)  
    if args.timereturn:  
        cerebro.addobserver(bt.observers.TimeReturn,  
timeframe=TIMEFRAMES[args.timeframe])  
    else:  
        benchdata = data0  
        if args.benchdata1:  
            data1 =  

  
﻿  

bt.feeds .YahooFinanceCSVData(dataname=args.data1, **dkwargs)  
            cerebro.adddata(data1, name='Data1')  
            benchdata = data1  
        cerebro.addobserver(bt.observers.Benchmark,  
data=benchdata, timeframe=TIMEFRAMES[args.timeframe])  
    cerebro.run()  
    if args.plot:  
        pkwargs = dict()  
        if args.plot is not True:  # 评估为 True 但不是 True             

pkwargs = eval('dict(' + args.plot +  ')')  # 传递的参数  
        cerebro.plot(**pkwargs)  
def parse_args(pargs=None):  
    parser = argparse.ArgumentParser(  
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,  
        description='Benchmark/TimeReturn Observers Sample')  
    parser.add_argument('--data0', required=False,  
default='../../datas/yhoo-1996-2015.txt', help='Data0 to be read  
in')  
    parser.add_argument('--data1', required=False,  
default='../../datas/orcl-1995-2014.txt', help='Data1 to be read  
in')  
    parser.add_argument('--benchdata1', required=False,  
action='store_true', help=('Benchmark against data1'))  
    parser.add_argument('--fromdate', required=False,  
default='2005-01-01', help='Starting date in YYYY-MM-DD format')  
    parser.add_argument('--todate', required=False, default='2006- 
12-31', help='Ending date in YYYY-MM-DD format')  
    parser.add_argument('--printout', required=False,  
action='store_true', help=('Print data lines'))  
    parser.add_argument('--cash', required=False, action='store',  
type=float, default=50000, help=('Cash to start with'))  
    parser.add_argument('--period', required=False,  
action='store', type=int, default=30, help=('Period for the  
crossover moving average'))  
    parser.add_argument('--stake', required=False, action='store',  
type=int, default=1000, help=('Stake to apply for the buy  
operations'))  
    parser.add_argument('--timereturn', required=False,  
action='store_true', default=None, help=('Use TimeReturn observer  
instead of Benchmark'))  
    parser.add_argument('--timeframe', required=False,  
action='store', default=None, choices=TIMEFRAMES.keys(),  
help=('TimeFrame to apply to the Observer'))  
    parser.add_argument('--plot', '-p', nargs='?', required=False,  

  
﻿  

metavar='kwargs', const=True, help=('Plot the read data applying  
any kwargs passed\nFor example:\n\n  --plot style="candle" (to  
plot candles)\n'))  
    if pargs:  
        return parser.parse_args(pargs)  
    return parser.parse_args()  
if __name__ ==  '__main__':  
    runstrat()  

🔗 原文链接： https://www.poloxue.com/backtrader/...  

⏰ 剪存时间：2025-03- 15 15:55:04 (UTC+8)  

✂️ 本文档由 飞书剪存 一键生成  

observers -参考  

Benchmark #  

Python  
class backtrader.observers.Benchmark()  

该观察器存储策略的回报和作为参考资产的回报，这个参考资产是传递给系统的一个 

数据。  

参数：  

•   timeframe  （默认：无）：如果为 None，则报告整个回测期间的总回报。  

•   compression  （默认：无）：仅用于子日时间框架，例如通过指定  

“TimeFrame.Minutes” 和 60 作为压缩在每小时时间框架上工作。  

•   data  （默认：无）：跟踪的参考资产以便进行比较。  

注意  ：此数据必须已通过 adddata  、  resampledata 或  replaydata 添加到 cerebro  

实例中。  

•   _doprenext  （默认：False）：基准测试将在策略开始运行时进行（即策略的最小 

周期已达到时）。将其设置为 True 将从数据源的起点记录基准值。  

•   firstopen  （默认：False）：保持为 False 确保价值和基准之间的首次比较点从  

0% 开始，因为基准不会使用其开盘价。参见 TimeReturn 分析器参考以获得参数的 

完整解释。  

•   fund  （默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode -  

True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的  

  
﻿  

set_fundmode  。设置为 True 或 False 以获得特定行为。  

记住，在运行的任何时刻都可以通过查看索引 0 处的线条名称来检查当前值。  

Broker #  

Python  
class backtrader.observers.Broker(*args, **kwargs)  

该观察器跟踪经纪人中的当前现金金额和投资组合价值（包括现金）。  

参数  ：无  

Broker - Cash #  

Python  
class backtrader.observers.Cash(*args, **kwargs)  

该观察器跟踪经纪人中的当前现金金额。  

参数  ：无  

Broker - Value #  

Python  
class backtrader.observers.Value(*args, **kwargs)  

该观察器跟踪经纪人中的当前投资组合价值，包括现金。  

参数  ：  

•   fund  （默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode -  

True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的  

set_fundmode  。设置为 True 或 False 以获得特定行为。  

BuySell #  

Python  
class backtrader.observers.BuySell(*args, **kwargs)  

该观察器跟踪单个买入/卖出订单（单个执行）并将在图表上绘制它们，围绕执行价格 

水平绘制。  

参数  ：  

•   barplot  （默认：  False ）：在最低点下方绘制买入信号，在最高点上方绘制卖 

  
﻿  

出信号。如果为  False  ，则将在条形的平均执行价格上绘制。  

•   bardist  （默认： 0.015  1.5%）：当 barplot 为 True  时，与最大值/最小值的距 

离。  

DrawDown #  

Python  
class backtrader.observers.DrawDown()  

该观察器跟踪当前的回撤水平（绘图）和最大回撤（不绘图）水平。  

参数  ：  

•   fund  （默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode -  

True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的  

set_fundmode  。设置为 True 或 False 以获得特定行为。  

TimeReturn #  

Python  
class backtrader.observers.TimeReturn()  

该观察器存储策略的回报。  

参数  ：  

•   timeframe  （默认：无）：如果为 None，则报告整个回测期间的总回报。传递  

TimeFrame.NoTimeFrame  以考虑整个数据集而不受时间限制。  

•   compression  （默认：无）：仅用于子日时间框架，例如通过指定  

“TimeFrame.Minutes” 和 60 作为压缩在每小时时间框架上工作。  

•   fund  （默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode -  

True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的  

set_fundmode  。设置为 True 或 False 以获得特定行为。  

记住，在运行的任何时刻都可以通过查看索引 0 处的线条名称来检查当前值。  

Trades #  

Python  
class backtrader.observers.Trades()  

该观察器跟踪完整的交易，并在交易关闭时绘制实现的损益水平。  

  
﻿  

交易在仓位从 0       （或跨越 0）变为 X  时开立，然后在回到 0            （或反方向跨越 0）时关闭。  

参数  ：  

•   pnlcomm  （默认： True ）：显示净利润和亏损，即扣除佣金后的结果。如果设置 

为  False  ，将显示扣除佣金前的交易结果。  

LogReturns #  

Python  
class backtrader.observers.LogReturns()  

该观察器存储策略的对数回报。  

参数  ：  

•   timeframe  （默认：无）：如果为 None，则报告整个回测期间的总回报。传递  

TimeFrame.NoTimeFrame  以考虑整个数据集而不受时间限制。  

•   compression  （默认：无）：仅用于子日时间框架，例如通过指定  

“TimeFrame.Minutes” 和 60 作为压缩在每小时时间框架上工作。  

•   fund  （默认：无）：如果为 None，将自动检测经纪人的实际模式（fundmode -  

True/False）来决定回报率是基于总净资产价值还是基金价值。见经纪人文档中的  

set_fundmode  。设置为 True 或 False 以获得特定行为。  

记住，在运行的任何时刻都可以通过查看索引 0 处的线条名称来检查当前值。  

LogReturns2 #  

Python  
class backtrader.observers.LogReturns2()  

扩展  LogReturns 观察器以显示两个工具。  

FundValue #  

Python  
class backtrader.observers.FundValue(*args, **kwargs)  

该观察器跟踪当前的基金价值。  

参数  ：无  

Python  
class backtrader.observers.FundShares(*args, **kwargs)  

  
