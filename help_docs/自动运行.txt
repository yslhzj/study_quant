  

线：  

•   datetime  

参数：  

•   signals ([])  

•   _accumulate (False)  

•   _concurrent (False)  

•   _data (None)  

 自动运行  

🔗 原文链接： https://www.poloxue.com/backtrader/...  

⏰ 剪存时间：2025-03- 15 16:38:11 (UTC+8)  

✂️ 本文档由 飞书剪存 一键生成  

到目前为止，所有 backtrader 示例和工作样本都从头开始创建一个主 Python 模块， 

该模块加载数据、策略、观察器，并准备现金和佣金方案。  

算法交易的目标之一是自动化交易，而 backtrader 作为一个回测平台，旨在检查交易 

算法（因此是一个算法交易平台），自动化使用 backtrader 是一个显而易见的目标。  

安装  backtrader 后，它提供了两个脚本/可执行文件形式的入口点，自动化大多数任务：  

1.  bt-run-py  ：一个使用下一个条目中的代码库的脚本。  

2.  btrun  （可执行文件）：由 setuptools 在打包时创建的入口点。该可执行文件在  

Windows 下具有优势，理论上不会出现“找不到路径/文件”的错误。  

下面的描述适用于这两个工具。  

btrun 允许最终用户：  

•   指定要加载的数据源  

•   设置加载数据的格式  

•   指定数据的日期范围  

•   传递参数给 Cerebro  

•   禁用标准观察器  

    ￮  这是一个原始的额外开关，在实现“Cerebro”参数之前。因此，如果传递了与 

    标准观察器相关的参数给 Cerebro ，将忽略此参数（参数 stdstats 给 Cerebro）  

•   从内置或 Python 模块加载一个或多个观察器（例如：DrawDown）  

  
﻿  

•   设置经纪商的现金和佣金方案参数（佣金、保证金、倍数）  

•   启用绘图，控制图表的数量和样式  

•   向系统添加一个参数化的 writer  

•   最后是核心功能：加载一个策略（内置或来自 Python 模块）  

    ￮   传递参数给加载的策略  

请参阅下面的脚本用法。  

应用用户定义策略 #  

考虑以下策略，它：  

•   简单加载一个简单移动平均线（默认周期为  15）  

•   打印输出  

•   存在于名为 mymod.py  的文件中  

Python  
from __future__ import (absolute_import, division, print_function,  
unicode_literals)  
import backtrader as bt  
import backtrader.indicators as btind  
class MyTest(bt.Strategy):  
    params = (('period', 15),)  
    def log(self, txt, dt=None):  
         '''策略的日志记录函数 '''        dt = dt 或 
self.data.datetime[0]  
        if isinstance(dt, float):  
            dt = bt.num2date(dt)  
        print('%s, %s' % (dt.isoformat(), txt))  
    def __init__(self):  
        sma = btind.SMA(period=self.p.period)  
    def next(self):  
        ltxt =  '%d, %.2f, %.2f, %.2f, %.2f, %.2f, %.2f'  
        self.log(ltxt %                 (len(self),  
                  self.data.open[0], self.data.high[0],  
                  self.data.low[0], self.data.close[0],  
                  self.data.volume[0], self.data.openinterest[0]))  

使用常规测试示例执行策略非常简单：  

Bash  

  
﻿  

btrun --csvformat btcsv \  
      --data ../../datas/2006-day-001.txt \  
      --strategy mymod.py  

图表输出：  

  

  

  

控制台输出：  

Plaintext  
2006-01-20T23:59:59+00:00, 15, 3593.16, 3612.37, 3550.80, 3550.80,  
0.00, 0.00  
2006-01-23T23:59:59+00:00, 16, 3550.24, 3550.24, 3515.07, 3544.31,  
0.00, 0.00  
2006-01-24T23:59:59+00:00, 17, 3544.78, 3553.16, 3526.37, 3532.68,  
0.00, 0.00  
2006-01-25T23:59:59+00:00, 18, 3532.72, 3578.00, 3532.72, 3578.00,  
0.00, 0.00  
...  
2006-12-22T23:59:59+00:00, 252, 4109.86, 4109.86, 4072.62,  
4073.50, 0.00, 0.00  
2006-12-27T23:59:59+00:00, 253, 4079.70, 4134.86, 4079.70,  
4134.86, 0.00, 0.00  
2006-12-28T23:59:59+00:00, 254, 4137.44, 4142.06, 4125.14,  
4130.66, 0.00, 0.00  
2006-12-29T23:59:59+00:00, 255, 4130.12, 4142.01, 4119.94,  
4119.94, 0.00, 0.00  

相同策略，但将参数 period 设置为 50 的命令行：  

Bash  
btrun --csvformat btcsv \  
      --data ../../datas/2006-day-001.txt \  
      --plot \  
      --strategy mymod.py:period=50  

图表输出：  

  

  

  

  
﻿  

注意：如果没有提供  .py 扩展名， bt-run 会自动添加它。  

使用内置策略 #  

backtrader 将逐步包括一些示例（教科书）策略。与 bt-run.py 脚本一起，包含了一 

个标准的简单移动平均交叉策略。名称为 SMA_CrossOver  。  

参数 #  

•   fast   （默认  10）：快速移动平均线的周期  

•   slow   （默认 30）：慢速移动平均线的周期  

该策略在快速移动平均线上穿慢速移动平均线时买入，并在快速移动平均线下穿慢速 

移动平均线时卖出（仅在之前已买入的情况下）。  

代码如下：  

Python  
from __future__ import (absolute_import, division, print_function,  
unicode_literals)  
import backtrader as bt  
import backtrader.indicators as btind  
class SMA_CrossOver(bt.Strategy):  
    params = (('fast', 10), ('slow', 30))  
    def __init__(self):  
        sma_fast = btind.SMA(period=self.p.fast)  
        sma_slow = btind.SMA(period=self.p.slow)  
        self.buysig = btind.CrossOver(sma_fast, sma_slow)  
    def next(self):  
        if self.position.size:  
            if self.buysig < 0:  
                self.sell()  
        elif self.buysig > 0:  
            self.buy()  

标准执行：  

Bash  
btrun --csvformat btcsv \  
      --data ../../datas/2006-day-001.txt \  
      --plot \  
      --strategy :SMA_CrossOver  

注意  :  。标准的加载策略表示法为： module:strategy:kwargs  。规则如下：  

  
﻿  

•    如果指定了 module 和  strategy  ，则使用该策略。  

•    如果指定了 module 但未指定  strategy  ，则使用模块中找到的第一个策略。  

•    如果未指定 module  ，则“strategy”被视为 backtrader 包中的策略。  

•    如果指定了 module 和/或 strategy  ，如果存在 kwargs  ，它们将传递给相应的 

策略。  

注意：相同的表示法和规则适用于  --observer  、  --analyzer 和  --indicator 选项， 

显然适用于相应的对象类型。  

输出结果：  

  

  

  

最后一个示例，添加佣金方案、现金并更改参数：  

Bash  
btrun --csvformat btcsv \  
      --data ../../datas/2006-day-001.txt \  
      --plot \  
      --cash 20000 \  
      --commission 2.0 \  
      --mult 10 \  
      --margin 2000 \  
      --strategy :SMA_CrossOver:fast=5,slow=20  

输出结果：  

  

  

  

我们已经回测了策略：  

•    更改移动平均线周期  

•    设置新的起始现金  

•    为类似期货的工具设置佣金方案  

观察每个条的现金持续变化，因为现金根据类似期货工具的每日变化进行调整。  

使用无策略 #  

  
﻿  

这是一个夸张的说法。会应用一个策略，但您可以省略任何类型的策略，会自动添加 

一个默认的 backtrader.Strategy  。  

分析器、观察器和指标将自动注入策略中。  

例如：  

Bash  
btrun --csvformat btcsv \  
      --data ../../datas/2006-day-001.txt \  
      --cash 20000 \  
      --commission 2.0 \  
      --mult 10 \  
      --margin 2000 \  
      --nost  
dstats \  
      --observer :Broker  

这不会做很多事情，但可以实现以下目的：  

•   在后台添加一个默认的 backtrader.Strategy  

•   Cerebro 不会实例化常规的 stdstats 观察器（Broker、BuySell、Trades）  

•   手动添加一个 Broker 观察器  

如上所述， nostdstats 是一个遗留参数。更新版本的 btrun 可以将参数直接传递给  

Cerebro。等效调用如下：  

Bash  
btrun --csvformat btcsv \  
      --data ../../datas/2006-day-001.txt \  
      --cash 20000 \  
      --commission 2.0 \  
      --mult 10 \  
      --margin 2000 \  
      --cerebro stdstats=False \  
      --observer :Broker  

添加分析器 #  

btrun 还支持使用与选择内部/外部分析器相同的语法添加分析器。  

例如，对 2005-2006 年进行夏普比率分析：  

Bash  
btrun --csvformat btcsv \  

  
﻿  

      --data ../../datas/2005-2006-day-001.txt \  
      --strategy :SMA_CrossOver \  
      --analyzer :SharpeRatio  

控制台输出为空。  

如果希望打印分析器结果，必须指定：  

•    --pranalyzer  ，默认调用下一个（除非分析器覆盖了适当的方法）  

•    --ppranalyzer  ，使用 pprint 模块打印结果  

注意：这两个打印选项在 writers 成为 backtrader 的一部分之前实现。添加一个 writer  

而不输出 CSV 将实现相同的效果（并且输出得到了改进）。  

扩展上述示例：  

Bash  
btrun --csvformat btcsv \  
      --data ../../datas/2005-2006-day-001.txt \  
      --strategy :SMA_CrossOver \  
      --analyzer :SharpeRatio \  
      --plot \  
      --pranalyzer  
====================== Analyzers  
====================##########sharperatio  
##########{'sharperatio': 11.647332609673256}  

好策略！（实际上纯属运气，示例中没有考虑佣金）  

图表（仅显示分析器未在图表中绘制，因为分析器无法绘制，它们不是线条对象）：  

  

  

  

使用 writer 参数的相同示例：  

Bash  
btrun --csvformat btcsv \  
      --data ../../datas/2005-2006-day-001.txt \  
      --strategy :SMA_CrossOver \  
      --analyzer :SharpeRatio \  
      --plot \  
      --writer  
================================================================== 
=============Cerebro:  

  
﻿  

  ---------------------------------------------------------------- 
-------------  
  - Datas:  
     
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
+++++++++  
    - Data0:  
      - Name: 2005-2006-day-001  
      - Timeframe: Days  
      - Compression: 1  ------------------------------------------ 
-----------------------------------  
  - Strategies:  
     
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
+++++++++  
    - SMA_CrossOver:  
       
****************************************************************** 
*******  
      - Params:  
        - fast: 10        - slow: 30        - _movav: SMA  
       
****************************************************************** 
*******  
      - Indicators:  
         .......................................................... 
.............  
        - SMA:  
          - Lines: sma  
           
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
~~~  
          - Params:  
            - period:  
30        ........................................................ 
...............  
        - CrossOver:  
          - Lines: crossover  
          - Params: None  
       
****************************************************************** 
*******  
      - Observers:  
         .......................................................... 

  
﻿  

.............  
        - Broker:  
          - Lines: cash, value  
          - Params: None  
         .......................................................... 
.............  
        - BuySell:  
          - Lines: buy, sell  
          - Params: None  
         .......................................................... 
.............  
        - Trades:  
          - Lines: pnlplus, pnlminus  
          - Params: None  
       
****************************************************************** 
*******  
      - Analyzers:  
         .......................................................... 
.............  
        - Value:  
          - Begin: 10000.0  
          - End: 10496.68  
         .......................................................... 
.............  
        - SharpeRatio:  
          - Params: None  
           
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
~~~  
          - Analysis:  
            - sharperatio: 11.6473326097  

添加指标和观察器 #  

与策略和分析器相同， btrun 还可以添加：  

•   指标  

•   观察器  

语法与上面添加 Broker 观察器时所见完全相同。  

让我们重复示例，添加一个随机指标、Broker 并查看图表（我们将更改一些参数）：  

  
﻿  

Bash  
btrun --csvformat btcsv \  
      --data ../../datas/2006-day-001.txt \  
      --nostdstats \  
      --observer :Broker \  
      --indicator :Stochastic:period_dslow=5 \  
      --plot  

图表：  

  

  

  

绘图控制 #  

上面大多数示例都使用了以下选项：  

•    --plot  ：激活创建默认图表 更多控制可以通过向  --plot 选项添加 kwargs 实现  

•    --plot style="candle" 例如，使用蜡烛图而不是 LineOnClose 样式（这是绘 

图默认值） 调用如下：  

Bash  
btrun --csvformat btcsv \  
      --data ../../datas/2006-day-001.txt \  
      --nostdstats \  
      --observer :Broker \  
      --indicator :Stochastic:period_dslow=5 \  
      --plot style=\"candle\"  

注意：示例在 bash shell 中运行，传递参数给脚本之前会去除引号，因此需要使用反 

斜杠转义 \" 确保 candle 作为字符串传递。  

图表：  

  

  

  

脚本用法 #  

直接从脚本：  

  
﻿  

Bash  
$ btrun --help  
usage: btrun-script.py [-h] --data DATA [--cerebro [kwargs]] [-- 
nostdstats]                       [--format  
{yahoocsv_unreversed,vchart,vchartcsv,yahoo,mt4csv,ibdata,sierracs 
v,yahoocsv,btcsv,vcdata}]                       [--fromdate  
FROMDATE] [--todate TODATE]                       [--timeframe  
{microseconds,seconds,weeks,months,minutes,days,years}]                        
[--compression COMPRESSION]                       [--resample  
RESAMPLE | --replay REPLAY]                       [--strategy  
module:name:kwargs]                       [--signal  
module:signaltype:name:kwargs]                       [--observer  
module:name:kwargs]                       [--analyzer  
module:name:kwargs]                       [--pranalyzer | -- 
ppranalyzer]                       [--indicator  
module:name:kwargs] [--writer [kwargs]]                       [-- 
cash CASH] [--commission COMMISSION]                       [-- 
margin MARGIN] [--mult MULT] [--interest INTEREST]                        
[--interest_long] [--slip_perc SLIP_PERC]                        [- 
-slip_fixed SLIP_FIXED] [--slip_open]                        [--no- 
slip_match] [--slip_out] [--flush]                       [--plot  
[kwargs]]  
Backtrader Run Script  
optional arguments:  
  -h, --help            show this help message and exit  
  --resample RESAMPLE, -rs RESAMPLE  
                        resample with timeframe:compression values  
  --replay REPLAY, -rp REPLAY  
                        replay with timeframe:compression values  
  --pranalyzer, -pralyzer  
                        Automatically print analyzers  
  --ppranalyzer, -ppralyzer  
                        Automatically PRETTY print analyzers  
  --plot [kwargs], -p [kwargs]                        Plot the  
read data applying any kwargs passed  
                        For example:  
                          --plot style="candle" (to plot  
candlesticks)  
Data options:  
  --data DATA, -d DATA  Data files to be added to the system  
Cerebro options:  
  --cerebro [kwargs], -cer [kwargs]                        The  
argument can be specified with the following form:  
                          - kwargs  

  
﻿  

                            Example: "preload=True" which set its  
to True  
                        The passed kwargs will be passed directly  
to the cerebro  
                        instance created for the execution  
                        The available kwargs to cerebro are:  
                          - preload (default: True)                           
- runonce (default: True)                          - maxcpus  
(default: None)                          - stdstats (default:  
True)                          - live (default: False)                           
- exactbars (default: False)                          - preload  
(default: True)                          - writer (default False)                           
- oldbuysell (default False)                          -  
tradehistory (default False)  --nostdstats          Disable the  
standard statistics observers  
  --format  
{yahoocsv_unreversed,vchart,vchartcsv,yahoo,mt4csv,ibdata,sierracs 
v,yahoocsv,btcsv,vcdata}, --csvformat  
{yahoocsv_unreversed,vchart,vchartcsv,yahoo,mt4csv,ibdata,sierracs 
v,yahoocsv,btcsv,vcdata}, -c  
{yahoocsv_unreversed,vchart,vchartcsv,yahoo,mt4csv,ibdata,sierracs 
v,yahoocsv,btcsv,vcdata}                        CSV Format  
  --fromdate FROMDATE, -f FROMDATE  
                        Starting date in YYYY-MM-DD[THH:MM:SS]  
format  
   
 --todate TODATE, -t TODATE  
                        Ending date in YYYY-MM-DD[THH:MM:SS]  
format  
  --timeframe  
{microseconds,seconds,weeks,months,minutes,days,years}, -tf  
{microseconds,seconds,weeks,months,minutes,days,years}                         
Ending date in YYYY-MM-DD[THH:MM:SS] format  
  --compression COMPRESSION, -cp COMPRESSION  
                        Ending date in YYYY-MM-DD[THH:MM:SS]  
format  
Strategy options:  
  --strategy module:name:kwargs, -st module:name:kwargs  
                        This option can be specified multiple  
times.  
                        The argument can be specified with the  
following form:  
                          - module:classname:kwargs  
                            Example: mymod:myclass:a=1,b=2  

  
﻿  

                        kwargs is optional  
                        If module is omitted then class name will  
be sought in  
                        the built-in strategies module. Such as  
in:  
                          -  :name:kwargs or :name  
                        If name is omitted, then the 1st strategy  
found in the mod  
                        will be used. Such as in:  
                          - module or module::kwargs  
Signals:  
  --signal module:signaltype:name:kwargs, -sig  
module:signaltype:name:kwargs  
                        This option can be specified multiple  
times.  
                        The argument can be specified with the  
following form:  
                          -  
signaltype:module:signaltype:classname:kwargs  
                            Example:  
longshort+mymod:myclass:a=1,b=2  
                        signaltype may be ommited: longshort will  
be used  
                            Example: mymod:myclass:a=1,b=2  
                        kwargs is optional  
                        signaltype will be uppercased to match the  
defintions  
                        fromt the backtrader.signal module  
                        If module is omitted then class name will  
be sought in  
                        the built-in signals module. Such as in:  
                          - LONGSHORT::name:kwargs or :name  
                        If name is omitted, then the 1st signal  
found in the mod  
                        will be used. Such as in:  
                          - module or module:::kwargs  
Observers and statistics:  
  --observer module:name:kwargs, -ob module:name:kwargs  
                        This option can be specified multiple  
times.  
                        The argument can be specified with the  
following form:  
                          - module:classname:kwargs  
                            Example: mymod:myclass:a=1,b=2  

  
﻿  

                        kwargs is optional  
                        If module is omitted then class name will  
be sought in  
                        the built-in observers module. Such as in:  
                          -  :name:kwargs or :name  
                        If name is omitted, then the 1st observer  
found in the  
                        will be used. Such as in:  
                          - module or module::kwargs  
Analyzers:  
  --analyzer module:name:kwargs, -an module:name:kwargs  
                        This option can be specified multiple  
times.  
                        The argument can be specified with the  
following form:  
                          - module:classname:kwargs  
                            Example: mymod:myclass:a=1,b=2  
                        kwargs is optional  
                        If module is omitted then class name will  
be sought in  
                        the built-in analyzers module. Such as in:  
                          -  :name:kwargs or :name  
                        If name is omitted, then the 1st analyzer  
found in the  
                        will be used. Such as in:  
                          - module or module::kwargs  
Indicators:  
  --indicator module:name:kwargs, -ind module:name:kwargs  
                        This option can be specified multiple  
times.  
                        The argument can be specified with the  
following form:  
                          - module:classname:kwargs  
                            Example: mymod:myclass:a=1,b=2  
                        kwargs is optional  
                        If module is omitted then class name will  
be sought in  
                        the built-in analyzers module. Such as in:  
                          -  :name:kwargs or :name  
                        If name is omitted, then the 1st analyzer  
found in the  
                        will be used. Such as in:  
                          - module or module::kwargs  
Writers:  

  
﻿  

  --writer [kwargs], -wr [kwargs]                        This  
option can be specified multiple times.  
                        The argument can be specified with the  
following form:  
                          - kwargs  
                            Example: a=1,b=2  
                        kwargs is optional  
                        It creates a system wide writer which  
outputs run data  
                        Please see the documentation for the  
available kwargs  
Cash and Commission Scheme Args:  
  --cash CASH, -cash CASH  
                        Cash to set to the broker  
  --commission COMMISSION, -comm COMMISSION  
                        Commission value to set  
  --margin MARGIN, -marg MARGIN  
                        Margin type to set  
  --mult MULT, -mul MULT  
                        Multiplier to use  
  --interest INTEREST   Credit Interest rate to apply (0.0x)  -- 
interest_long       Apply credit interest to long positions  
  --slip_perc SLIP_PERC  
                        Enable slippage with a percentage value  
  --slip_fixed SLIP_FIXED  
                        Enable slippage with a fixed point value  
  --slip_open           enable slippage for when matching opening  
prices  
  --no-slip_match       Disable slip_match, ie: matching capped at  
                        high-low if slippage goes over those  
limits  
  --slip_out            with slip_match enabled, match outside  
high-low  
  --flush               flush the output - useful under win32  
systems  

Strategy 的生命周期方法 #  

注意 , 策略可以在创建时通过抛出 StrategySkipError 异常来中断，该异常来自  

backtrader.errors 模块。这将避免在回测期间处理该策略。请参阅“异常”部分。  

构建： __init__ #  

这是在实例化期间调用的：指标将在此处创建以及其他需要的属性。  

  
﻿  

示例代码：  

Python  
def __init__(self):  
    self.sma = btind.SimpleMovingAverage(period=15)  

启动： start #  

Cerebro 实例通知策略是时候开始运行了。存在一个默认的空方法。  

初期： prenext #  

在创建期间声明的指标将对策略的成熟期施加限制：这称为最小周期。上面的  

__init__ 创建了一个周期为  15 的简单移动平均线 (SMA)。  

只要系统看到的 bar 少于  15 个，就会调用 prenext           （默认实现为空操作）。  

成熟： next #  

一旦系统看到  15 个 bar 并且 SMA 有足够的缓冲区开始生成值，策略就足够成熟可以 

真正执行。  

存在一个 nextstart 方法，会在从 prenext 切换到 next  时调用一次。 nextstart  

的默认实现是简单地调用 next  。  

繁衍：无 #  

策略实际上不会繁衍，但从某种意义上来说，它们会，因为系统会在优化时实例化它 

们多次（使用不同的参数）。  

结束： stop #  

系统通知策略是时候重置并整理一切了。存在一个默认的空方法。  

通常情况下和常规使用模式下，这看起来像这样：  

Python  
class MyStrategy(bt.Strategy):  
    def __init__(self):  
        self.sma = btind.SimpleMovingAverage(period=15)  
    def next(self):  
        if self.sma > self.data.close:  

            # 执行某些操作            pass        elif self.sma <  
self.data.close:  

  
﻿  

            # 执行其他操作            pass  

在这个代码片段中：  

•   在 __init__  中分配一个指标给属性  

•   默认的空 start 方法未被重写  

•   prenext 和 nextstart 未被重写  

•   在 next  中，指标的值与收盘价进行比较，以执行某些操作  

•   默认的空 stop 方法未被重写  

策略事件通知 #  

策略将每个 next 周期收到通知：  

notify_order #  

通过 notify_order(order) 接收任何订单状态的变化通知。  

notify_trade #  

通过 notify_trade(trade) 接收任何交易的开启/更新/关闭通知  

notify_cashvalue #  

通过 notify_cashvalue(cash, value) 接收经纪账户中的当前现金和投资组合  

notify_fund #  

通过 notify_fund(cash, value, fundvalue, shares) 接收经纪账户中的当前现 

金、投资组合、基金价值和份额  

notify_store #  

通过 notify_store(msg, *args, **kwargs) 接收来自存储提供者的通知  

如何买入/卖出/平仓 #  

buy  和  sell  方法生成订单。调用这些方法时，它们返回一个  Order              （或其子类）实例， 

该实例可用作引用。此订单具有唯一的  ref 标识符，可用于比较。  

注意  ，特定经纪实现的 Order 子类可能携带经纪提供的其他唯一标识符。  

要创建订单，请使用以下参数：  

  
﻿  

参数名                   默认值                   描述  

data                  None                  创建订单的数据。如果为  

                                            None，则使用系统中的第 

                                            一个数据 self.datas[0]  

                                            或 self.data0  （即  

                                            self.data ）。  

size                  None                  要使用的订单数量（正 

                                            值）。如果为 None，则使 

                                            用通过 getsizer 检索到 

                                            的 sizer 实例来确定大 

                                            小。  

price                 None）                 使用的价格（实时经纪可 

                                            能对格式有最低价格步长 

                                            要求）。对于市场和收盘 

                                            订单（Market 和 Close  

                                            orders）为 None （市场 

                                            决定价格）。对于限价、 

                                            止损和止损限价订单，这 

                                            个值决定触发点。  

plimit                None                  仅适用于止损限价订单。 

                                            这是在触发止损后设置隐 

                                            含限价订单的价格（使用  

                                            price ）。  

exectype              None                  可能的值：  

                                            •  - Order.Market 或  

                                            None ：市场订单将以下一 

                                            个可用价格执行。在回测 

                                            中，将是下一个 bar 的开 

                                            盘价。  

                                            •  - Order.Limit  ：订 

                                            单只能以给定价格或更好 

                                            价格执行。  

  
﻿  

                                                  •  - Order.Stop  ：订单 

                                                 在 price 触发时被触发， 

                                                  并像 Order.Market 订单 

                                                 一样执行。  

                                                  •  -  
                                                 Order.StopLimit  ：订 

                                                 单在 price 触发时被触 

                                                 发，并作为隐含的限价订 

                                                 单执行，限价由  

                                                  pricelimit 给出。  

valid                    None                    可能的值：  

                                                  •  - None ：生成一个不 

                                                 会过期的订单（即 Good  

                                                 til cancel），并保留在市场 

                                                 上直到匹配或取消。实际 

                                                 上，经纪通常会施加一个 

                                                  时间限制，但通常远远在 

                                                 未来，可以认为它不会过 

                                                 期。  

                                                  •  -  
                                                 datetime.datetime 或  

                                                 datetime.date 实例：日 

                                                 期将用于生成有效期至给 

                                                 定日期的订单（即 good  

                                                 til date）。  

                                                  •  - Order.DAY 或 0 或  

                                                 timedelta()  ：生成一个 

                                                 有效期至交易日结束的订 

                                                 单（即日订单）。  

                                                  •  - 数值：假定为  

                                                 matplotlib 编码的  

                                                 datetime 值 

                                                   （ backtrader 使用 

                                                  的），将用于生成有效期 

                                                  至该时间的订单（即  

                                                 good til date）。  

  
﻿  

tradeid                 0                       backtrader 用于跟踪同 

                                                一资产上重叠交易的内部 

                                                值。当通知订单状态变化 

                                                时，此 tradeid 会发送回 

                                                策略。  

示例  ：如果 backtrader 直接支持的 4 种订单执行类型不够，可以为 Interactive  

Brokers 传递以下参数：  

Python  
orderType='LIT', lmtPrice=10.0, auxPrice=9.8  

这将覆盖 backtrader 创建的设置，并生成一个  LIMIT IF TOUCHED 订单，触及价格 

为 9.8 ，限价为  10.0。  

策略信息： #  

属性名                                 描述  

env                                 策略所属的 cerebro 实体  

datas                               传递给 cerebro 的数据源数组  

data/data0                          datas[0]  的别名  

dataX                               datas[X]  的别名  

dnames                              按名称访问数据源的替代方法（通过  

                                    [name] 或 .name 语法）  

broker                              与此策略关联的经纪（从 cerebro 接 

                                    收）  

stats                               包含 cerebro 为此策略创建的观察者的 

                                    列表/命名元组序列  

analyzers                           包含 cerebro 为此策略创建的分析器的 

                                    列表/命名元组序列  

  
﻿  

position                         获取 data0  的当前仓位的属性  

成员属性（用于统计/观察者/分析器）： #  

属性名                              描述  

_orderspending                   将在调用 next 之前通知策略的订单列 

                                 表  

_tradespending                   将在调用 next 之前通知策略的交易列 

                                 表  

_orders                          已经通知的订单列表。订单可以在列表 

                                 中多次出现，具有不同的状态和执行部 

                                 分。列表旨在保留历史记录。  

_trades  ：                       已经通知的交易列表。交易可以像订单 

                                 一样多次出现在列表中。  

注意： prenext  、 nextstart 和 next 可以针对同一时间点多次调用（例如，当使用 

每日时间框架时，价格更新每日 bar 的 ticks）。  

策略参考 #  

class backtrader.Strategy(*args, **kwargs)  

基类，用于子类化用户定义的策略。  

方法 #  

方法名                              描述  

next()                           当所有数据/指标的最小周期满足时，将 

                                 为所有剩余数据点调用此方法。  

nextstart()                      当所有数据/指标的最小周期满足时，将 

                                 调用一次此方法。默认行为是调用  

                                 next  。  

  
﻿  

prenext()                          在满足所有数据/指标的最小周期之前调 

                                   用此方法。  

start()                            在回测即将开始之前调用。  

stop()                             在回测即将结束之前调用。  

notify_order(order)                当订单状态变化时接收通知。  

notify_trade(trade)                当交易状态变化时接收通知。  

notify_cashvalue(cash, value)      接收策略经纪账户的当前资金和投资组 

                                   合状态。  

notify_fund(cash, value,           接收当前现金、投资组合、基金价值和 
fundvalue, shares)                 份额。  

notify_store(msg, *args,           接收存储提供者的通知。  
**kwargs)  

订单方法 #  

方法名                                描述  

buy(...)                           创建买入订单并发送给经纪。  

sell(...)                          创建卖出（空头）订单并发送给经纪。  

close(...)  ：                      关闭现有仓位。  

cancel(order)                      取消经纪中的订单。  

其他方法 #  

方法名                                描述  

buy_bracket(...)                   创建括号订单组（低侧 - 买入订单 - 高 

                                   侧）。  

  
﻿  

sell_bracket(...)                      创建括号订单组（低侧 - 卖出订单 - 高 

                                       侧）。  

order_target_size(...)                 下订单将仓位重新平衡为目标大小。  

order_target_value(...)                下订单将仓位重新平衡为目标价值。  

order_target_percent(...)              下订单将仓位重新平衡为当前投资组合 

                                       价值的目标百分比。  

getsizer()                             返回用于自动计算头寸的 sizer  。  

setsizer(sizer)                        替换默认的 sizer  。  

getsizing(data=None, isbuy=True)       返回 sizer 实例为当前情况计算的头 

                                       寸。  

getpositionbyname(name=None,           按名称返回给定经纪的当前仓位。  
broker=None)  

getposition(data=None,                 返回给定数据和经纪的当前仓位。  
broker=None)  

getpositionsbyname(broker=None)        直接从经纪获取按名称的所有仓位。  

getdatanames()                         返回现有数据名称的列表。  

getdatabyname(name)                    使用环境（cerebro）按名称返回给定数 

                                       据。  

add_timer(...)                         计划一个计时器以调用指定的回调或策 

                                       略的 notify_timer  。  

notify_timer(timer, when, *args,  接收计时器通知，其中 timer 是由  
**kwargs)                              add_timer 返回的计时器， when 是调 

                                       用时间。 args 和 kwargs 是传递给  

                                       add_timer  的额外参数。  

    

  
